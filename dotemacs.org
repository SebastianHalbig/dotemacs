#+TITLE: Emacs literate configuration
#+AUTHOR: Sebastian Halbig
#+DATE: 04/2022
#+STARTUP: show2levels indent hidestars
#+PROPERTY: header-args :tangle (let ((org-use-tag-inheritance t)) (if (member "INACTIVE" (org-get-tags))  "no" "~/.emacs.d/init.el")))

* Documentation
** Forewords

This document is a literate configuration for GNU Emacs written in [[https://orgmode.org/][org]] format. It is an adaptation of Nicolas P. Rougier's brilliant work. It cannot be used directly and needs to be transformed to extract all the different code blocks into a single configuration file. This is done using the [[help:org-babel-tangle][org-babel-Utangle]] function that "extract the bodies of all source code blocks from the current file into their own source-specific files". You can try by yourself by typing the sequence: =C-c C-v t= (org-babel-execute-subtree).

However, on my Emacs (28.1), there seems to be a bug that prevent a proper tangling. You'll thus need to go to the [[Configuration]] section and execute it using =C-c C-v s= to fix this bug before tangling the file.

Each subsection may be tagged with:

- =:BINDING:=  The section defines some key binding
- =:HOOK:=     The section installs some hook
- =:ADVICE:=   The section installs some advice
- =:FACE:=     The section modifies some face
- =:MODE:=     The section activates a mode
- =:DEFER:=    The content of the section is deferred (lazy load)
- =:PERSONAL:= The content is personal and should be adapted
- =:INACTIVE:= The content of the section won't be exported
- =:BUGFIX:=   The section contains (temporary) bug fix code
- =:OTHER:=    The section will be exported to a different file than default
- =:TIMER:=    The section installs a timer
- =:OS:=       The section contains some system specific code

There is also a configuration mode defined in the section below to ease the writing.

When tangled, the process will create the files[[file:~/.emacs.d/init.el][~/.emacs.d/init.el]] and [[file:~/.emacs.d/early-init.el][~/.emacs.d/early-init.el]] (from the [[Early init]] section).

Note also that the first time you will start emacs using this configuration, *it will take a long time* because a lof of packages will be dowloaded, installed and possibly compiled (if you use Emacs 28 and above).

** To sort :INACTIVE:

#+begin_src emacs-lisp

(setq-default
 ad-redefinition-action 'accept         ; Silence warnings for redefinition
 custom-unlispify-menu-entries nil      ; Prefer kebab-case for titles
 custom-unlispify-tag-names nil         ; Prefer kebab-case for symbols
(put 'downcase-region 'disabled nil)    ; Enable downcase-region
(put 'upcase-region 'disabled nil)      ; Enable upcase-region
 native-comp-async-report-warnings-errors nil ; Skip compilation error buffers
 read-process-output-max (* 1024 1024)  ; Increase read size per process

#+end_src

** To do [5/12] :INACTIVE:

- [X] Tangle file when saving (org-auto-tangle)
- [X] Hitting `space` on top node should open the node (instead of folding)
- [X] Dim inactive entries in the sidebar
- [X] Shift-tab to toggle sidebar (all entries)
- [X] Filter sidebar (`f` key)
- [ ] Integrate  LaTeX settings into this config
- [ ] Configure the mail settings
- [ ] Build a usefull startup screen
- [ ] Work on the agenda settings
- [ ] Work on org-roam settings
- [ ] Setup dirvish
- [ ] Fix keybindings
- [ ] use use-package consequently


* Core

** Header

This will generate a header at the top of the tangled file to indicate it is generated and is not meant to be modified directly.

#+begin_src emacs-lisp :epilogue (format-time-string ";; Last generated on %c")

;; -*- lexical-binding: t -*-
;; This file has been generated from dotemacs.org file. DO NOT EDIT.
;; Based on from https://github.com/rougier/dotemacs

;; Copyright (C) 2022 Nicolas P. Rougier

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; For a full copy of the GNU General Public License
;; see <https://www.gnu.org/licenses/>.

#+end_src

#+begin_src emacs-lisp

(defvar my-init-start-time (current-time) "Time when init.el was started")
(defvar my-section-start-time (current-time) "Time when section was started")
(defun my-report-time (section)
  (message "%-36s %.2fs"
           (concat section " " "section time: ")
           (float-time (time-subtract (current-time) my-section-start-time))))
(message "---------------------------------------------------------------")

#+end_src

** Packages management :PERSONAL:

Using [[https://github.com/raxod502/straight.el][straight.el]] for package management and disable checking (for speedup).

#+begin_src emacs-lisp

(setq straight-check-for-modifications nil)

#+end_src

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+end_src

Library and theme load paths with a special case for mu4e (you may need to adapt this path).

#+begin_src emacs-lisp

(add-to-list 'load-path
             (expand-file-name "lisp" user-emacs-directory))
(add-to-list 'custom-theme-load-path
             (expand-file-name "theme" user-emacs-directory))
(add-to-list 'load-path
             "/usr/share/emacs/site-lisp/mu4e/mu4e.el")

#+end_src

Load uses the newest version possible.

#+begin_src emacs-lisp

(setq load-prefer-newer t) ; always choose the newest version of a package

#+end_src

** Packages installation :CLEANUP:

Packages used in this specific configuration. You may want to adapt this list. The first time this sequence will be executed, *it will take a long time*. Then, at next restart, it should be very fast (less than 1 second because it won't install anything basically).

#+begin_src emacs-lisp

(setq package-list
      '(all-the-icons       ; ICONS
        projectile          ; TODO
        adaptive-wrap       ; A version of adaptive-line-wrap that does not alter the text.
        dirvish             ; A modern file manager
        anzu                ; Show number of matches in modeline
        swiper              ; Better search with swiper
        lsp-mode            ; Implementation of language server protocol
        dictcc              ; Online DE/EN dictionary interface
        flyspell-lazy       ; Lazy flyspell-completion
        puni                ; Parenthesis handeling
        rainbow-delimiters  ; Make parentheses sexy
        cdlatex             ; LaTeX features
        laas                ; LaTeX autocompleting snippes
        latex-extra         ; Addons for LaTeX-mode
        ergoemacs-mode      ; "Modern" key-bindings
        fira-code-mode      ; Fira code ligatures
        oauth               ; Oauth library
        offlineimap         ; OfflineIMAP from Emacs
        org-bullets         ; Bullet points for org mode
        org-modern          ; Nicer org mode
        org-super-agenda    ; TODO ???
        org-recur           ; For recurring tasks
        selectrum           ; TODO REMOVE?
        selectrum-prescient ; TODO REMOVE?
        wgrep               ; TODO REMOVE?
        undo-tree           ; Undo history presented in a tree
        cape                ; Completion At Point Extensions
        orderless           ; Completion style for matching regexps in any order
        vertico             ; VERTical Interactive COmpletion
        marginalia          ; Enrich existing commands with completion annotations
        consult             ; Consulting completing-read
        corfu               ; Completion Overlay Region FUnction
        ;;deft                ; Quickly browse, filter, and edit plain text notes
        ;;elpher              ; A friendly gopher and gemini client
        elfeed              ; Emacs Atom/RSS feed reader
        elfeed-org          ; Configure elfeed with one or more org-mode files
        ;;f                   ; Modern API for working with files and directories
        citar               ; Citation-related commands for org, latex, markdown
        ;;citeproc            ; A CSL 1.0.2 Citation Processor
        flyspell-correct-popup ; Correcting words with flyspell via popup interface
        flyspell-popup      ; Correcting words with Flyspell in popup menus
        guess-language      ; Robust automatic language detection
        helpful             ; A better help buffer
        htmlize             ; Convert buffer text and decorations to HTML
        mini-frame          ; Show minibuffer in child frame on read-from-minibuffer
        imenu-list          ; Show imenu entries in a separate buffer
        magit               ; A Git porcelain inside Emacs.
        ;;markdown-mode       ; Major mode for Markdown-formatted text
        multi-term          ; Managing multiple terminal buffers in Emacs.
        pinentry            ; GnuPG Pinentry server implementation
        use-package         ; A configuration macro for simplifying your .emacs
        vc-backup           ; VC backend for versioned backups
        ;;yaml-mode           ; YAML mode
        ;;consult-recoll      ; Consult interface for recoll query
        org-auto-tangle     ; Tangle org file when it is saved
        exec-path-from-shell; Get environment variables such as $PATH from the shell
        which-key))         ; Display available keybindings in popup

;; Install packages that are not yet installed
(dolist (package package-list)
  (straight-use-package package))

;; AucTeX-LaTeXmk fork
(provide 'tex-buf)
(straight-use-package
 '(auctex-latexmk :type git :host github :repo "aam-at/auctex-latexmk"))

;; Browsing nerd-fonts within emacs
(straight-use-package
 '(nerd-fonts :type git :host github :repo "twlz0ne/nerd-fonts.el"))

;; Special case for pdf-tools that has recently (2022) changed maintainer
(straight-use-package
 '(pdf-tools :type git :host github :repo "vedang/pdf-tools"))

;; Denote not yet on ELPA (2022-06-19)
(straight-use-package
 '(denote :type git :host github :repo "protesilaos/denote"))

#+end_src

Packages of N. Rougier

#+begin_src emacs-lisp

;; Display org properties in the agenda buffer (modified version)
(straight-use-package
 '(org-agenda-property :type git :host github :repo "Malabarba/org-agenda-property"
                       :fork (:host github :repo "rougier/org-agenda-property")))

;; NANO splash
(straight-use-package
 '(nano-splash :type git :host github :repo "rougier/nano-splash"))

;; NANO theme
(straight-use-package
 '(nano-theme :type git :host github :repo "rougier/nano-theme"))

;; NANO modeline
(straight-use-package
 '(nano-modeline :type git :host github :repo "rougier/nano-modeline"))

;; NANO agenda
(straight-use-package
 '(nano-agenda :type git :host github :repo "rougier/nano-agenda"))

;; NANO agenda
(straight-use-package
 '(minibuffer-header :type git :host github :repo "rougier/minibuffer-header"))

;; SVG tags, progress bars & icons
(straight-use-package
 '(svg-lib :type git :host github :repo "rougier/svg-lib"))

;; Replace keywords with SVG tags
(straight-use-package
 '(svg-tag-mode :type git :host github :repo "rougier/svg-tag-mode"))

;; Dashboard for mu4e
(straight-use-package
 '(mu4e-dashboard :type git :host github :repo "rougier/mu4e-dashboard"))

;; Folding mode for mu4e
(straight-use-package
 '(mu4e-folding :type git :host github :repo "rougier/mu4e-folding"))

;; Relative date formatting
(straight-use-package
 '(relative-date :type git :host github :repo "rougier/relative-date"))

;; org imenu
(straight-use-package
 '(org-imenu :type git :host github :repo "rougier/org-imenu"))

;; pdf-drop-mode
(straight-use-package
 '(pdf-drop-mode :type git :host github :repo "rougier/pdf-drop-mode"))


;; Bilbliography manager in org mode
(straight-use-package
 '(org-bib :type git :host github :branch "org-imenu" :repo "rougier/org-bib-mode"))

#+end_src

** TODO Startup :ENHANCE:

Emacs does a lot of things at startup and here, we disable pretty much everything.

#+begin_src emacs-lisp

(setq
 inhibit-startup-screen t               ; Disable start-up screen
 inhibit-startup-message t              ; Disable startup message
 inhibit-startup-echo-area-message t    ; Disable initial echo message
 initial-scratch-message ""             ; Empty the initial *scratch* buffer
 initial-buffer-choice t                ; Open *scratch* buffer at init
 native-comp-async-report-warnings-errors 'silent) ; Do not focus the warnings buffer

(add-hook 'after-init-hook (lambda () (org-agenda nil "a")))
(setq org-agenda-window-setup 'current-window)

#+end_src

** Encoding and locale

We tell emacs to use UTF-8 encoding as much as possible.

#+begin_src emacs-lisp

(set-default-coding-systems 'utf-8)     ; Default to utf-8 encoding
(prefer-coding-system       'utf-8)     ; Add utf-8 at the front for automatic detection.
(set-terminal-coding-system 'utf-8)     ; Set coding system of terminal output
(set-keyboard-coding-system 'utf-8)     ; Set coding system for keyboard input on TERMINAL
(set-language-environment "English")    ; Set up multilingual environment
(setq calendar-date-style 'european     ; European style calenders
      calendar-week-start-day '1)       ; The week starts on Monday

#+end_src

** Recovery

If Emacs or the computer crashes, you can recover the files you were editing at the time of the crash from their auto-save files. To do this, start Emacs again and type the command ~M-x recover-session~. Here, we parameterise how files are saved in the background.

#+begin_src emacs-lisp

(setq auto-save-list-file-prefix ; Prefix for generating auto-save-list-file-name
      (expand-file-name ".auto-save-list/.saves-" user-emacs-directory)
      auto-save-default t        ; Auto-save every buffer that visits a file
      auto-save-timeout 20       ; Number of seconds between auto-save
      auto-save-interval 200)    ; Number of keystrokes between auto-saves

#+end_src

** Backups

Emacs carefully copies the old contents to another file, called the “backup” file, before actually saving. Emacs makes a backup for a file only the first time the file is saved from a buffer. No matter how many times you subsequently save the file, its backup remains unchanged. However, if you kill the buffer and then visit the file again, a new backup file will be made. Here, we activate backup and parameterise the number of backups to keep.

#+begin_src emacs-lisp


(setq backup-directory-alist       ; File name patterns and backup directory names.
      `(("." . ,(expand-file-name "backups" user-emacs-directory)))
      make-backup-files t          ; Backup of a file the first time it is saved.
      vc-make-backup-files t       ; No backup of files under version contr
      backup-by-copying t          ; Don't clobber symlinks
      version-control t            ; Version numbers for backup files
      delete-old-versions t        ; Delete excess backup files silently
      kept-old-versions 6          ; Number of old versions to keep
      kept-new-versions 9          ; Number of new versions to keep
      delete-by-moving-to-trash t) ; Delete files to trash

;; Back
(require 'vc-backup)

#+end_src

** Bookmarks

#+begin_src emacs-lisp

(setq bookmark-default-file (expand-file-name "bookmark" user-emacs-directory))

#+end_src

** Recent files

50 Recents files with some exclusion (regex patterns).

#+begin_src emacs-lisp

(require 'recentf)

(setq recentf-max-menu-items 10
      recentf-max-saved-items 100
      recentf-exclude '("~/Documents/.mails/"))

(let (message-log-max)
  (recentf-mode 1))

#+end_src

** History :HOOK:

Remove text properties for kill ring entries (see https://emacs.stackexchange.com/questions/4187). This saves a lot of time when loading it.

#+begin_src emacs-lisp

(defun unpropertise-kill-ring ()
  (setq kill-ring (mapcar 'substring-no-properties kill-ring)))

(add-hook 'kill-emacs-hook 'unpropertise-kill-ring)

#+end_src

We save every possible history we can think of.

#+begin_src emacs-lisp

(require 'savehist)

(setq kill-ring-max 50
      history-length 50)

(setq savehist-additional-variables
      '(kill-ring
        command-history
        set-variable-value-history
        custom-variable-history
        query-replace-history
        read-expression-history
        minibuffer-history
        read-char-history
        face-name-history
        bookmark-history
        file-name-history))

(put 'minibuffer-history         'history-length 50)
(put 'file-name-history          'history-length 50)
(put 'set-variable-value-history 'history-length 25)
(put 'custom-variable-history    'history-length 25)
(put 'query-replace-history      'history-length 25)
(put 'read-expression-history    'history-length 25)
(put 'read-char-history          'history-length 25)
(put 'face-name-history          'history-length 25)
(put 'bookmark-history           'history-length 25)

#+end_src

No duplicates in history

#+begin_src emacs-lisp

(setq history-delete-duplicates t)

#+end_src

Start history mode.

#+begin_src emacs-lisp

(let (message-log-max)
  (savehist-mode))

#+end_src

** Saving

#+begin_src emacs-lisp

(add-hook 'before-save-hook 'delete-trailing-whitespace) ; On save, delete trailing whitespaces
(setq require-final-newline t)                ; Require a final newline—POSIX BOIS

#+end_src

** Cursor

Record cursor position from one session ot the other

#+begin_src emacs-lisp

(setq save-place-file (expand-file-name "saveplace" user-emacs-directory)
      save-place-forget-unreadable-files t)

(save-place-mode 1)

#+end_src

** Customisation

Since init.el will be generated from this file, we save customisation in a dedicated file.

#+begin_src emacs-lisp

(setq custom-file (concat user-emacs-directory "custom.el"))

(when (file-exists-p custom-file)
  (load custom-file nil t))

#+end_src

** Server

Server start.

#+begin_src emacs-lisp

(require 'server)

(unless (server-running-p)
  (server-start))

#+end_src

** Keybindings

A "modern" keyboard layout is provided by ergoemacs.

#+begin_src emacs-lisp

(use-package ergoemacs-mode
  :config
  (setq ergoemacs-theme nil)            ;; Uses Standard Ergoemacs keyboard theme
  (setq ergoemacs-keyboard-layout "us") ;; Assumes QWERTY keyboard layout
  (ergoemacs-mode 1)                    ;; Globally enables ergoemacs-mode
  )
#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Core")

#+end_src


* Personal library

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

Some functions that are used throughout this configuration.

** String related

A set of functions to join two strings such as to fit a given width. This will be used for displaying elfeed posts, privileging the right part (tag and feed).

#+name: my-string-pad-right
#+begin_src emacs-lisp

(defun my-string-pad-right (len s)
  "If S is shorter than LEN, pad it on the right,
   if S is longer than LEN, truncate it on the right."

  (if (> (length s) len)
      (concat (substring s 0 (- len 1)) "…")
    (concat s (make-string (max 0 (- len (length s))) ?\ ))))

#+end_src

#+name: my-string-pad-left
#+begin_src emacs-lisp

(defun my-string-pad-left (len s)
  "If S is shorter than LEN, pad it on the left,
   if S is longer than LEN, truncate it on the left."

  (if (> (length s) len)
      (concat  "…" (substring s (- (length s) len -1)))
    (concat (make-string (max 0 (- len (length s))) ?\ ) s)))

#+end_src

#+name: my-string-join
#+begin_src emacs-lisp

(defun my-string-join (len left right &optional spacing)
  "Join LEFT and RIGHT strings to fit LEN characters with at least SPACING characters
between them. If len is negative, it is retrieved from current window width."

  (let* ((spacing (or spacing 3))
         (len (or len (window-body-width)))
         (len (if (< len 0)
                  (+ (window-body-width) len)
                len)))
    (cond ((> (length right) len)
           (my-string-pad-left len right))

          ((> (length right) (- len spacing))
           (my-string-pad-left len (concat (make-string spacing ?\ )
                                           right)))

          ((> (length left) (- len spacing (length right)))
           (concat (my-string-pad-right (- len spacing (length right)) left)
                   (concat (make-string spacing ?\ )
                           right)))
          (t
           (concat left
                   (make-string (- len (length right) (length left)) ?\ )
                   right)))))

#+end_src

** Date related

A set of date related functions, mostly used for mail display.

#+name: my-date-day
#+begin_src emacs-lisp

(defun my-date-day (date)
  "Return DATE day of month (1-31)."

  (nth 3 (decode-time date)))

#+end_src

#+name: my-date-month
#+begin_src emacs-lisp

(defun my-date-month (date)
  "Return DATE month number (1-12)."

  (nth 4 (decode-time date)))

#+end_src

#+name: my-date-year
#+begin_src emacs-lisp

(defun my-date-year (date)
  "Return DATE year."

  (nth 5 (decode-time date)))

#+end_src

#+name: my-date-equal
#+begin_src emacs-lisp

(defun my-date-equal (date1 date2)
  "Check if DATE1 is equal to DATE2."

  (and (eq (my-date-day date1)
           (my-date-day date2))
       (eq (my-date-month date1)
           (my-date-month date2))
       (eq (my-date-year date1)
           (my-date-year date2))))

#+end_src

#+name: my-date-inc
#+begin_src emacs-lisp

(defun my-date-inc (date &optional days months years)
  "Return DATE + DAYS day & MONTH months & YEARS years"

  (let ((days (or days 0))
        (months (or months 0))
        (years (or years 0))
        (day (my-date-day date))
        (month (my-date-month date))
        (year (my-date-year date)))
    (encode-time 0 0 0 (+ day days) (+ month months) (+ year years))))

#+end_src

#+name: my-date-dec
#+begin_src emacs-lisp

(defun my-date-dec (date &optional days months years)
  "Return DATE - DAYS day & MONTH months & YEARS years"

  (let ((days (or days 0))
        (months (or months 0))
        (years (or years 0)))
    (my-date-inc date (- days) (- months) (- years))))

#+end_src

#+name: my-date-today
#+begin_src emacs-lisp

(defun my-date-today ()
  "Return today date."

  (current-time))

#+end_src

#+name: my-date-is-today
#+begin_src emacs-lisp

(defun my-date-is-today (date)
  "Check if DATE is today."

  (my-date-equal (current-time) date))

#+end_src

#+name: my-date-is-yesterday
#+begin_src emacs-lisp

(defun my-date-is-yesterday (date)
  "Check if DATE is yesterday."

  (my-date-equal (my-date-dec (my-date-today) 1) date))

#+end_src

#+name: my-date-relative
#+begin_src emacs-lisp

(defun my-date-relative (date)
  "Return a string with a relative date format."

  (let* ((now (current-time))
         (delta (float-time (time-subtract now date)))
         (days (ceiling (/ (float-time (time-subtract now date)) (* 60 60 24)))))
    (cond ((< delta (*       3 60))     "now")
          ((< delta (*      60 60))     (format "%d minutes ago" (/ delta   60)))
          ;;  ((< delta (*    6 60 60))     (format "%d hours ago"   (/ delta 3600)))
          ((my-date-is-today date)      (format-time-string "%H:%M" date))
          ((my-date-is-yesterday date)  (format "Yesterday"))
          ((< delta (* 4 24 60 60))     (format "%d days ago" (+ days 1)))
          (t                            (format-time-string "%d %b %Y" date)))))

#+end_src

** Mini frame

A set of functions to create a mini-frame over the header line.

#+begin_src emacs-lisp

(defun my-mini-frame (&optional height foreground background border)
  "Create a child frame positionned over the header line whose
width corresponds to the width of the current selected window.

The HEIGHT in lines can be specified, as well as the BACKGROUND
color of the frame. BORDER width (pixels) and color (FOREGROUND)
can be also specified."

  (interactive)
  (let* ((foreground (or foreground
                         (face-foreground 'font-lock-comment-face nil t)))
         (background (or background (face-background 'highlight nil t)))
         (border (or border 1))
         (height (round (* (or height 8) (window-font-height))))
         (edges (window-pixel-edges))
         (body-edges (window-body-pixel-edges))
         (top (nth 1 edges))
         (bottom (nth 3 body-edges))
         (left (- (nth 0 edges) (or left-fringe-width 0)))
         (right (+ (nth 2 edges) (or right-fringe-width 0)))
         (width (- right left))

         ;; Window divider mode
         (width (- width (if (and (bound-and-true-p window-divider-mode)
                                  (or (eq window-divider-default-places 'right-only)
                                      (eq window-divider-default-places t))
                                  (window-in-direction 'right (selected-window)))
                             window-divider-default-right-width
                           0)))
         (y (- top border))
         (child-frame-border (face-attribute 'child-frame-border :background)))
    (set-face-attribute 'child-frame-border t :background foreground)
    (let ((frame (make-frame
                  `((parent-frame . ,(window-frame))
                    (delete-before . ,(window-frame))
                    (minibuffer . nil)
                    (modeline . nil)
                    (left . ,(- left border))
                    (top . ,y)
                    (width . (text-pixels . ,width))
                    (height . (text-pixels . ,height))
                    ;; (height . ,height)
                    (child-frame-border-width . ,border)
                    (internal-border-width . ,border)
                    (background-color . ,background)
                    (horizontal-scroll-bars . nil)
                    (menu-bar-lines . 0)
                    (tool-bar-lines . 0)
                    (desktop-dont-save . t)
                    (unsplittable . nil)
                    (no-other-frame . t)
                    (undecorated . t)
                    (pixelwise . t)
                    (visibility . t)))))
      (set-face-attribute 'child-frame-border t :background child-frame-border)
      frame)))

#+end_src

#+begin_src emacs-lisp

(defun my-mini-frame-reset (frame)
  "Reset FRAME size and position.

  Move frame at the top of parent frame and resize it
  horizontally to fit the width of current selected window."

  (interactive)
  (let* ((border (frame-parameter frame 'internal-border-width))
         (height (frame-parameter frame 'height)))
    (with-selected-frame (frame-parent frame)
      (let* ((edges (window-pixel-edges))
             (body-edges (window-body-pixel-edges))
             (top (nth 1 edges))
             (bottom (nth 3 body-edges))
             (left (- (nth 0 edges) (or left-fringe-width 0)))
             (right (+ (nth 2 edges) (or right-fringe-width 0)))
             (width (- right left))
             (y (- top border)))
        (set-frame-width frame width nil t)
        (set-frame-height frame height)
        (set-frame-position frame (- left border) y)))))

#+end_src

#+begin_src emacs-lisp

(defun my-mini-frame-shrink (frame &optional delta)
  "Make the FRAME DELTA lines smaller.

  If no argument is given, make the frame one line smaller. If
  DELTA is negative, enlarge frame by -DELTA lines."

  (interactive)
  (let ((delta (or delta -1)))
    (when (and (framep frame)
               (frame-live-p frame)
               (frame-visible-p frame))
      (set-frame-parameter frame 'height
                           (+ (frame-parameter frame 'height) delta)))))

#+end_src

** Mu4e related

A set of mail (mu4e) related functions.

#+name: my-mu4e-get-account
#+begin_src emacs-lisp

(defun my-mu4e-get-account (msg)
  "Get MSG related account."

  (let* ((maildir (mu4e-message-field msg :maildir))
         (maildir (substring maildir 1)))
    (nth 0 (split-string maildir "/"))))

#+end_src

#+name: my-mu4e-get-maildir
#+begin_src emacs-lisp

(defun my-mu4e-get-maildir (msg)
  "Get MSG related maildir."

  (let* ((maildir (mu4e-message-field msg :maildir))
         (maildir (substring maildir 1)))
    (nth 0 (reverse (split-string maildir "/")))))

#+end_src

#+name: my-mu4e-get-mailbox
#+begin_src emacs-lisp

(defun my-mu4e-get-mailbox (msg)
  "Get MSG related mailbox as 'account - maildir' "

  (format "%s - %s" (mu4e-get-account msg) (mu4e-get-maildir msg)))

#+end_src

#+name: my-mu4e-get-sender
#+begin_src emacs-lisp

(defun my-mu4e-get-sender (msg)
  "Get MSG sender."

  (let ((addr (cdr-safe (car-safe (mu4e-message-field msg :from)))))
    (mu4e~headers-contact-str (mu4e-message-field msg :from))))

#+end_src

** TODO Better search :BINDING:

Bound to the =C-s=, this function provides an integrated search and regexp-replace environment. Invoking it once opens the search with the active region as its default input. Typing a new string, deletes the default query and replaces it. If there is no default input, the arrow keys allow to navigate the search history (of the active buffer). Iterated calling of ~my-search()~, toggles between search and regexp-replace mode.

#+begin_src emacs-lisp

(bind-key "C-f" #'my-consult-line `ergoemacs-override-keymap)

#+end_src

** TODO Configuration :BINDING:HOOK:DEFER:
# :PROPERTIES:
# :header-args:emacs-lisp: :prologue "(with-eval-after-load 'org" :epilogue ")"
# :END:

*** General

This section is meant to ease the writing of the configuration file using a dedicated minor mode (~my-config-mode~) with a few key bindings:

=C-`=       : Toggle navigation sidebar
=C-c C-p=   : Go to previous subsection
=C-c C-n=   : Go to next subsection
=C-c C-S-p= : Go to previous section
=C-c C-S-n= : Go to next section
=C-c t=     : Fold code blocks
=C-c f=     : Filter block visibility (sidebar)
=C-c C-v t= : Export (tangle) code
=C-c C-v s= : Execute current subsection

Before being able to use it, you need to execute the whole subtree using [[help:org-babel-execute-subtree][org-babel-execute-subtree]] (generally bound to =C-c C-v s=).

*** Sidebar :BINDING:

This defines an org sidebar using imenu-list.

#+name: my-org-sidebar
#+begin_src emacs-lisp

(require 'imenu)
(require 'imenu-list)

(defun my-org-tree-to-indirect-buffer ()
  "Create indirect buffer, narrow it to current subtree and unfold blocks"

  (org-tree-to-indirect-buffer)
  (org-show-block-all)
  (setq-local my-org-blocks-hidden nil))

(defun my-org-sidebar ()
  "Open an imenu list on the left that allow navigation."

  (interactive)
  (setq imenu-list-after-jump-hook #'my-org-tree-to-indirect-buffer
        imenu-list-position 'left
        imenu-list-size 36
        imenu-list-focus-after-activation t)

  (let ((heading (substring-no-properties (or (org-get-heading t t t t) ""))))
    (when (buffer-base-buffer)
      (switch-to-buffer (buffer-base-buffer)))
    (imenu-list-minor-mode)
    (imenu-list-stop-timer)
    (hl-line-mode)
    (face-remap-add-relative 'hl-line :inherit 'nano-subtle)
    (setq header-line-format
          '(:eval
            (nano-modeline-render nil
                                  (buffer-name imenu-list--displayed-buffer)
                                  "(outline)"
                                  "")))
    (setq-local cursor-type nil)
    (when (> (length heading) 0)
      (goto-char (point-min))
      (search-forward heading)
      (imenu-list-display-dwim))))

#+end_src

#+RESULTS: my-org-sidebar
: my-org-sidebar

This toggles the org-sidebar.

#+name: org-sidebar-toggle
#+begin_src emacs-lisp

(defun my-org-sidebar-toggle ()
  "Toggle the org-sidebar"

  (interactive)
  (if (get-buffer-window "*Ilist*")
      (progn
        (quit-window nil (get-buffer-window "*Ilist*"))
        (switch-to-buffer (buffer-base-buffer)))
    (my-org-sidebar)))

#+end_src

#+RESULTS: org-sidebar-toggle
: my-org-sidebar-toggle

Make sure tangle is applied to the base buffer and not the subtree.

#+name: my-org-babel-tangle
#+begin_src emacs-lisp

(defun my-org-babel-tangle ()
  "Write code blocks to source-specific files from the base buffer."

  (interactive)
  (with-current-buffer (or (buffer-base-buffer)
                           (current-buffer))
    (org-babel-tangle)))

#+end_src

#+RESULTS: my-org-babel-tangle
: my-org-babel-tangle


Toggle code blocks folding, starting folded.

#+name: my-org-toggle-blocks
#+begin_src emacs-lisp

(defvar my-org-blocks-hidden nil)

(defun my-org-toggle-blocks ()
  "Toggle code blocks folding."

  (interactive)
  (if my-org-blocks-hidden
      (org-show-block-all)
    (org-hide-block-all))
  (setq-local my-org-blocks-hidden (not my-org-blocks-hidden)))

(add-hook 'config-mode-hook #'my-org-toggle-blocks)

#+end_src

#+RESULTS: my-org-toggle-blocks
| my-org-toggle-blocks |


#+begin_src emacs-lisp

(defvar my-imenu-list-folding-status t
  "Folding status of the imenu-list")

(defun my-imenu-list-toggle-folding ()
  "Toggle top level nodes of the imenu-list buffer"

  (interactive)
  (with-current-buffer "*Ilist*"
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\+ " nil t)
        (if my-imenu-list-folding-status
            (hs-hide-block)
          (hs-show-block)))
      (setq my-imenu-list-folding-status (not my-imenu-list-folding-status)))))

(bind-key "S-<tab>" #'my-imenu-list-toggle-folding imenu-list-major-mode-map)

#+end_src

#+RESULTS:
: my-imenu-list-toggle-folding

Some information for when a top node is closed

#+begin_src emacs-lisp

(defun my-display-code-line-counts (ov)
  (when (eq 'code (overlay-get ov 'hs))
    (overlay-put ov 'display
                 (propertize
                  (format " [%d sections] … "
                          (- (count-lines (overlay-start ov)
                                          (overlay-end ov)) 1))
                  'face 'nano-faded))))

(setq hs-set-up-overlay #'my-display-code-line-counts)

#+end_src

#+RESULTS:
: my-display-code-line-counts

#+begin_src emacs-lisp

(defun my-imenu-list-display-dwim ()
  "Display or toggle the entry at `point'."
  (interactive)
  (save-selected-window
    (save-excursion
      (my-imenu-list-ret-dwim))))

(defun my-imenu-list-ret-dwim ()
  "Jump to or toggle the entry at `point'."
  (interactive)
  (save-excursion
    (let ((entry (imenu-list--find-entry)))
      (when (imenu--subalist-p entry)
        (setq entry (cons
                     (car entry)
                     (get-text-property 0 'marker (car entry)))))
      (imenu-list--goto-entry entry))))

(bind-key "<SPC>" #'my-imenu-list-display-dwim imenu-list-major-mode-map)
(bind-key "<return>" #'my-imenu-list-ret-dwim imenu-list-major-mode-map)

#+end_src

#+RESULTS:
: my-imenu-list-ret-dwim

*** Filter :BINDING:

This provide the ~my-org-imenu-filter~ that allow to filter sidebar entries using the specified expression (e.g. "+HOOK +DEFER").

#+begin_src emacs-lisp

(bind-key "C-c f" #'my-org-imenu-filter)
(bind-key "f" #'my-org-imenu-filter imenu-list-major-mode-map)
(bind-key "U" #'imenu-list-refresh imenu-list-major-mode-map)

#+end_src

#+RESULTS:
: imenu-list-refresh

3 levels for org-imenu

#+begin_src emacs-lisp

(setq org-imenu-depth 3)

#+end_src

#+RESULTS:
: 3


#+begin_src emacs-lisp

(require 'svg-tag-mode)

(defvar my-org-imenu-filter-history
  '("BINDING" "HOOK" "ADVICE" "FACE" "MODE" "DEFER"
    "PERSONAL" "INACTIVE" "BUGFIX" "OTHER" "TIMER" "OS")
  "Filter history list.")

(with-eval-after-load 'org
  (defvar my-org-imenu-filter-function
    (cdr (org-make-tags-matcher "*"))
    "Filter function to decide if a headline is kept"))

(defun my-org-imenu-filter ()
  "Define and apply a new filter"

  (interactive)
  (let* ((match (completing-read-multiple
                 "FILTER: "
                 my-org-imenu-filter-history
                 nil nil nil
                 'my-org-imenu-filter-history))
         (match (mapconcat #'identity match " ")))
    (when (string= "" match)
      (setq match "*"))
    (setq my-org-imenu-filter-function
          (cdr (org-make-tags-matcher match)))
    (imenu-list-refresh)))


(defun my-org-imenu-filter-tree (&optional bound parent-match)
  "Build a imenu list using current filter function"

  (let* ((headlines '()))
    (save-excursion
      (org-with-wide-buffer
       (unless bound
         (setq bound (point-max))
         (goto-char (point-min)))
       (while (re-search-forward org-heading-regexp bound t)
         (let* ((element (org-element-at-point))
                (begin (org-element-property :begin element))
                (end (org-element-property :end element))
                (marker (copy-marker begin))
                (level (org-element-property :level element))
                (tags (save-excursion
                        (goto-char begin)
                        (org-get-tags)))
                (match (save-excursion
                         (goto-char begin)
                         (funcall my-org-imenu-filter-function
                                  nil (org-get-tags) level)))

                (title (org-element-property :raw-value element))
                (title (org-link-display-format
                        (substring-no-properties title)))
                (title (propertize title 'org-imenu-marker marker
                                   'org-imenu t))
                (title (if (member "INACTIVE" tags)
                           (propertize title 'face 'nano-faded)
                         title))
                (svg-tags (mapconcat #'(lambda (tag)
                                         (propertize tag 'display (svg-tag-make tag :face 'nano-faded)))
                                     tags " "))
                (title (if tags (format "%s %s" title svg-tags) title))
                (title (propertize title 'marker marker))
                (children (my-org-imenu-filter-tree end match)))
           (goto-char end)

           (cond ((> level org-imenu-depth)
                  nil)
                 ((> (length children) 0)
                  (add-to-list 'headlines (append (list title) children) t))
                 ((or match parent-match)
                  (add-to-list 'headlines (cons title marker) t)))))))
    headlines))

(advice-add #'org-imenu-get-tree :override #'my-org-imenu-filter-tree)

#+end_src

#+RESULTS:

*** Configuration mode

This section defines the ~my-config-mode~ to ease navigating and interacting with the configuration file.

Navigation commands using the ilist menu.

#+begin_src emacs-lisp

(defun my-config-mode-prev-header ()
  "Move to previous header"

  (interactive)
  (with-current-buffer "*Ilist*"
    (search-backward-regexp "^  ")
    (imenu-list-display-dwim)))

(defun my-config-mode-next-header ()
  "Move to next header"

  (interactive)
  (with-current-buffer "*Ilist*"
    (forward-line)
    (search-forward-regexp "^  ")
    (imenu-list-display-dwim)))

(defun my-config-mode-prev-section ()
  "Move to previous section"

  (interactive)
  (with-current-buffer "*Ilist*"
    (search-backward-regexp "\\+ " nil nil 2)
    (forward-line)
    (imenu-list-display-dwim)))

(defun my-config-mode-next-section ()
  "Move to next section"

  (interactive)
  (with-current-buffer "*Ilist*"
    (previous-line)
    (search-forward-regexp "\\+ ")
    (forward-line)
    (imenu-list-display-dwim)))

#+end_src

#+RESULTS:
: my-config-mode-next-section

A minor mode for configuration

#+name: config-mode
#+begin_src emacs-lisp

(define-minor-mode my-config-mode
  "Configuration mode"

  :init-value nil
  :global nil
  :keymap (let* ((map (make-sparse-keymap)))
            (bind-key "C-c C-p"   #'my-config-mode-prev-header map)
            (bind-key "C-c C-n"   #'my-config-mode-next-header map)
            (bind-key "C-c C-S-p" #'my-config-mode-prev-section map)
            (bind-key "C-c C-S-n" #'my-config-mode-next-section map)
            (bind-key "C-`"       #'my-org-sidebar-toggle map)
            (bind-key "C-c C-v t" #'my-org-babel-tangle map)
            (bind-key "C-c t"     #'my-org-toggle-blocks map)
            map)

  (require 'org)
  (if my-config-mode
      (my-org-sidebar)))


#+end_src

#+RESULTS: config-mode
| my-config-mode         | keymap | (67108960 . my-org-sidebar-toggle)                                                                                                    | (3 keymap (116 . my-org-toggle-blocks) (22 keymap (116 . my-org-babel-tangle)) (33554446 . my-config-mode-next-section) (33554448 . my-config-mode-prev-section) (14 . my-config-mode-next-header) (16 . my-config-mode-prev-header)) |
| vc-dir-git-mode        | keymap | (122 keymap (112 . vc-git-stash-pop) (115 . vc-git-stash-snapshot) (99 . vc-git-stash))                                               |                                                                                                                                       |
| diff-minor-mode        | keymap | (3 keymap (61 keymap (remap keymap (undo . diff-undo)) (82 . diff-reverse-direction) (114 . diff-restrict-view) (65 . diff-ediff-patch) (111 . diff-goto-source) (87 . widen) (mouse-2 . diff-goto-source) (13 . diff-goto-source) (123 . diff-file-prev) (125 . diff-file-next) (75 . diff-file-kill) (107 . diff-hunk-kill) (backtab . diff-hunk-prev) (9 . diff-hunk-next) (80 . diff-file-prev) (112 . diff-hunk-prev) (78 . diff-file-next) (110 . diff-hunk-next) keymap (103 . revert-buffer) (60 . beginning-of-buffer) (62 . end-of-buffer) (104 . describe-mode) (63 . describe-mode) (127 . scroll-down-command) (33554464 . scroll-down-command) (32 . scroll-up-command) (113 . quit-window) (57 . digit-argument) (56 . digit-argument) (55 . digit-argument) (54 . digit-argument) (53 . digit-argument) (52 . digit-argument) (51 . digit-argument) (50 . digit-argument) (49 . digit-argument) (48 . digit-argument) (45 . negative-argument) (remap keymap (self-insert-command . undefined)))) |                                                                                                                                       |
| gnus-dead-summary-mode | keymap | #^[nil nil keymap                                                                                                                     |                                                                                                                                       |

A shortcut to edit configuration

#+begin_src emacs-lisp :prologue "" :epilogue ""
(defun my-config ()
  "Create a new for editing configuration"

  (interactive)
  (select-frame (make-frame '((name . "my-config")
                              (width . 150)
                              (height . 45))))
  (find-file "~/Documents/GitHub/dotemacs/dotemacs.org")
  (my-config-mode))

#+end_src

#+RESULTS:
: my-config

An autoload function for my-config (that will load org mode).

#+begin_src emacs-lisp :prologue "" :epilogue ""

(autoload 'my-config
  (expand-file-name "init.el" user-emacs-directory)
  "Autoloaded my-config command."
  t)

#+end_src

#+RESULTS:

*** Bugfix :BUGFIX:

*Temporary bugfix* for babel emacs-lisp that does not take into account prologue/epilogue.
See https://list.orgmode.org/CA+G3_PNrdhx0Ejzw8UO7DgZ+ju1B7Ar_eTch5MMViEpKGwqq3w@mail.gmail.com/T/
(November 2020)

#+name: org-babel-expand-body:emacs-lisp
#+begin_src emacs-lisp

(defun my-org-babel-expand-body:emacs-lisp (orig-fun body params)
  "Expand BODY according to PARAMS and call original function with new body"

  (let* ((pro (or (cdr (assq :prologue params)) ""))
         (epi (or (cdr (assq :epilogue params)) ""))
         (body (concat pro body epi)))
    (apply orig-fun `(,body ,params))))

(advice-add 'org-babel-expand-body:emacs-lisp
            :around
            #'my-org-babel-expand-body:emacs-lisp)

#+end_src

#+RESULTS: org-babel-expand-body:emacs-lisp

*** Auto-tangle

Automatically tangle org-mode files with the option #+auto_tangle: t

#+begin_src emacs-lisp

(add-hook 'org-mode-hook 'org-auto-tangle-mode)

#+end_src

#+RESULTS:
| org-auto-tangle-mode | org-tempo-setup | my-org-mode-hook | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] |

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Personal library")

#+end_src


* Interface

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** TODO Frame :BINDING:

A [[help:make-frame][make-frame]] rewrite that creates the frame and switch to the ~*scratch*~ buffer.

#+name: my-new-frame
#+begin_src emacs-lisp

(defun my-make-frame ()
  "Create a new frame and switch to *scratch* buffer."

  (interactive)
  (select-frame (make-frame))
  (switch-to-buffer "*scratch*"))

#+end_src

A function that close the current frame and kill emacs if it was the last frame.

#+name: my-kill-emacs
#+begin_src emacs-lisp

(defun my-kill-emacs ()
  "Delete frame or kill Emacs if there is only one frame."

  (interactive)
  (condition-case nil
      (delete-frame)
    (error (save-buffers-kill-terminal))))

#+end_src

Default frame geometry (large margin: 24 pixels).

#+begin_src emacs-lisp

(require 'frame)

;; Default frame settings
(setq default-frame-alist '((min-height . 1)  '(height . 45)
                            (min-width  . 1)  '(width  . 81)
                            (vertical-scroll-bars . nil)
                            (internal-border-width . 24)
                            (left-fringe . 0)
                            (right-fringe . 0)
                            (tool-bar-lines . 0)
                            (menu-bar-lines . 1)))

;; Default frame settings
(setq initial-frame-alist default-frame-alist)


#+end_src

Frame related binding (self explanatory).

#+begin_src emacs-lisp


(bind-key "M-n"        #'my-make-frame `ergoemacs-override-keymap)
(bind-key "C-x C-c"    #'my-kill-emacs `ergoemacs-override-keymap)
(bind-key "M-`"        #'other-frame `ergoemacs-override-keymap)
;; (bind-key "<M-return>" #'toggle-frame-maximize `ergoemacs-override-keymap)

#+end_src

For frame maximisation, we have to make a specific case for [[help:org-mode][org-mode]].

#+begin_src emacs-lisp

(with-eval-after-load 'org
  (bind-key "<M-return>" #'toggle-frame-maximized 'org-mode-map))

#+end_src

** Window :BINDING:MODE:

Margin and divider mode.

#+begin_src emacs-lisp

(setq-default window-divider-default-right-width 24
              window-divider-default-places 'right-only
              left-margin-width 0
              right-margin-width 0
              window-combination-resize nil) ; Do not resize windows proportionally

(window-divider-mode 1)

#+end_src

Toggle the dedicated flag on the current window

#+name: my-toggle-window-dedicated
#+begin_src emacs-lisp

;; Make a window dedicated
(defun my-toggle-window-dedicated ()
  "Toggle whether the current active window is dedicated or not"
  (interactive)
  (message
   (if (let (window (get-buffer-window (current-buffer)))
         (set-window-dedicated-p window (not (window-dedicated-p window))))
       "Window '%s' is dedicated"
     "Window '%s' is normal")
   (current-buffer))
  (force-window-update))

(bind-key "C-c d" #'my-toggle-window-dedicated `ergoemacs-override-keymap)

#+end_src

Close the window and kill the buffer if its title matches a certain regular expression.
This functionality is bound to ~C-w~.

#+name: my-delete-window
#+begin_src emacs-lisp
(defvar my-kill-buffer-by-regexp "^\*.+\*" "Buffers whose name matches this regular expression are killed upon closing their window")

(defun my-delete-window()
  (interactive)
  "Close the active window. If the buffer-name matches the my-kill-buffer-by-regexp variable, close the buffer first."
  (let ((currently-active-windows (count-windows)))
    (when (or (eq currently-active-windows 1)
              (string-match my-kill-buffer-by-regexp (buffer-name)))
      (ergoemacs-close-current-buffer))
    (unless (eq currently-active-windows 1) (delete-window))))

(bind-key "C-w" #'my-delete-window `ergoemacs-override-keymap)
(bind-key "M-w" #'ergoemacs-close-current-buffer `ergoemacs-override-keymap)
#+end_src

** Buffer :BINDING:

Size of temporary buffers

#+begin_src emacs-lisp

(temp-buffer-resize-mode)
(setq temp-buffer-max-height 8)

#+end_src

Unique buffer names

#+begin_src emacs-lisp

(require 'uniquify)

(setq uniquify-buffer-name-style 'reverse
      uniquify-separator " • "
      uniquify-after-kill-buffer-p t
      uniquify-ignore-buffers-re "^\\*")

#+end_src

No question after killing a buffer (kill-buffer asks you which buffer to switch to)

#+begin_src emacs-lisp

(bind-key "C-x k" #'kill-current-buffer `ergoemacs-override-keymap)

#+end_src
** File :BINDING:PERSONAL:

Thanks to dirvish, navigating through files is now like dancing.

#+begin_src emacs-lisp
(dirvish-override-dired-mode)
#+end_src

Follow symlinks without prompt

,#+begin_src emacs-lisp

(setq vc-follow-symlinks t)

#+end_src

** Dialogues :OS:

Emacs can use a large number of dialogs and popups. Here we get rid of them.

#+begin_src emacs-lisp

(setq-default show-help-function nil    ; No help text
              use-file-dialog nil       ; No file dialog
              use-dialog-box nil        ; No dialog box
              pop-up-windows nil)       ; No popup windows

#+end_src

** Keyboard :MODE:

The mode displays the key bindings following your currently entered incomplete command (a ;; prefix) in a popup.

#+begin_src emacs-lisp

(require 'which-key)

(which-key-mode)

#+end_src

** Cursor :MODE:

We set the appearance of the cursor: vertical line, 3 pixels thick, no blinking

#+begin_src emacs-lisp

(setq-default cursor-in-non-selected-windows nil ; Hide the cursor in inactive windows
              cursor-type '(bar . 3)             ; Vertical cursor
              cursor-intangible-mode t           ; Enforce cursor intangibility
              x-stretch-cursor nil)
                                        ; Don't stretch cursor to the glyph width

(blink-cursor-mode 0)                            ; Blinking cursor

#+end_src

** Text :BINDING:

Pretty self-explanatory

#+begin_src emacs-lisp

(setq-default use-short-answers t                     ; Replace yes/no prompts with y/n
              confirm-nonexistent-file-or-buffer nil) ; Ok to visit non existent files

#+end_src

Replace region when inserting text

#+begin_src emacs-lisp

(delete-selection-mode 1)

#+end_src

A smarter fill/unfill command

#+begin_src emacs-lisp

(defun my-fill-unfill ()
  "Like `fill-paragraph', but unfill if used twice."

  (interactive)
  (let ((fill-column
         (if (eq last-command #'my-fill-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'fill-paragraph)))

(bind-key "M-q"  #'my-fill-unfill)
;; (bind-key [remap fill-paragraph]  #'my-fill-unfill)

#+end_src

** Sound

Disable the bell (auditory or visual).

#+begin_src emacs-lisp

(setq-default visible-bell nil             ; No visual bell
              ring-bell-function 'ignore)  ; No bell

#+end_src

** Mouse :MODE:

Mouse behavior can be finely controlled using the [[help:mouse-avoidance-mode][mouse-avoidance-mode]].

#+begin_src emacs-lisp

(setq-default mouse-yank-at-point t) ; Yank at point rather than pointer
(mouse-avoidance-mode 'exile)        ; Avoid collision of mouse with point

#+end_src

Mouse active in tty mode.

#+begin_src emacs-lisp

(unless (display-graphic-p)
  (xterm-mouse-mode 1)
  (global-set-key (kbd "<mouse-4>") #'scroll-down-line)
  (global-set-key (kbd "<mouse-5>") #'scroll-up-line))

#+end_src

** Scroll

Smoother scrolling.

#+begin_src emacs-lisp

(setq-default scroll-conservatively 101       ; Avoid recentering when scrolling far
              scroll-margin 2                 ; Add a margin when scrolling vertically
              recenter-positions '(5 bottom)) ; Set re-centering positions

#+end_src

** Clipboard :OS:

Allows system and Emacs clipboard to communicate smoothly (both ways)

#+begin_src emacs-lisp

(setq-default select-enable-clipboard t) ; Merge system's and Emacs' clipboard

#+end_src

Make sure clipboard works properly in tty mode on OSX.

#+begin_src emacs-lisp

(defun my-paste-from-osx ()
  (shell-command-to-string "pbpaste"))

(defun my-copy-to-osx (text &optional push)
  (let ((process-connection-type nil))
    (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
      (process-send-string proc text)
      (process-send-eof proc))))

(when (and (not (display-graphic-p))
           (eq system-type 'darwin))
  (setq interprogram-cut-function   #'my-copy-to-osx
        interprogram-paste-function #'my-paste-from-osx))

#+end_src

** Help :BINDING:

[[https://github.com/Wilfred/helpful][Helpful]] is an alternative to the built-in Emacs help that provides much more contextual information.
It is a bit slow to load so we do need load it explicitely.

#+begin_src emacs-lisp

(setq help-window-select t)             ; Focus new help windows when opened

(bind-key "C-h f"   #'helpful-callable) ; Look up callable
(bind-key "C-h v"   #'helpful-variable) ; Look up variable
(bind-key "C-h k"   #'helpful-key)      ; Look up key
(bind-key "C-c C-d" #'helpful-at-point) ; Look up the current symbol at point
(bind-key "C-h F"   #'helpful-function) ; Look up *F*unctions (excludes macros).
(bind-key "C-h C"   #'helpful-command)  ; Look up *C*ommands.

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Interface")

#+end_src


* Visual


#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** Colors :MODE:TIMER:

A consistent theme for GNU Emacs. The light theme is based on Material colors and the dark theme is based on Nord colors. The theme is based on a set of six faces (only).

#+begin_src lisp

(require 'nano-theme)
(setq nano-fonts-use t) ; Use theme font stack
(nano-light)            ; Use theme light version
(nano-mode)             ; Recommended settings


(defun my-set-face (face style)
  "Reset FACE and make it inherit STYLE."
  (set-face-attribute face nil
                      :foreground 'unspecified :background 'unspecified
                      :family     'unspecified :slant      'unspecified
                      :weight     'unspecified :height     'unspecified
                      :underline  'unspecified :overline   'unspecified
                      :box        'unspecified :inherit    style))
(my-set-face 'italic 'nano-faded)

#+end_src

We still want the transient nano splash screen

#+begin_src emacs-lisp

(require 'nano-splash)

#+end_src

** Fonts

This is the font stack we install:

- Default font:  Roboto Mono 14pt Light       [[https://fonts.google.com/specimen/Roboto+Mono][]]
- /Italic font/:   Victor Mono 14pt Semilight   [[https://github.com/rubjo/victor-mono][]]
- *Bold font*:     Roboto Mono 14pt Regular     [[https://fonts.google.com/specimen/Roboto+Mono][]]
- Unicode font:  Inconsolata 16pt Light       [[https://github.com/googlefonts/Inconsolata][]]
- Icon font:     Roboto Mono Nerd 12pt Light  [[https://www.nerdfonts.com/][]]

Text excerpt using a /gorgeous/ and true italic font (Victor Mono),
chosen to really *stand out* from the default font (Roboto Mono).
┌───────────────────────────────────────────────┐
│  The quick brown fox jumps over the lazy dog │
│  /The quick brown fox jumps over the lazy dog/            ┼─ Victor Mono Italic
│  *The quick brown fox jumps over the lazy dog* ├─ Inconsolata
└─┼───────────────────────────┼─────────────────┘
Roboto Mono Nerd            Roboto Mono

Note that the Victor Mono needs to be hacked such as to have the same line height as Roboto Mono. To do that, you can use the [[https://github.com/source-foundry/font-line][font-line]] utility (github.com/source-foundry/font-line): copy all the italic faces from the Victor Mono ttf file into a directoy and type: =font-line percent 10 *.ttf=. This will create a new set of files that you can use to replace the Victor Mono italic faces on your system.


#+begin_src lisp

(set-face-attribute 'default nil
                    :family "Roboto Mono"
                    :weight 'light
                    :height 140)

(set-face-attribute 'bold nil
                    :family "Roboto Mono"
                    :weight 'regular)

(set-face-attribute 'italic nil
                    :family "Victor Mono"
                    :weight 'semilight
                    :slant 'italic)

(set-fontset-font t 'unicode
                  (font-spec :name "Inconsolata Light"
                             :size 16) nil)

(set-fontset-font t '(#xe000 . #xffdd)
                  (font-spec :name "RobotoMono Nerd Font"
                             :size 28) nil)

#+end_src

** Typography

#+begin_src emacs-lisp

(setq-default fill-column 100                         ; Default line width
              sentence-end-double-space nil           ; Use a single space after dots
              bidi-paragraph-direction 'left-to-right ; Faster
              truncate-string-ellipsis "…")           ; Nicer ellipsis

#+end_src

Changing the symbol for truncation (…) and wrap (↩).

#+begin_src emacs-lisp

(require 'nano-theme)

;; Nicer glyphs for continuation and wrap
(set-display-table-slot standard-display-table
                        'truncation (make-glyph-code ?… 'nano-faded))

(defface wrap-symbol-face
  '((t (:family "Fira Code"
                :inherit nano-faded)))
  "Specific face for wrap symbol")

(set-display-table-slot standard-display-table
                        'wrap (make-glyph-code ?↩ 'wrap-symbol-face))

#+end_src

Fix a bug on OSX in term mode & zsh (spurious "%" after each command)

#+begin_src emacs-lisp

(when (eq system-type 'darwin)
  (add-hook 'term-mode-hook
            (lambda ()
              (setq buffer-display-table (make-display-table)))))

#+end_src

Make sure underline is positionned at the very bottom.

#+begin_src emacs-lisp

(setq x-underline-at-descent-line nil
      x-use-underline-position-properties t
      underline-minimum-offset 10)

#+end_src
** Benchmark

#+begin_src emacs-lisp

(my-report-time "Visual")

#+end_src


* Editing

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** Default mode :HOOK:MODE:

Default & initial mode is text.

#+begin_src emacs-lisp

(setq-default initial-major-mode 'text-mode   ; Initial mode is text
              default-major-mode 'text-mode)  ; Default mode is text

#+end_src

Visual line mode for prog and text modes

#+begin_src emacs-lisp

(add-hook 'text-mode-hook 'visual-line-mode)
(add-hook 'prog-mode-hook 'visual-line-mode)

#+end_src

** Tabulations

No tabulation, ever.

#+begin_src emacs-lisp

(setq-default indent-tabs-mode nil        ; Stop using tabs to indent
              tab-always-indent 'complete ; Indent first then try completions
              tab-width 4)                ; Smaller width for tab characters

;; Let Emacs guess Python indent silently
(setq python-indent-guess-indent-offset t
      python-indent-guess-indent-offset-verbose nil)

#+end_src

** Parenthesis :MODE:

Paren mode for highlighting matcing paranthesis

#+begin_src emacs-lisp

(require 'paren)
;; (setq show-paren-style 'expression)
(setq show-paren-style 'parenthesis)
(setq show-paren-when-point-in-periphery t)
(setq show-paren-when-point-inside-paren nil)
(show-paren-mode)

#+end_src

** Imenu list

Imenu setup

#+begin_src emacs-lisp

(require 'imenu-list)

(setq-default imenu-list-position 'left
              imenu-max-item-length 1000)

#+end_src
** Highlighting :MODE:

Highlighting of the current line (native mode)

#+begin_src emacs-lisp

(require 'hl-line)

(global-hl-line-mode)

#+end_src

** PDF Tools

For retina display (OSX)

#+begin_src emacs-lisp
;; (require 'pdf-tools)

(add-hook 'doc-view-mode-hook 'pdf-tools-install)

(setq-default pdf-view-use-scaling t
              pdf-view-use-imagemagick nil)

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Editing")

#+end_src


* Completion

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** Corfu :MODE:

[[https://github.com/minad/corfu][Corfu]] enhances completion at point with a small completion popup.

#+begin_src emacs-lisp

(require 'corfu)

(setq corfu-cycle t                ; Enable cycling for `corfu-next/previous'
      corfu-auto t                 ; Enable auto completion
      corfu-auto-delay 60.0        ; Delay before auto-completion shows up
      corfu-separator ?\s          ; Orderless field separator
      corfu-quit-at-boundary nil   ; Never quit at completion boundary
      corfu-quit-no-match t        ; Quit when no match
      corfu-preview-current nil    ; Disable current candidate preview
      corfu-preselect-first nil    ; Disable candidate preselection
      corfu-on-exact-match nil     ; Configure handling of exact matches
      corfu-echo-documentation nil ; Disable documentation in the echo area
      corfu-scroll-margin 5)       ; Use scroll margin

(global-corfu-mode)

#+end_src

A few more useful configurations...

#+begin_src emacs-lisp

;; TAB cycle if there are only few candidates
(setq completion-cycle-threshold 3)

;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
;; Corfu commands are hidden, since they are not supposed to be used via M-x.
(setq read-extended-command-predicate
      #'command-completion-default-include-p)

;; Enable indentation+completion using the TAB key.
;; completion-at-point is often bound to M-TAB.
(setq tab-always-indent 'complete)

;; Completion in source blocks
(require 'cape)

(add-to-list 'completion-at-point-functions 'cape-symbol)

#+end_src

** TODO Orderless

Allow completion based on space-separated tokens, out of order.

#+begin_src emacs-lisp

(require 'orderless)

(setq completion-styles '(substring orderless basic)
      orderless-component-separator 'orderless-escapable-split-on-space
      read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t
      completion-ignore-case t)

(use-package orderless
  :ensure t
  :init
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles . (partial-completion))))))

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Completion")

#+end_src


* Minibuffer & Modeline

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** Consult :BINDING:

We replace some of emacs functions with their consult equivalent

#+begin_src emacs-lisp

(require 'consult)

(setq consult-preview-key nil) ; No live preview

(bind-key "C-x C-r" #'consult-recent-file)
(bind-key "C-x h"   #'consult-outline)
(bind-key "C-x b"   #'consult-buffer)
(bind-key "C-c h"   #'consult-history)
;; (bind-key "M-:"     #'consult-complex-command)

#+end_src

For the [[help:consult-goto-line][consult-goto-line]] and ~consult-line~ commands, we define our owns with live preview (independently of the [[help:consult-preview-key][consult-preview-key]])

#+name: my-consult-line
#+begin_src emacs-lisp

(defun my-consult-line ()
  "Consult line with live preview"

  (interactive)
  (let ((consult-preview-key 'any)
        (mini-frame-resize 'grow-only)) ;; !! Important
    (consult-line)))

(bind-key "C-s"   #'my-consult-line)

#+end_src
#+name: my-consult-goto-line
#+begin_src emacs-lisp

(defun my-consult-goto-line ()
  "Consult goto line with live preview"

  (interactive)
  (let ((consult-preview-key 'any))
    (consult-goto-line)))

(bind-key "M-g g"   #'my-consult-goto-line)
(bind-key "M-g M-g" #'my-consult-goto-line)

#+end_src

** Vertico :ADVICE:HOOK:BINDING:MODE:FACE:

[[https://github.com/minad/vertico][Vertico]] provides a performant and minimalistic vertical completion UI based on the default completion system but aims to be highly flexible, extensible and modular.

#+begin_src emacs-lisp

(require 'vertico)

;; (setq completion-styles '(basic substring partial-completion flex))

(setq vertico-resize nil        ; How to resize the Vertico minibuffer window.
      vertico-count 8           ; Maximal number of candidates to show.
      vertico-count-format nil) ; No prefix with number of entries

(vertico-mode)

#+end_src

Tweaking settings

#+begin_src emacs-lisp

(setq vertico-grid-separator
      #("  |  " 2 3 (display (space :width (1))
                             face (:background "#ECEFF1")))

      vertico-group-format
      (concat #(" " 0 1 (face vertico-group-title))
              #(" " 0 1 (face vertico-group-separator))
              #(" %s " 0 4 (face vertico-group-title))
              #(" " 0 1 (face vertico-group-separator
                              display (space :align-to (- right (-1 . right-margin) (- +1)))))))

(set-face-attribute 'vertico-group-separator nil
                    :strike-through t)
(set-face-attribute 'vertico-current nil
                    :inherit '(nano-strong nano-subtle))
(set-face-attribute 'completions-first-difference nil
                    :inherit '(nano-default))

#+end_src

Bind =shift-tab= for completion

#+begin_src emacs-lisp

(bind-key "<backtab>" #'minibuffer-complete vertico-map)

#+end_src

Completion-at-point and completion-in-region (see
https://github.com/minad/vertico#completion-at-point-and-completion-in-region)

#+begin_src emacs-lisp

(setq completion-in-region-function
      (lambda (&rest args)
        (apply (if vertico-mode
                   #'consult-completion-in-region
                 #'completion--in-region)
               args)))

#+end_src

Prefix the current candidate
(See https://github.com/minad/vertico/wiki#prefix-current-candidate-with-arrow)

#+begin_src emacs-lisp

(defun minibuffer-format-candidate (orig cand prefix suffix index _start)
  (let ((prefix (if (= vertico--index index)
                    "  "
                  "   ")))
    (funcall orig cand prefix suffix index _start)))

(advice-add #'vertico--format-candidate
            :around #'minibuffer-format-candidate)

#+end_src

See https://kristofferbalintona.me/posts/vertico-marginalia-all-the-icons-completion-and-orderless/#vertico

#+begin_src emacs-lisp

(defun vertico--prompt-selection ()
  "Highlight the prompt"

  (let ((inhibit-modification-hooks t))
    (set-text-properties (minibuffer-prompt-end) (point-max)
                         '(face (nano-strong nano-salient)))))

#+end_src

See https://github.com/minad/vertico/issues/145

#+begin_src emacs-lisp

(defun minibuffer-vertico-setup ()

  (setq truncate-lines t)
  (setq completion-in-region-function
        (if vertico-mode
            #'consult-completion-in-region
          #'completion--in-region)))

(add-hook 'vertico-mode-hook #'minibuffer-vertico-setup)
(add-hook 'minibuffer-setup-hook #'minibuffer-vertico-setup)

#+end_src
** Marginalia :MODE:

Pretty straightforward.

#+begin_src emacs-lisp

(require 'marginalia)

(setq-default marginalia--ellipsis "…"    ; Nicer ellipsis
              marginalia-align 'right     ; right alignment
              marginalia-align-offset -1) ; one space on the right

(marginalia-mode)

#+end_src
** Modeline :HOOK:MODE:FACE:

We're using [[https://github.com/rougier/nano-modeline][nano-modeline]] and modify some settings here.

#+begin_src emacs-lisp

(require 'nano-theme)
(require 'nano-modeline)

(setq nano-modeline-prefix 'status)
(setq nano-modeline-prefix-padding 1)

(set-face-attribute 'header-line nil)
(set-face-attribute 'mode-line nil
                    :foreground (face-foreground 'nano-subtle-i)
                    :background (face-foreground 'nano-subtle-i)
                    :inherit nil
                    :box nil)
(set-face-attribute 'mode-line-inactive nil
                    :foreground (face-foreground 'nano-subtle-i)
                    :background (face-foreground 'nano-subtle-i)
                    :inherit nil
                    :box nil)

(set-face-attribute 'nano-modeline-active nil
                    :underline (face-foreground 'nano-default-i)
                    :background (face-background 'nano-subtle)
                    :inherit '(nano-default-)
                    :box nil)
(set-face-attribute 'nano-modeline-inactive nil
                    :foreground 'unspecified
                    :underline (face-foreground 'nano-default-i)
                    :background (face-background 'nano-subtle)
                    :box nil)

(set-face-attribute 'nano-modeline-active-name nil
                    :foreground "black"
                    :inherit '(nano-modeline-active nano-strong))
(set-face-attribute 'nano-modeline-active-primary nil
                    :inherit '(nano-modeline-active))
(set-face-attribute 'nano-modeline-active-secondary nil
                    :inherit '(nano-faded nano-modeline-active))

(set-face-attribute 'nano-modeline-active-status-RW nil
                    :inherit '(nano-faded-i nano-strong nano-modeline-active))
(set-face-attribute 'nano-modeline-active-status-** nil
                    :inherit '(nano-popout-i nano-strong nano-modeline-active))
(set-face-attribute 'nano-modeline-active-status-RO nil
                    :inherit '(nano-default-i nano-strong nano-modeline-active))

(set-face-attribute 'nano-modeline-inactive-name nil
                    :inherit '(nano-faded nano-strong
                                          nano-modeline-inactive))
(set-face-attribute 'nano-modeline-inactive-primary nil
                    :inherit '(nano-faded nano-modeline-inactive))

(set-face-attribute 'nano-modeline-inactive-secondary nil
                    :inherit '(nano-faded nano-modeline-inactive))
(set-face-attribute 'nano-modeline-inactive-status-RW nil
                    :inherit '(nano-modeline-inactive-secondary))
(set-face-attribute 'nano-modeline-inactive-status-** nil
                    :inherit '(nano-modeline-inactive-secondary))
(set-face-attribute 'nano-modeline-inactive-status-RO nil
                    :inherit '(nano-modeline-inactive-secondary))

#+end_src

We set a thin modeline

#+begin_src emacs-lisp

(defun my-thin-modeline ()
  "Transform the modeline in a thin faded line"

  (nano-modeline-face-clear 'mode-line)
  (nano-modeline-face-clear 'mode-line-inactive)
  (setq mode-line-format (list ""))
  (setq-default mode-line-format (list ""))
  (set-face-attribute 'mode-line nil
                      :box nil
                      :inherit nil
                      :foreground (face-background 'nano-subtle)
                      :background (face-background 'nano-subtle)
                      :height 0.1)
  (set-face-attribute 'mode-line-inactive nil
                      :box nil
                      :inherit nil
                      :foreground (face-background 'nano-subtle)
                      :background (face-background 'nano-subtle)
                      :height 0.1))

(add-hook 'nano-modeline-mode-hook #'my-thin-modeline)

#+end_src

We start the nano modeline.
#+begin_src emacs-lisp

(nano-modeline-mode 1)

#+end_src

** Minibuffer :MODE:HOOK:

Headerline (fake) for minibuffer

#+begin_src emacs-lisp
(require 'minibuffer-header)

(setq minibuffer-header-show-message t
      minibuffer-header-hide-prompt t
      minibuffer-header-default-message "")

(set-face-attribute 'minibuffer-header-face nil
                    :inherit 'nano-subtle
                    :extend t)
(set-face-attribute 'minibuffer-header-message-face nil
                    :inherit '(nano-subtle nano-faded)
                    :extend t)
#+end_src

This should be an advice but it is simpler to rewrite the function

#+begin_src emacs-lisp

(defun my-minibuffer-header-format (prompt)
  "Minibuffer header"

  (let* ((prompt (replace-regexp-in-string "[: \t]*$" "" prompt))
         (depth (minibuffer-depth))
         (prompt (cond ((string= prompt "M-x") "Extended command")
                       ((string= prompt "Function") "Help on function")
                       ((string= prompt "Callable") "Help on function or macro")
                       ((string= prompt "Variable") "Help on variable")
                       ((string= prompt "Command") "Help on command")
                       ((string= prompt "Eval") "Evaluate lisp expression")
                       (t prompt))))
    (concat
     (propertize (format " %d " depth)
                 'face `(:inherit (nano-salient-i nano-strong)
                                  :extend t))
     (propertize " "
                 'face 'nano-subtle 'display `(raise ,nano-modeline-space-top))

     (propertize prompt
                 'face `(:inherit (nano-subtle nano-strong nano-salient)
                                  :extend t))
     (propertize " "
                 'face 'nano-subtle 'display `(raise ,nano-modeline-space-bottom))
     (propertize "\n" 'face 'highlight)
     (propertize " " 'face 'highlight
                 'display `(raise ,nano-modeline-space-top))
     (propertize "︎︎" 'face '(:inherit (nano-salient nano-strong)))
     (propertize " " 'face 'highlight
                 'display `(raise ,nano-modeline-space-bottom)))))

(setq minibuffer-header-format #'my-minibuffer-header-format)

#+end_src

Activate minibuffer header

#+begin_src emacs-lisp

(minibuffer-header-mode)

#+end_src

Some styling setting for the minibuffer

#+begin_src emacs-lisp

(defun my-minibuffer-setup ()

  (set-window-margins nil 0 0)
  (set-fringe-style '(0 . 0))
  (cursor-intangible-mode t)
  (face-remap-add-relative 'default :inherit 'highlight))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup)

#+end_src

Showing key binding for the current command

#+begin_src emacs-lisp

;; Code from https://stackoverflow.com/questions/965263
(defun my-lookup-function (keymap func)
  (let ((all-bindings (where-is-internal (if (symbolp func)
                                             func
                                           (cl-first func))
                                         keymap))
        keys key-bindings)
    (dolist (binding all-bindings)
      (when (and (vectorp binding)
                 (integerp (aref binding 0)))
        (push binding key-bindings)))
    (push (mapconcat #'key-description key-bindings " or ") keys)
    (car keys)))


(defun my-minibuffer-show-last-command-setup ()
  (setq minibuffer-header-default-message
        (my-lookup-function (current-global-map) this-command)))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-show-last-command-setup)

(defun my-minibuffer-show-last-command-exit ()
  (setq minibuffer-header-default-message ""))
(add-hook 'minibuffer-exit-hook #'my-minibuffer-show-last-command-exit)

#+end_src



Vertico will disable truncate lines when point is too far on the right. Problem is that it'll mess up with our fake headerline. We thus rewrite here the function to have truncate lines always on.

#+begin_src emacs-lisp

(defun my-vertico--resize-window (height)
  "Resize active minibuffer window to HEIGHT."
  ;;  (setq-local truncate-lines (< (point) (* 0.8 (vertico--window-width)))
  (setq-local truncate-lines t
              resize-mini-windows 'grow-only
              max-mini-window-height 1.0)
  (unless (frame-root-window-p (active-minibuffer-window))
    (unless vertico-resize
      (setq height (max height vertico-count)))
    (let* ((window-resize-pixelwise t)
           (dp (- (max (cdr (window-text-pixel-size))
                       (* (default-line-height) (1+ height)))
                  (window-pixel-height))))
      (when (or (and (> dp 0) (/= height 0))
                (and (< dp 0) (eq vertico-resize t)))
        (window-resize nil dp nil nil 'pixelwise)))))

(advice-add #'vertico--resize-window :override #'my-vertico--resize-window)

#+end_src

No prompt editing and recursive minibuffer

#+begin_src emacs-lisp

(setq minibuffer-prompt-properties '(read-only t
                                               cursor-intangible t
                                               face minibuffer-prompt)
      enable-recursive-minibuffers t)

#+end_src

** Miniframe :MODE:FACE:BUGFIX:

#+begin_src emacs-lisp

(require 'mini-frame)

(defcustom my-minibuffer-position 'bottom
  "Minibuffer position, one of 'top or 'bottom"
  :type '(choice (const :tag "Top"    top)
                 (const :tag "Bottom" bottom))
  :group 'nano-minibuffer)


(defun my-minibuffer--frame-parameters ()
  "Compute minibuffer frame size and position."

  ;; Quite precise computation to align the minibuffer and the
  ;; modeline when they are both at top position
  (let* ((edges (window-pixel-edges)) ;; (left top right bottom)
         (body-edges (window-body-pixel-edges)) ;; (left top right bottom)
         (left (nth 0 edges)) ;; Take margins into account
         (top (nth 1 edges)) ;; Drop header line
         (right (nth 2 edges)) ;; Take margins into account
         (bottom (nth 3 body-edges)) ;; Drop header line
         (left (if (eq left-fringe-width 0)
                   left
                 (- left (frame-parameter nil 'left-fringe))))
         (right (nth 2 edges))
         (right (if (eq right-fringe-width 0)
                    right
                  (+ right (frame-parameter nil 'right-fringe))))
         (border 1)
         (width (- right left (* 1 border)))

         ;; Window divider mode
         (width (- width (if (and (bound-and-true-p window-divider-mode)
                                  (or (eq window-divider-default-places 'right-only)
                                      (eq window-divider-default-places t))
                                  (window-in-direction 'right (selected-window)))
                             window-divider-default-right-width
                           0)))
         (y (- top border)))

    (append `((left-fringe . 0)
              (right-fringe . 0)
              (user-position . t)
              (foreground-color . ,(face-foreground 'highlight nil 'default))
              (background-color . ,(face-background 'highlight nil 'default)))
            (cond ((and (eq my-minibuffer-position 'bottom))
                   `((top . -1)
                     (left . 0)
                     (width . 1.0)
                     (child-frame-border-width . 0)
                     (internal-border-width . 0)))
                  (t
                   `((left . ,(- left border))
                     (top . ,y)

                     (width . (text-pixels . ,width))
                     (child-frame-border-width . ,border)
                     (internal-border-width . 0)))))))

(set-face-background 'child-frame-border (face-foreground 'nano-faded))
(setq mini-frame-default-height 3)
(setq mini-frame-create-lazy t)
(setq mini-frame-show-parameters 'my-minibuffer--frame-parameters)
(setq mini-frame-ignore-commands
      '("edebug-eval-expression" debugger-eval-expression))
(setq mini-frame-internal-border-color (face-foreground 'nano-faded))

(setq mini-frame-resize-min-height 3)
(setq mini-frame-resize t)
;; (setq mini-frame-resize 'grow-only)
;; (setq mini-frame-default-height (+ 1 vertico-count))
;; (setq mini-frame-resize-height (+ 1 vertico-count))
;; (setq mini-frame-resize nil)

#+end_src

Mini-frame mode OFF

#+begin_src emacs-lisp

;; (mini-frame-mode 1)

#+end_src


More a hack than a fix but the code below improve the mini-frame resize by
setting position explicity. CURRENTLY INACTIVE

#+begin_src emacs-lisp

(defun my-mini-frame--resize-mini-frame (frame)
  "Resize FRAME vertically only.
This function used as value for `resize-mini-frames' variable."
  (funcall mini-frame--fit-frame-function
           frame
           mini-frame-resize-max-height
           (if (eq mini-frame-resize 'grow-only)
               (max (frame-parameter frame 'height)
                    mini-frame-resize-min-height)
             mini-frame-resize-min-height)
           ;; A max-width must be included to work around a bug in Emacs which
           ;; causes wrapping to not be taken into account in some situations
           ;; https://debbugs.gnu.org/cgi/bugreport.cgi?bug=56102
           (window-body-width)
           nil
           'vertically)

  (if (eq my-minibuffer-position 'top)
      (modify-frame-parameters  mini-frame-completions-frame `((top . 0)))
    (modify-frame-parameters  mini-frame-completions-frame `((top . (- 1))))))

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Minibuffer/Modeline")

#+end_src



* Mail :DEFER:
:PROPERTIES:
:header-args:emacs-lisp: :prologue "(with-eval-after-load 'mu4e" :epilogue ")"
:END:

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** Setup :PERSONAL:BINDING:

Mu4e doesn't come with an autoload function, we declare it here.

#+begin_src emacs-lisp :prologue "" :epilogue ""

(autoload 'mu4e
  "/usr/share/emacs/site-lisp/mu4e/mu4e.el"
  "Start mu4e daemon and show its main window." t)

#+end_src

# Lots of options. Make sure to adapt paths to your system.

#+begin_src emacs-lisp
(setq mu4e-mu-binary "/usr/bin/mu"
      mu4e-maildir "~/Documents/.mails"
      mu4e-attachment-dir "~/Downloads"
      mu4e-get-mail-command "/usr/bin/offlineimap"

      mu4e-update-interval 300            ; Update interval (seconds)
      mu4e-index-cleanup t                ; Cleanup after indexing
      mu4e-index-update-error-warning t   ; Warnings during update
      mu4e-hide-index-messages t          ; Hide indexing messages
      mu4e-index-update-in-background t   ; Background update
      mu4e-index-lazy-check nil           ; Don't be lazy, index everything

      ;;mu4e-confirm-quit nil
      ;;mu4e-split-view 'single-window    ; Breaks the mu4e main page.

      mu4e-headers-auto-update t                ; avoid to type `g' to update
      mu4e-headers-date-format "%d-%m"
      mu4e-headers-time-format "%H:%M"
      mu4e-headers-from-or-to-prefix '("" . "To ")
      mu4e-headers-include-related t
      mu4e-headers-skip-duplicates t

      mu4e-view-show-images t                   ; show images in the view buffer
      mu4e-use-fancy-chars t                    ; allow fancy icons for mail threads
      mu4e-view-html-plaintext-ratio-heuristic  most-positive-fixnum
      mu4e-html2text-command 'mu4e-shr2text
      shr-use-fonts nil   ; Simple HTML Renderer / no font
      shr-use-colors nil) ; Simple HTML Renderer / no color

#+end_src

How to handle various MIME data.

#+begin_src emacs-lisp :prologue "" :epilogue ""

(require 'mailcap)

(push '((viewer . "open %s 2> /dev/null &")
        (type . "application/pdf")
        (test . window-system))
      mailcap-user-mime-data)

(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))

#+end_src

Some bindings to avoid confirmation for execution (headers and message view)

#+begin_src emacs-lisp

(bind-key "x" (lambda() (interactive) (mu4e-mark-execute-all t)) mu4e-headers-mode-map)
(bind-key "x" (lambda() (interactive) (mu4e-mark-execute-all t)) mu4e-view-mode-map)

#+end_src

** Accounts :PERSONAL:

*** General

General information about me.

#+begin_src emacs-lisp

;; User name
(setq user-full-name "Sebastian Halbig")

;; Main user mail address
(setq user-mail-address "SebastianHalbig@gmx.de")

;; Common signature for all accounts.
(setq mu4e-signature (concat
                      "Sebastian Halbig —  — https://www.nowebisite.yet\n"
                      "Philipps-Univeristät Marburg —Research Group Algebraic Lie Theory\n"
                      "Hans-Meerwein-Straße 6, 35043 Marburg"))

#+end_src

Because we'll use mu4e-contexts, we reset single account settings.

#+begin_src emacs-lisp

(setq mu4e-contexts nil
      mu4e-drafts-folder nil
      mu4e-compose-reply-to-address nil
      mu4e-compose-signature t
      mu4e-compose-signature-auto-include t
      mu4e-sent-folder nil
      mu4e-trash-folder nil)

#+end_src

#+begin_src emacs-lisp

(setq mu4e-context-policy 'pick-first  ; How to determine context when entering headers view
      mu4e-compose-context-policy nil) ; Do not modify context when composing

#+end_src

Refile/archive depending on the context (via maildir)

#+begin_src emacs-lisp

(defun my-mu4e-refile-folder (msg)
  "Contextual refile"

  (let ((maildir (mu4e-message-field msg :maildir)))
    (cond
     ((string-match "Marburg (internal)" maildir) "/MarburgInternal/archive")
     ((string-match "Marburg" maildir) "/Marburg/archive")
     ((string-match "GMX"  maildir) "/GMX/archive")
     ((string-match "TUD (deprecated)"  maildir) "/TUD/archive")
     ((string-match "Web"  maildir) "/Web/archive")

     (t ""))))

(setq mu4e-refile-folder 'my-mu4e-refile-folder)

#+end_src

*** Web :PERSONAL:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "Spam"
              :enter-func (lambda () (mu4e-message "Entering Spam context"))
              :leave-func (lambda () (mu4e-message "Leaving Spam context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                       :to "xolotl.spam@web.de")))
              :vars `((user-mail-address . "xolotl.spam@web.de"  )
                      (user-full-name . "Sebastian Halbig" )
                      (mu4e-compose-signature . ,mu4e-signature)
                      (mu4e-sent-folder . "/Web/sent")
                      (mu4e-trash-folder . "/Web/trash")
                      (mu4e-drafts-folder . "/Web/drafts")
                      (mu4e-maildir-shortcuts . (("/Web/inbox" . ?i)
                                                 ("/Web/archive" . ?a)
                                                 ("/Web/sent" . ?s)))
                      (smtpmail-smtp-server . "smtp.staff.uni-marburg.de")
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_src

*** Dresden(deprecated) :PERSONAL:DEPRECATED:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "TUDresden"
              :enter-func (lambda () (mu4e-message "Entering Dresden(deprecated) context"))
              :leave-func (lambda () (mu4e-message "Leaving Dresden(deprecated) context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                       :to "sebastian.halbig@tu-dresden.de")))
              :vars `((user-mail-address . "Sebastian.Halbig@tu-dresden.de"  )
                      (user-full-name . "Sebastian Halbig" )
                      (mu4e-compose-signature . ,mu4e-signature)
                      (mu4e-sent-folder . "/TUD/sent")
                      (mu4e-trash-folder . "/TUD/trash")
                      (mu4e-drafts-folder . "/TUD/drafts")
                      (mu4e-maildir-shortcuts . (("/TUD/inbox" . ?i)
                                                 ("/TUD/archive" . ?a)
                                                 ("/TUD/sent" . ?s)))
                      (smtpmail-smtp-server . "msx.tu-dresden.de")
                      (smtpmail-stream-type . tls)
                      (smtpmail-smtp-service . 587))))

#+end_src

*** Private :PERSONAL:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "GMX"
              :enter-func (lambda () (mu4e-message "Entering GMX context"))
              :leave-func (lambda () (mu4e-message "Leaving GMX context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                                                          :to "sebastianhalbig@gmx.de")))
              :vars `((user-mail-address . "SebastianHalbig@gmx.de"  )
                      (user-full-name . "Sebastian Halbig" )
                      (mu4e-sent-folder . "/GMX/sent")
                      (mu4e-trash-folder . "/GMX/trash")
                      (mu4e-drafts-folder . "/GMX/drafts")
                      (mu4e-maildir-shortcuts . (("/GMX/inbox" . ?i)
                                                 ("/GMX/archive" . ?a)
                                                 ("/GMX/sent" . ?s)))
                      (smtpmail-smtp-server . "mail.gmx.net")
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_src
*** Marburg-Internal :PERSONAL:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "Internal-Marburg"
              :enter-func (lambda () (mu4e-message "Entering Marburg(general) context"))
              :leave-func (lambda () (mu4e-message "Leaving Marburg(general) context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                       :to "halbigs@mathematik.uni-marburg.de")))
              :vars `((user-mail-address . "halbigs@mathematik.uni-marburg.de")
                      (user-full-name . "Sebastian Halbig")
                      (mu4e-compose-signature . ,mu4e-signature)
                      (mu4e-sent-folder . "/MarburgInternal/sent")
                      (mu4e-trash-folder . "/MarburgInternal/trash")
                      (mu4e-drafts-folder . "/MarburgInternal/drafts")
                      (mu4e-maildir-shortcuts . (("/MarburgInternal/inbox" . ?i)
                                                 ("/MarburgInternal/archive" . ?a)
                                                 ("/MarburgInternal/sent" . ?s)))
                      (smtpmail-smtp-server . "smtp.staff.uni-marburg.de")
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_src

*** Marburg :PERSONAL:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "Marburg"
              :enter-func (lambda () (mu4e-message "Entering Marburg(general) context"))
              :leave-func (lambda () (mu4e-message "Leaving Marburg(general) context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                       :to "Sebastian.Halbig@uni-marburg.de")))
              :vars `((user-mail-address . "Sebastian.Halbig@uni-marburg.de"  )
                      (user-full-name . "Sebastian Halbig" )
                      (mu4e-compose-signature . ,mu4e-signature)
                      (mu4e-sent-folder . "/Marburg/sent")
                      (mu4e-trash-folder . "/Marburg/trash")
                      (mu4e-drafts-folder . "/Marburg/drafts")
                      (mu4e-maildir-shortcuts . (("/Marburg/inbox" . ?i)
                                                 ("/Marburg/archive" . ?a)
                                                 ("/Marburg/sent" . ?s)))
                      (smtpmail-smtp-server . "smtp.uni-marburg.de")
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_src
** Encryption

See https://www.djcbsoftware.nl/code/mu/mu4e/Reading-messages.html

#+begin_src emacs-lisp :prologue "" :epilogue ""

(require 'epg-config)

(setq epg-gpg-program "/usr/bin/gpg"        ; What gpg program to use
      epg-user-id "Sebastian Halbig <Sebastian.Halbig@uni-marburg.de>" ; GnuPG ID of your default identity
      mml2015-use 'epg                      ; The package used for PGP/MIME.
      mml2015-encrypt-to-self t             ; Add our own key ID to recipient list
      mml2015-sign-with-sender t)           ; Use message sender to find a key to sign with.

;;(setq epa-file-cache-passphrase-for-symmetric-encryption nil)
;;(require 'epa-file)
;;(epa-file-enable)
;;(setq epa-file-select-keys nil)
(setq epa-pinentry-mode 'loopback)
(pinentry-start)

#+end_src

** TODO Read :BINDING:FACE:

Various settings

#+begin_src emacs-lisp

(setq mu4e-show-images t
      mu4e-use-fancy-chars nil
      mu4e-view-html-plaintext-ratio-heuristic  most-positive-fixnum
      mu4e-html2text-command 'mu4e-shr2text
      shr-use-fonts nil   ; Simple HTML Renderer / no font
      shr-use-colors nil) ; Simple HTML Renderer / no color

#+end_src

n/p for nevigating unread mails

#+begin_src emacs-lisp

(bind-key "n" #'mu4e-headers-next-unread mu4e-headers-mode-map)
(bind-key "p" #'mu4e-headers-prev-unread mu4e-headers-mode-map)

#+end_src

Custom faces

#+begin_src emacs-lisp

(set-face-attribute 'mu4e-system-face nil :inherit 'nano-critical)
(set-face-attribute 'mu4e-header-marks-face nil :inherit 'nano-critical)
(set-face-attribute 'mu4e-header-highlight-face nil :inherit 'nano-salient-i)

#+end_src
** TODO Write :HOOK:BINDING:

See www.gnu.org/software/emacs/manual/html_node/message/Insertion-Variables.html
We try to sign all mails. Encryption should also be managed automatically

#+begin_src emacs-lisp

(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-servers-requiring-authorization '".*"
      message-cite-reply-position 'below
      message-citation-line-format "%N [%Y-%m-%d at %R] wrote:"
      message-citation-line-function 'message-insert-formatted-citation-line
      message-yank-prefix       "> "
      message-yank-cited-prefix "> "
      message-yank-empty-prefix "> "
      message-indentation-spaces 1
      message-kill-buffer-on-exit t

      mu4e-compose-format-flowed t
      mu4e-compose-complete-only-personal t
      ;; mu4e-compose-complete-only-after "2021-01-01" ; Limit address auto-completion
      mu4e-compose-dont-reply-to-self t
      mu4e-compose-crypto-reply-policy 'sign-and-encrypt)

(add-hook 'message-send-hook 'mml-secure-message-sign-pgpmime)

#+end_src

Multi-language flyspell in compose mode

#+begin_src emacs-lisp

(require 'flyspell)
(require 'guess-language)
(require 'flyspell-correct-popup)

;;(bind-key "C-;" #'flyspell-popup-wrapper flyspell-mode-map)
;;(bind-key "C-;" #'flyspell-popup-correct flyspell-mode-map)

;; Automatically detect language for Flyspell
(with-eval-after-load 'guess-language
  (add-hook 'text-mode-hook #'guess-language-mode)
  (setq guess-language-langcodes '((en . ("en_GB" "English"))
                                   (de . ("de_DE" "German")))
        guess-language-languages '(en de)
        guess-language-min-paragraph-length 45))

(setq flyspell-generic-check-word-predicate  'mail-mode-flyspell-verify)

#+end_src

#+name: my-mu4e-compose-hook
#+begin_src emacs-lisp

(defun my-mu4e-compose-hook ()
  "Settings for message composition."

  (auto-save-mode -1)
  (turn-off-auto-fill)
  (set-fill-column 79)
  (setq flyspell-generic-check-word-predicate
        'mail-mode-flyspell-verify)
  (flyspell-mode))

(add-hook 'mu4e-compose-mode-hook #'my-mu4e-compose-hook)

#+end_src

** Bookmarks

#+begin_src emacs-lisp

(setq mu4e-bookmarks
      '((:name "Unread"
               :key ?u
               :show-unread t
               :query "flag:unread AND NOT flag:trashed")

        (:name "Inbox"
               :key ?i
               :show-unread t
               :query "m:/GMX/inbox or m:/TUD/inbox or m:/Marburg/inbox or m:/MarburgInternal/inbox or m:/Web/inbox")

        (:name "Today"
               :key ?t
               :show-unread t
               :query "date:today..now")

        (:name "Yesterday"
               :key ?y
               :show-unread t
               :query "date:2d..today and not date:today..now")

        (:name "Last week"
               :key ?w
               :hide-unread t
               :query "date:7d..now")

        (:name "Sent"
               :key ?s
               :hide-unread t
               :query "from:Sebastian.Halbig")

        (:name "Drafts"
               :key ?d
               :hide-unread t
               :query "flag:draft")

        (:name "Important"
               :key ?I
               :hide-unread t
               :query "flag:important")

        (:name "Eventually"
               :key ?e
               :hide-unread t
               :query "flag:eventually")

        (:name "Action"
               :key ?a
               :hide-unread t
               :query "flag:needs_action")
      ))
#+end_src

** Tags :BINDING:

This provides a tag action inside the mu4e headers view to quickly tag message. Tags are saved in the ~mu4e-tag-history~ variable that is also saved from one session to the other. We use the ~consult-completing-read-multiple~ function to read tags.

#+begin_src emacs-lisp

(defvar mu4e-tag-history '()
  "Mu4e tag history list.")

(add-to-list 'savehist-additional-variables 'mu4e-tag-history)

(put 'mu4e-tag-history 'history-length 100)

#+end_src

Here is the actual tag action

#+begin_src emacs-lisp

(defun mu4e-tag-read (target msg)
  "Ask for tags to be added and/or removed."

  (let* ((tags nil)
         (old-tags (mu4e-message-field msg :tags))
         (new-tags (completing-read-multiple
                    "TAGS: "
                    mu4e-tag-history
                    nil
                    nil
                    (mapconcat #'identity old-tags ",")
                    'mu4e-tag-history)))
    (dolist (tag old-tags)
      (let ((tag (string-trim tag)))
        (if (and (> (length tag) 0)
                 (not (member tag new-tags)))
            (push (concat "-" tag) tags))))
    (dolist (tag new-tags)
      (let ((tag (string-trim tag)))
        (if (and (> (length tag) 0)
                 (not (member tag old-tags)))
            (push (concat "+" tag) tags))))
    (mapconcat #'identity tags ",")))

;; Add the mark to mu4e. If the action does nothing, the header is marked anyway.
;; I Did not find a way to cancel the marks
(add-to-list 'mu4e-marks
             '(tag
               :char       "g"
               :prompt     "gtag"
               :dyn-target mu4e-tag-read
               :action      (lambda (docid msg target)
                              (when (> (length target) 0)
                                (mu4e-action-retag-message msg target)))))

;; Tell mu4e about the new mark
;; See https://www.djcbsoftware.nl/code/mu/mu4e/Adding-a-new-kind-of-mark.html
(mu4e~headers-defun-mark-for tag)

#+end_src

We bind the tagging with the "g" key in mu4e-headers-mode.

#+begin_src emacs-lisp

(bind-key "g" #'mu4e-headers-mark-for-tag mu4e-headers-mode-map)

#+end_src

** Folding :FACE:

Some face specification for folding.

#+begin_src emacs-lisp

(require 'mu4e-folding)

(set-face-attribute 'mu4e-folding-root-folded-face nil
                    :background (face-background 'default)
                    :extend t)
(set-face-attribute 'mu4e-folding-root-unfolded-face nil
                    :background (face-background 'default)
                    :extend t)
(set-face-attribute 'mu4e-folding-child-folded-face nil
                    :background (face-background 'default)
                    :extend t)
(set-face-attribute 'mu4e-folding-child-unfolded-face nil
                    :background (face-background 'default)
                    :extend t)

#+end_src

** Layout for mu4e :HOOK:BINDING:
*** Headers

#+begin_src emacs-lisp

(setq mu4e-headers-fields
      '((:my-flags      . 2)
        (:my-from       . 25)
        (:my-subject    . 70)
        (:my-tags       . 6)
        (:my-date       . 14)))


(setq mu4e-headers-thread-root-prefix          '(""   . "")
      mu4e-headers-thread-first-child-prefix   '(""   . "")
      mu4e-headers-thread-child-prefix         '(""   . "")
      mu4e-headers-thread-last-child-prefix    '(""   . "")
      mu4e-headers-thread-connection-prefix    '("| " . "| ")
      mu4e-headers-thread-blank-prefix         '(""   . "")
      mu4e-headers-thread-orphan-prefix        '(""   . "")
      mu4e-headers-thread-single-orphan-prefix '(""   . "")
      mu4e-headers-thread-duplicate-prefix     '("="  . "="))

(plist-put (cdr (assq 'refile   mu4e-marks)) :char "")
(plist-put (cdr (assq 'trash    mu4e-marks)) :char "")
(plist-put (cdr (assq 'action   mu4e-marks)) :char "")
(plist-put (cdr (assq 'untrash  mu4e-marks)) :char "")
(plist-put (cdr (assq 'delete   mu4e-marks)) :char "×")
(plist-put (cdr (assq 'flag     mu4e-marks)) :char "")
(plist-put (cdr (assq 'unflag   mu4e-marks)) :char "類")
(plist-put (cdr (assq 'move     mu4e-marks)) :char "")
(plist-put (cdr (assq 'tag      mu4e-marks)) :char "")

#+end_src

**** Colorisation of recent emails

#+begin_src emacs-lisp

(defun my-mu4e-headers-colorise (item msg)
  "Colorise item depending on whe msg was received"

  (let* ((recent (* 5 60)) ;; 5 minutes
         (now (current-time))
         (unread (mu4e-message-field msg :unread))
         (date (mu4e-message-field msg :date))
         (delta (float-time (time-subtract now date))))
    (if (and (< delta recent) unread)
        (propertize item 'face 'nano-salient)
      item)))

#+end_src

**** Date (custom info)

#+begin_src emacs-lisp

(require 'relative-date)

(defun my-mu4e-headers-date (msg)
  (let* ((date (mu4e-message-field msg :date)))
    (my-mu4e-headers-colorise
       (format "%12s" (relative-date date)) msg)))

(add-to-list 'mu4e-header-info-custom
                 '(:my-date . (:name "my-date"
                               :shortname "D"
                               :function my-mu4e-headers-date)))
#+end_src

**** From (custom info)

#+begin_src emacs-lisp

(defun my-mu4e-headers-from (msg)
  (let* ((from        (my-mu4e-get-sender msg))
         (meta        (when msg (mu4e-message-field msg :meta)))
         (root        (when meta (plist-get meta :root)))
         (orphan      (when meta (plist-get meta :orphan)))
         (first-child (when meta (plist-get meta :first-child)))
         (has-child   (when meta (plist-get meta :has-child)))
         (root        (when meta (plist-get meta :root)))
         (from        (cond ((and root has-child)       (concat " " from))
                            ((and orphan first-child)   (concat " " from))
                            ((and root (not has-child)) (concat "" from))
                            (t                          (concat "│ " from)))))
    (my-mu4e-headers-colorise from msg)))

(add-to-list 'mu4e-header-info-custom
             '(:my-from . (:name "my-from"
                           :shortname "F"
                           :function my-mu4e-headers-from)))

#+end_src

**** Flags (custom info)

#+begin_src emacs-lisp

(defun my-mu4e-headers-flags (msg)
  (let* ((size (mu4e-message-field msg :size))
         (flags (cond ((memq 'flagged   (mu4e-message-field msg :flags)) "")
                     ((and (> size 256000)
                     (memq 'attach    (mu4e-message-field msg :flags))) "")
                     ((memq 'replied   (mu4e-message-field msg :flags)) "")
                     ((memq 'draft     (mu4e-message-field msg :flags)) "")
                     ((memq 'trashed   (mu4e-message-field msg :flags)) "")
                     ((memq 'encrypted (mu4e-message-field msg :flags)) "")
                     (t ""))))
    (my-mu4e-headers-colorise flags msg)))

(add-to-list 'mu4e-header-info-custom
             '(:my-flags . (:name "my-flags"
                            :shortname "F"
                            :function my-mu4e-headers-flags)))

#+end_src

**** Tags (custom info)

#+begin_src emacs-lisp

(defface mu4e-tag-face
  '((t :inherit (nano-popout nano-strong)))
  "Face for message tags"
  :group 'mu4e-faces)

(defun my-mu4e-headers-tags (msg)
  (let* ((tags (mu4e-message-field msg :tags)))
    (if tags
        (propertize (format "[%s]" (mapconcat #'identity tags ","))
                    'face 'mu4e-tag-face)
      "")))
(add-to-list 'mu4e-header-info-custom
             '(:my-tags . (:name "my-tags"
                           :shortname "T"
                           :function my-mu4e-headers-tags)))

#+end_src

**** Thread count (custom info)

This is an empty info field (4 non-breaking spaces) that will be overwritten by folding mode.

#+begin_src emacs-lisp

(defun my-mu4e-headers-thread-counter (msg)
  "    ") ;; NON-BREAKING spaces
(add-to-list 'mu4e-header-info-custom
             '(:my-counter . (:name "my-counter"
                              :shortname "#"
                              :function my-mu4e-headers-thread-counter)))
#+end_src

**** Subject (custom info)

#+begin_src emacs-lisp

(defun my-mu4e-headers-subject (msg)
  (let* ((thread (mu4e-message-field msg :meta))
         (prefix (mu4e~headers-thread-prefix thread))
         (subject (mu4e-message-field msg :subject))
         ;; (subject (concat prefix subject " " (my-mu4e-headers-tags msg)))
         )
    (my-mu4e-headers-colorise subject msg)))

(add-to-list 'mu4e-header-info-custom
             '(:my-subject . (:name "my-subject"
                              :shortname "S"
                              :function my-mu4e-headers-subject)))

#+end_src

*** Folding

#+begin_src emacs-lisp

(require 'mu4e-folding)

(setq mu4e-folding-default-view 'folded)
(add-hook 'mu4e-headers-mode-hook #'mu4e-folding-mode)

;; (define-key mu4e-headers-mode-map (kbd "<tab>")     'mu4e-headers-toggle-at-point)
;; (define-key mu4e-headers-mode-map (kbd "<left>")    'mu4e-headers-fold-at-point)
;; (define-key mu4e-headers-mode-map (kbd "<S-left>")  'mu4e-headers-fold-all)
;; (define-key mu4e-headers-mode-map (kbd "<right>")   'mu4e-headers-unfold-at-point)
;; (define-key mu4e-headers-mode-map (kbd "<S-right>") 'mu4e-headers-unfold-all)

;; (defun mu4e-folding--make-root-overlay (beg end)
;;   "Create the root overlay."

;;   (let* ((buffer-read-only)
;;          (overlay (car (mu4e-folding--children-overlay)))
;;          (count (if overlay
;;                     (overlay-get overlay 'mu4e-folding-children-count)
;;                   0)))
;;     (save-excursion
;;       (goto-char beg)
;;       (when (search-forward "" end t)
;;         (put-text-property (- (point) 1) (point)
;;                            'display (svg-lib-tag (format "%d" count) nil
;;                                                  :ascent 'center)))))
;;   (save-excursion
;;     (let* ((match (search-forward "  " end t)))
;;       (if match
;;           (make-overlay (- match 2) end)
;;         (make-overlay beg end)))))

;; (defun mu4e-folding--make-root-overlay (beg end)
;;   "Create the root overlay."

;;   (let* ((buffer-read-only)
;;          (overlay (car (mu4e-folding--children-overlay)))
;;          (count (if overlay
;;                     (overlay-get overlay 'mu4e-folding-children-count)
;;                   0))
;;          (tag (format "%d" count))
;;          (tag (svg-lib-tag tag nil
;;                            :margin (- 4 (length tag))
;;                            :alignment 1.0
;;                            )))
;;     (save-excursion
;;       (goto-char beg)
;;       (when (search-forward "    " end t)
;;         (set-text-properties (- (point) 4) (+ (point) 1)
;;                              `(display ,tag)))))

;;   (let ((buffer-read-only)
;;         (overlay (make-overlay beg end)))
;;     overlay))

#+end_src

*** Threads separation

#+begin_src emacs-lisp

(defun my-mu4e-headers-is-root ()
  "Check if message at point is the root of a thread"
  (let* ((msg  (get-text-property (point) 'msg))
         (meta (when msg (mu4e-message-field msg :meta)))
         (orphan      (when meta (plist-get meta :orphan)))
         (first-child (when meta (plist-get meta :first-child)))
         (has-child   (when meta (plist-get meta :has-child)))
         (root     (when meta (plist-get meta :root))))

    ;; (and root has-child)
    (or root (and orphan first-child))
    ))

;; my-mu4e-headers-is-root

(defun my-mu4e-headers-separate-root ()
  (save-excursion
    (let ((buffer-read-only))
      (goto-char (point-min))
      (while (not (eobp))
        (when (my-mu4e-headers-is-root)
          (goto-char (line-beginning-position))
          (unless (or (eq (point) 1)
                      (and (> (point) (point-min))
                           (get-text-property (- (point) 1) 'mu4e-separator)))
            (insert
              (propertize "\n"
                          'mu4e-separator t
                          'face '(:inherit nano-strong
                                  :strike-through t
                                  :height 45
                                  :weight bold
                                  :extend t)))))
        (forward-line)))))

(add-hook 'mu4e-headers-found-hook #'my-mu4e-headers-separate-root)

#+end_src

** Layout for mu4e (1.8, alternative) :HOOK:BINDING:INACTIVE:

A custom multiline headers view for mu4e.

#+name: my-mu4e-headers-multiline
#+begin_src emacs-lisp

(defun my-mu4e-headers-multiline (msg)
  "A multiline headers mode."

  (let* ((sender  (my-mu4e-get-sender msg))
         (date (mu4e-message-field msg :date))
         (date (concat (propertize "" 'display " ")
                       (format "%16s" (my-date-relative date))))
         (subject (mu4e-message-field msg :subject))
         (subject (truncate-string-to-width subject (- (window-width) 16) nil nil "…"))
         (flagged   (memq 'flagged   (mu4e-message-field msg :flags)))
         (attach    (memq 'attach    (mu4e-message-field msg :flags)))
         (unread    (memq 'unread    (mu4e-message-field msg :flags)))
         (replied   (memq 'replied   (mu4e-message-field msg :flags)))
         (encrypted (memq 'encrypted (mu4e-message-field msg :flags)))
         (draft     (memq 'draft     (mu4e-message-field msg :flags)))
         (thread (mu4e-message-field msg :meta))
         (related (and thread (plist-get thread :related)))
         (prefix (mu4e~headers-thread-prefix thread))
         (root (plist-get thread :root))
         (orphan (plist-get thread :orphan))
         (first-child (plist-get thread :first-child))
         (has-child (plist-get thread :has-child))
         (level (plist-get thread :level))
         (root (or root (and orphan (or first-child has-child))))
         (child (and thread (not root)))
         (tags      (mu4e-message-field msg :tags))
         (unread-mark (propertize (cond (unread               (propertize " ●" 'face 'nano-salient))
                                        ((and root has-child) "  ")
                                        (t                    "  "))))
         (one-line (and child mu4e-headers-include-related))
         (face-sender (cond (unread               '(nano-salient nano-strong))
                            ((and root related)   '(nano-strong nano-faded))
                            (root                '(nano-strong nano-default))
                            ((and child related) '(:inherit nano-faded :height 140))
                            (child               '(:inherit nano-default :height 140))
                            (t                   '(nano-default))))
         (face-subject (cond (unread  '(:inherit nano-salient))
                             (related '(:inherit nano-faded))
                             (t       '(:inherit nano-default))))
         (face-tags (cond (related '(:inherit (nano-faded)              :height 120))
                          (t       '(:inherit (nano-popout nano-strong) :height 120))))
         (face-date    (cond (t '(:inherit nano-faded :height 140))))

         (icons (string-join
                 `(,@(if draft   `( ,(propertize "" 'face 'nano-faded)))
                   ,@(if attach  `( ,(propertize "" 'face 'nano-faded)))
                   ,@(if flagged `( ,(propertize "" 'face 'nano-salient)))
                   ) " ")))

    (concat

     ;; Separaction line between threads
     (when root
       (concat
        (propertize " "
                    'mu4e-root t
                    'display `((margin left-margin) "  "))
        (propertize "-" 'display "\n"
                    'face '(:extend t
                            :strike-through t
                            :inherit nano-subtle-i))
        "  ")) ;; !! NON-BREAKING SPACE -> will be searched later

     ;; Children are always indented (relatively to root)
     (when (and child one-line)
       (concat
        (propertize "│" 'face 'nano-faded)))

     ;; Unread mark appears in the left margin
     (propertize " " 'face (if unread 'nano-default face-sender)
                     'display `((margin left-margin) ,unread-mark))

     ;; Sender
     (cond (one-line     (propertize (concat prefix sender)
                                     'face face-sender))
           ((and root has-child) (propertize (concat " " sender)
                                             'face face-sender))
           (t (propertize sender 'face face-sender)))

     " "
     ;; Replied
     (when replied
         (propertize " " 'face face-sender))

     ;; In one line mode (children), icons are displayed next to sender
     (when one-line
         (concat (propertize icons)
                 " "))

     ;; Tags next to sender
     (when tags
       (concat
        (propertize " " 'face face-tags)
        (mapconcat #'(lambda (tag)
                       (propertize tag 'face face-tags))
                   tags (propertize "," 'face face-tags))))

     ;; Spacing to have date aligned on the right
     (propertize " " 'display `(space :align-to (- right 1 ,(* 1.0 (length date)))))

     ;; Date
     (propertize date 'face face-date)

     ;; When not a child
     (when (or root (not mu4e-headers-include-related))
       (concat

        ;; Second line. We use a display property such that hl-line-mode works correctly.
        (propertize " " 'display "\n") ;; NON-BREAKING space for later search (see below)

        ;; Blank spaces in the margin (for nice hl-line-mode)
        (propertize " " 'face '(nano-strong nano-salient)
                        'display `((margin left-margin) "  "))

        ;; Indentation (to compensate for the virtual "\n" we introduced before)
        (propertize "  ")

        ;; Align subject and sender when this is a child
        (when (and one-line child)
            (propertize "  " 'face 'nano-faded))

        ;; Subject
        (propertize subject 'face face-subject)

        ;; Spacing to have icons aligned on the right
        (propertize " " 'display `(space :align-to (- right ,(length icons) 1)))

        ;; Icons on the right
        (propertize icons))))))

#+end_src

Then, we redefine thread symbols (we'll mostly manage ourselves).

#+begin_src emacs-lisp

(setq mu4e-headers-thread-root-prefix          '(""    . "")
      mu4e-headers-thread-first-child-prefix   '(" "   . " ")
      mu4e-headers-thread-child-prefix         '(" "   . " ")
      mu4e-headers-thread-last-child-prefix    '(" "   . " ")
      mu4e-headers-thread-connection-prefix    '(" |"  . "  ")
      mu4e-headers-thread-blank-prefix         '(""    . "")
      mu4e-headers-thread-orphan-prefix        '(" "   . "")
      mu4e-headers-thread-single-orphan-prefix '(""    . "")
      mu4e-headers-thread-duplicate-prefix     '("="   . "="))

#+end_src

And we install the new header.

#+begin_src emacs-lisp

;; (add-to-list 'mu4e-header-info-custom
;;              '(:multiline . (:name "multiline"
;;                              :shortname ""
;;                              :function my-mu4e-headers-multiline)))
;; (setq mu4e-headers-fields  '((:multiline . nil)))

#+end_src

*** Margins :INACTIVE:

Because the multiline header view uses margin to show new mail, we have to make sure there are always margin in the headers view. We also make the hl-line more salient.

#+name: my-mu4e-headers-setup
#+begin_src emacs-lisp

(defun my-mu4e-headers-mode-setup ()

  (with-current-buffer "*mu4e-headers*"
    (set-face-attribute 'mu4e-header-highlight-face nil
                        :inherit 'nano-salient-i)
    (setq-local left-margin-width 2)
    (setq-local cursor-type nil)
    (set-window-buffer nil "*mu4e-headers*")))

(add-hook 'mu4e-headers-found-hook #'my-mu4e-headers-mode-setup)
(add-hook 'mu4e-headers-mode-hook  #'my-mu4e-headers-mode-setup)

#+end_src

*** Navigation :INACTIVE:

Since a header can now be displayed over several consecutive lines, we need to remap prev/next line such as to use mu4e prev/next functions (that works properly with multiline headers).

#+begin_src emacs-lisp

(bind-key [remap next-line] #'mu4e-headers-next mu4e-headers-mode-map)
(bind-key [remap previous-line] #'mu4e-headers-prev mu4e-headers-mode-map)

#+end_src

*** Highlight :INACTIVE:

A special highlight function for root headers that takes the multiline root header into account.

#+begin_src emacs-lisp

(defun my-mu4e-hl-line-move ()

  (save-excursion
    (let* ((beg (line-beginning-position))
           (end (min (line-beginning-position 2) (point-max)))
           (match1 (search-forward "  " end t))
           (match2 (search-forward "│" end t)))
      (goto-char beg)
      (cond (match1 (cons (- match1 2) end))
            (match2 (cons (+ match2 1) end))
            (t      (cons beg end))))))

#+end_src

We retrict the hack to mu4e-header-mode

#+begin_src emacs-lisp

 (defun my-mu4e-headers-mode-hl-line-move ()
     (setq-local hl-line-range-function #'my-mu4e-hl-line-move))

 (add-hook 'mu4e-headers-mode-hook  #'my-mu4e-headers-mode-hl-line-move)

#+end_src

*** Folding :INACTIVE:

A special overlay function for folding that takes the multiline root header
into account & insert the number of children at the root level (replacing "" symbol)

#+begin_src emacs-lisp

(defun mu4e-folding--make-root-overlay (beg end)
  "Create the root overlay."

  (let* ((buffer-read-only)
         (overlay (car (mu4e-folding--children-overlay)))
         (count (if overlay
                    (overlay-get overlay 'mu4e-folding-children-count)
                  0)))
    (save-excursion
      (goto-char beg)
      (when (search-forward "" end t)
        (put-text-property (- (point) 1) (point)
                           'display (svg-lib-tag (format "%d" count) nil
                                                 :ascent 'center)))))
  (save-excursion
    (let* ((match (search-forward "  " end t)))
      (if match
          (make-overlay (- match 2) end)
        (make-overlay beg end)))))


#+end_src

#+begin_src emacs-lisp

(defun my-mu4e-move-mark-overlay ()
   (interactive)
   (let* ((beg (line-beginning-position))
          (end (line-beginning-position 2))
          (overlays (overlays-in beg end)))
     (dolist (overlay overlays)
       (when (overlay-get overlay 'mu4e-mark)
         (move-overlay overlay
                       (overlay-start overlay)
                       (+ (overlay-start overlay) 2))))))

#+end_src

** Dashboard

Provide a [[help:mu4e-dashboard][mu4e-dashboard]] command that opens the mu4e dashboard on the left side.

#+name: mu4e-dashboard
#+begin_src emacs-lisp

(require 'mu4e-dashboard)
(require 'svg-lib)

(setq mu4e-dashboard-propagate-keymap nil)

(defun mu4e-dashboard ()
  "Open the mu4e dashboard on the left side."

  (interactive)
  (with-selected-window
      (split-window (selected-window) -34 'left)

    (find-file (expand-file-name "mu4e-dashboard.org" user-emacs-directory))
    (mu4e-dashboard-mode)
    (hl-line-mode)
    (set-window-dedicated-p nil t)i
    (defvar svg-font-lock-keywords
      `(("\\!\\([\\ 0-9]+\\)\\!"
         (0 (list 'face nil 'display (svg-font-lock-tag (match-string 1)))))))
    (defun svg-font-lock-tag (label)
      (svg-lib-tag label nil
                   :stroke 0 :margin 1 :font-weight 'bold
                   :padding (max 0 (- 3 (length label)))
                   :foreground (face-foreground 'nano-popout-i)
                   :background (face-background 'nano-popout-i)))
    (push 'display font-lock-extra-managed-props)
    (font-lock-add-keywords nil svg-font-lock-keywords)
    (font-lock-flush (point-min) (point-max))))

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "Mail")

#+end_src





* Bibliography

** Bibtex

Settings for bibtex

#+begin_src emacs-lisp
(setq bibtex-autokey-titleword-length 0
      bibtex-autokey-name-year-separator ":"
      bibtex-autokey-name-case-convert-function 'capitalize
      bibtex-autokey-year-length 4
      bibtex-autokey-names 1
      bibtex-autokey-titleword-separator ""
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-edit-before-use nil
      imenu-list-position 'left
      imenu-list-size 100
      org-imenu-depth 2
      org-image-actual-width `( ,(truncate (* (frame-pixel-width) 0.85)))
      org-startup-with-inline-images t)
#+end_src

** Org bib mode :HOOK:

Dedicated header line for org-bib-mode

#+begin_src emacs-lisp

(defun my-org-bib-mode-hook ()

  (with-current-buffer "*Ilist*"
    (setq header-line-format
        '(:eval
          (nano-modeline-render nil
                                (buffer-name imenu-list--displayed-buffer)
                                (format "(view mode: %s, filter: %s)"
                                        (if (eq org-bib--view-mode-current 'none)
                                            "-"
                                          org-bib--view-mode-current)
                                        (if (eq org-imenu-filter-string "*")
                                            "-"
                                          org-imenu-filter-string))
                                "")))
    (face-remap-add-relative 'hl-line :inherit 'nano-strong-i)))

(add-hook 'org-bib-mode-hook #'my-org-bib-mode-hook)

#+end_src

A shortcut to edit bibliography

#+begin_src emacs-lisp :prologue "" :epilogue ""
(defun my-biblio ()
  "Create a new frame for editing bibliography"

  (interactive)
  (require 'org-bib)
  (setq imenu-list-position 'left
        imenu-list-size 100
        org-imenu-depth 2)

  (select-frame (make-frame '((name . "my-biblio")
                              (width . 180)
                              (height . 45))))
  (find-file "~/Documents/mathematics/research/literature.org")
  (org-bib-mode))

#+end_src

An autoload function for my-config (that will load org mode).

#+begin_src emacs-lisp :prologue "" :epilogue ""

(autoload 'my-biblio
  (expand-file-name "init.el" user-emacs-directory)
  "Autoloaded my-config command."
  t)

#+end_src


* Org :DEFER:
:PROPERTIES:
:header-args:emacs-lisp: :prologue "(with-eval-after-load 'org" :epilogue ")"
:END:

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** General :HOOK:

#+begin_src emacs-lisp

(setq-default org-directory "~/Documents/org"
              org-ellipsis " …"              ; Nicer ellipsis
              org-tags-column 1              ; Tags next to header title
              org-hide-emphasis-markers t    ; Hide markers
              org-cycle-separator-lines 2    ; Number of empty lines between sections
              org-use-tag-inheritance nil    ; Tags ARE NOT inherited
              org-use-property-inheritance t ; Properties ARE inherited
              org-indent-indentation-per-level 2 ; Indentation per level
              org-link-use-indirect-buffer-for-internals t ; Indirect buffer for internal links
              org-fontify-quote-and-verse-blocks t ; Specific face for quote and verse blocks
              org-return-follows-link nil    ; Follow links when hitting return
              org-image-actual-width nil     ; Resize image to window width
              org-indirect-buffer-display 'other-window ; Tab on a task expand it in a new window
              org-outline-path-complete-in-steps nil) ; No steps in path display

#+end_src

Better latex preview (see https://stackoverflow.com/questions/30151338)

#+begin_src emacs-lisp

(setq org-latex-create-formula-image-program 'dvisvgm)

#+end_src

We adapt fill functions according to the indent level.

#+begin_src emacs-lisp

 (defun my-calc-offset-on-org-level ()
   "Calculate offset (in chars) on current level in org mode file."

   (* (or (org-current-level) 0) org-indent-indentation-per-level))

 (defun my-org-fill-paragraph (&optional justify region)
   "Calculate apt fill-column value and fill paragraph."

   (let* ((fill-column (- fill-column (my-calc-offset-on-org-level))))
     (org-fill-paragraph justify region)))

 (defun my-org-auto-fill-function ()
   "Calculate apt fill-column value and do auto-fill"

   (let* ((fill-column (- fill-column (my-calc-offset-on-org-level))))
     (org-auto-fill-function)))

 (defun my-org-mode-hook ()
   (setq fill-paragraph-function #'my-org-fill-paragraph
         normal-auto-fill-function #'my-org-auto-fill-function))

 (add-hook 'org-load-hook 'my-org-mode-hook)
 (add-hook 'org-mode-hook 'my-org-mode-hook)

#+end_src

A shortcut for emacs-lisp source blocks. Type "<S" (in org-mode) then press tab.

#+begin_src emacs-lisp

(require 'org-tempo)
(add-to-list 'org-structure-template-alist
             '("S" . "src emacs-lisp"))

#+end_src

** Babel

#+begin_src emacs-lisp

(setq-default org-src-fontify-natively t         ; Fontify code in code blocks.
              org-adapt-indentation nil          ; Adaptive indentation
              org-src-tab-acts-natively t        ; Tab acts as in source editing
              org-confirm-babel-evaluate nil     ; No confirmation before executing code
              org-edit-src-content-indentation 0 ; No relative indentation for code blocks
              org-fontify-whole-block-delimiter-line t) ; Fontify whole block

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "Org")

#+end_src




* Agenda :DEFER:
:PROPERTIES:
:header-args:emacs-lisp: :prologue "(with-eval-after-load 'org-agenda" :epilogue ")"
:END:

#+begin_src emacs-lisp :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** General

Load libraries.

#+begin_src emacs-lisp

(require 'org-agenda)
(require 'org-agenda-property)

#+end_src

Open agenda(s)

#+begin_src emacs-lisp :prologue "" :epilogue ""

(bind-key "C-c a" #'org-agenda)

#+end_src

Files

#+begin_src emacs-lisp

(setq org-agenda-files (list "~/Documents/org-files/agenda/maths.org"
                             "~/Documents/org-files/agenda/leisure.org")
      org-agenda-diary-file (expand-file-name "diary" user-emacs-directory))

#+end_src

Settings

#+begin_src emacs-lisp

(setq org-agenda-window-setup 'current-window
      org-agenda-restore-windows-after-quit t
      org-agenda-show-all-dates nil
      org-agenda-time-in-grid t
      org-agenda-show-current-time-in-grid t
      org-agenda-start-on-weekday 1
      org-agenda-span 7
      org-agenda-hide-tags-regexp "." ; No tags
    ; org-agenda-hide-tags-regexp nil) ; All tags
      org-agenda-tags-column 0
    ; org-agenda-tags-column -79)      ; Left aling
      org-agenda-block-separator nil
      org-agenda-category-icon-alist nil
      org-agenda-skip-deadline-if-done t
      org-agenda-skip-scheduled-if-done t
      org-agenda-sticky t)

#+end_src

Prefix format

#+begin_src emacs-lisp

(setq org-agenda-prefix-format
      '((agenda . "%i %?-12t%s")
        (todo .   "%i")
        (tags .   "%i")
        (search . "%i")))

#+end_src

Sorting strategy

#+begin_src emacs-lisp

(setq org-agenda-sorting-strategy
      '((agenda deadline-down scheduled-down todo-state-up time-up
                habit-down priority-down category-keep)
        (todo   priority-down category-keep)
        (tags   timestamp-up priority-down category-keep)
        (search category-keep)))

#+end_src

Minimal time grid

#+begin_src emacs-lisp

(setq org-agenda-time-grid
      '((daily today require-timed)
        ()
        "......" "----------------"))

(setq org-agenda-current-time-string "   now")

#+end_src

A small function to cancel a meeting

#+begin_src emacs-lisp

(defun my-org-cancel-meeting ()
  (interactive)
  (org-entry-put (point) "CATEGORY" "cancelled")
  (org-entry-put (point) "NOTE" "Cancelled")
  (org-set-tags ":CANCELLED:"))

#+end_src

** Holidays :HOOK:PERSONAL:

#+begin_src emacs-lisp

(require 'cal-iso)
(require 'holidays)

(defvar french-holidays nil
  "French holidays")

(setq french-holidays
      `((holiday-fixed 1 1 "New year's Day")
	    (holiday-fixed 5 1 "Labour Day")
	    (holiday-fixed 5 8 "Victory in Europe Day")
	    (holiday-fixed 7 14 "Bastille day")
	    (holiday-fixed 8 15 "Assumption of Mary")
	    (holiday-fixed 11 11 "Armistice 1918")
	    (holiday-fixed 11 1 "All Saints' Day")
	    (holiday-fixed 12 25 "Christmas Day")
	    (holiday-easter-etc 0 "Easter Sunday")
        (holiday-easter-etc 1 "Easter Monday")
        (holiday-easter-etc 39 "Ascension Day")
        (holiday-easter-etc 50 "Whit Monday")
        (holiday-sexp
         '(if (equal
               (holiday-easter-etc 49)
               (holiday-float 5 0 -1 nil))
              (car (car (holiday-float 6 0 1 nil)))
            (car (car (holiday-float 5 0 -1 nil))))
         "Mother's Day")))

(setq calendar-holidays french-holidays     ; French holidays
      calendar-week-start-day 1             ; Week starts on Monday
      calendar-mark-diary-entries-flag nil) ; Do not show diary entries

; Mark today in calendar
(add-hook 'calendar-today-visible-hook  #'calendar-mark-today)

#+end_src

Week day name with holidays

#+name: my-org-agenda-format-date
#+begin_src emacs-lisp

(defun my-org-agenda-format-date (date)
  "Org agenda date format displaying holidays"
  (let* ((dayname (calendar-day-name date))
	     (day (cadr date))
	     (month (car date))
	     (monthname (calendar-month-name month))
	     (year (nth 2 date))
         (holidays (calendar-check-holidays date)))
    (concat "\n"
            dayname " "
            (format "%d " day)
            monthname " "
            (format "%d" year)
            (if holidays (format " (%s)" (nth 0 holidays)))
            "\n")))

(setq org-agenda-format-date #'my-org-agenda-format-date)

#+end_src

** Daily agenda :HOOK:ADVICE:BINDING:

The daily agenda

#+begin_src emacs-lisp

(add-to-list 'org-agenda-custom-commands
             '("a" "Agenda"
               ((agenda "Agenda"
                        ((org-agenda-todo-keyword-format "%s")
                         (org-agenda-skip-deadline-if-done nil)
                         (org-deadline-warning-days 3)
                         (org-agenda-overriding-header nil))))))

#+end_src

Some decorations for the agenda

#+name: my-org-agenda-highlight-todo
#+begin_src emacs-lisp

(defun my-org-agenda-highlight-todo (x)
  (let* ((done (string-match-p (regexp-quote ":DONE:") x))
         (canceled (string-match-p (regexp-quote "~") x))
         (x (replace-regexp-in-string ":TODO:" "" x))
         (x (replace-regexp-in-string ":DONE:" "" x))
         (x (replace-regexp-in-string "~" "" x))
         (x (if (and (boundp 'org-agenda-dim) org-agenda-dim)
                (propertize x 'face 'nano-faded) x))
         (x (if done (propertize x 'face 'nano-faded) x))
         (x (if canceled (propertize x 'face 'nano-faded) x)))
    x))

;;(advice-add 'org-agenda-highlight-todo
;;            :filter-return #'my-org-agenda-highlight-todo)

#+end_src

Timestamp tags for the agenda (bold means inverse video below):

now        -> *now*
9:00       -> *9h00*
9:30-10:00 -> 9h30 | *30mn*
           -> ANYTIME

#+name: svg-tag-timestamp
#+begin_src emacs-lisp

(require 'svg-lib)
(require 'svg-tag-mode)

(defun my-svg-tag-timestamp (&rest args)
  "Create a timestamp SVG tag for the time at point."

  (interactive)
  (let ((inhibit-read-only t))

    (goto-char (point-min))
    (while (search-forward-regexp
            "\\(\([0-9]/[0-9]\):\\)" nil t)
              (set-text-properties (match-beginning 1) (match-end 1)
                             `(display ,(svg-tag-make "ANYTIME"
                                                      :face 'nano-faded
                                                      :inverse nil
                                                      :padding 3 :alignment 0))))

    (goto-char (point-min))
    (while (search-forward-regexp
            "\\([0-9]+:[0-9]+\\)\\(\\.+\\)" nil t)

              (set-text-properties (match-beginning 1) (match-end 2)
                             `(display ,(svg-tag-make (match-string 1)
                                                       :face 'nano-faded
                                                       :margin 4 :alignment 0))))

    (goto-char (point-min))
    (while (search-forward-regexp
            "\\([0-9]+:[0-9]+\\)\\(\\.*\\)" nil t)

              (set-text-properties (match-beginning 1) (match-end 2)
                             `(display ,(svg-tag-make (match-string 1)
                                                      :face 'nano-default
                                                      :inverse t
                                                      :margin 4 :alignment 0))))
    (goto-char (point-min))
    (while (search-forward-regexp
            "\\([0-9]+:[0-9]+\\)\\(-[0-9]+:[0-9]+\\)" nil t)
      (let* ((t1 (parse-time-string (match-string 1)))
             (t2 (parse-time-string (substring (match-string 2) 1)))
             (t1 (+ (* (nth 2 t1) 60) (nth 1 t1)))
             (t2 (+ (* (nth 2 t2) 60) (nth 1 t2)))
             (d  (- t2 t1)))

        (set-text-properties (match-beginning 1) (match-end 1)
                                `(display ,(svg-tag-make (match-string 1)
                                                         :face 'nano-faded
                                                         :crop-right t)))
        ;; 15m: ¼, 30m:½, 45m:¾
        (if (< d 60)
             (set-text-properties (match-beginning 2) (match-end 2)
                                  `(display ,(svg-tag-make (format "%2dm" d)
                                                           :face 'nano-faded
                                                           :crop-left t :inverse t)))
           (set-text-properties (match-beginning 2) (match-end 2)
                                `(display ,(svg-tag-make (format "%1dH" (/ d 60))
                                                         :face 'nano-faded
                                                         :crop-left t :inverse t
                                                         :padding 2 :alignment 0))))))))

#+end_src


#+begin_src emacs-lisp

(add-hook 'org-agenda-mode-hook #'my-svg-tag-timestamp)
(advice-add 'org-agenda-redo :after #'my-svg-tag-timestamp)

#+end_src

** Tasks agenda

A custom date format function using svg tags (progress pies) for the task agenda.

#+name: my-org-agenda-custom-date
#+begin_src emacs-lisp

(defun my-org-agenda-custom-date ()
  (interactive)
  (let* ((timestamp (org-entry-get nil "TIMESTAMP"))
         (timestamp (or timestamp (org-entry-get nil "DEADLINE"))))
    (if timestamp
        (let* ((delta (- (org-time-string-to-absolute (org-read-date nil nil timestamp))
                         (org-time-string-to-absolute (org-read-date nil nil ""))))
               (delta (/ (+ 1 delta) 30.0))
               (face (cond ;; ((< delta 0.25) 'nano-popout)
                           ;; ((< delta 0.50) 'nano-salient)
                           ((< delta 1.00) 'nano-default)
                           (t 'nano-faded))))
          (concat
           (propertize " " 'face nil
                       'display (svg-lib-progress-pie
                                 delta nil
                                 :background (face-background face nil 'default)
                                 :foreground (face-foreground face)
                                 :margin 0 :stroke 2 :padding 1))
           " "
           (propertize
            (format-time-string "%d/%m" (org-time-string-to-time timestamp))
            'face 'nano-popout)))
      "     ")))

#+end_src

The task agenda

#+begin_src emacs-lisp

(add-to-list 'org-agenda-custom-commands
        '("x" "Tasks"
          ((todo "TODO" ;; "PROJECT"
                 ( (org-agenda-todo-keyword-format ":%s:")
                   (org-agenda-prefix-format '((todo   . " ")))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp))
                   (org-agenda-overriding-header (propertize " Todo \n" 'face 'nano-strong))))

           (tags "+TALK+TIMESTAMP>=\"<now>\""
                 ((org-agenda-span 90)
                  (org-agenda-max-tags 5)
                  (org-agenda-prefix-format '((tags   . " %(my-org-agenda-custom-date) ")))
                  (org-agenda-overriding-header "\n Upcoming talks\n")))

           (tags "TEACHING+TIMESTAMP>=\"<now>\""
                 ((org-agenda-span 90)
                  (org-agenda-max-tags 5)
                  (org-agenda-prefix-format '((tags   . " %(my-org-agenda-custom-date) ")))
                  (org-agenda-overriding-header "\n Upcoming lessons\n")))

           (tags "TRAVEL+TIMESTAMP>=\"<now>\""
                 ((org-agenda-span 90)
                  (org-agenda-max-tags 5)
                  (org-agenda-prefix-format '((tags .  " %(my-org-agenda-custom-date) ")))
                  (org-agenda-overriding-header "\n Upcoming travels\n")))

           (tags "DEADLINE>=\"<today>\""
                  ((org-agenda-span 90)
                   (org-agenda-max-tags 5)
                   (org-agenda-prefix-format '((tags .  " %(my-org-agenda-custom-date) ")))
                   (org-agenda-overriding-header "\n Upcoming deadlines\n"))))))

#+end_src

** Update :TIMER:

We install a time to refresh the daily agenda (a) at regular intervals such that the current time is up to date.

#+begin_src emacs-lisp

(defvar my-org-agenda-update-delay 60)
(defvar my-org-agenda-update-timer nil)

(defun my-org-agenda-update ()
  "Refresh daily agenda view"

  (when my-org-agenda-update-timer
    (cancel-timer my-org-agenda-update-timer))

  (let ((window (get-buffer-window "*Org Agenda(a)*" t)))
    (when window
      (with-selected-window window
        (let ((inhibit-message t))
          (org-agenda-redo)))))

  (setq my-org-agenda-update-timer
    (run-with-idle-timer
     (time-add (current-idle-time) my-org-agenda-update-delay)
     nil
     'my-org-agenda-update)))

(run-with-idle-timer my-org-agenda-update-delay t 'my-org-agenda-update)

#+end_src

** Refile

Set refile targets according to my setup

#+begin_src emacs-lisp
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-use-outline-path nil)
(setq org-refile-targets
      '(
        ("~/Documents/org/agenda.org"    :maxlevel . 2)
        ("~/Documents/org/inbox.org"     :maxlevel . 1)
;;        ("~/Documents/org/organizer.org" :tag      . "tasks")
;;        ("~/Documents/org/organizer.org" :tag      . "notes")
;;        ("~/Documents/org/organizer.org" :tag      . "mails")
;;        ("~/Documents/org/organizer.org" :tag      . "meetings")
        ;;("~/Documents/org/archives.org" :maxlevel . 1)
        ))

#+end_src
** Capture :ADVICE:BINDING:

#+begin_src emacs-lisp :prologue "" :epilogue ""

(setq org-capture-templates
      '(("i" "Inbox"  entry   (file "inbox.org")
         "* TODO %?Task :INBOX:\n")

        ("m" "Meeting" entry  (file+headline "agenda.org" "Future")
         "* %?Meeting   <%<%Y-%m-%d %a 12:00-13:00>>"
         :empty-lines-after 1)))

#+end_src

Assign key

#+begin_src emacs-lisp :prologue "" :epilogue ""

(bind-key "C-c c" #'org-capture)

(defun my-org-capture-meeting ()
  (interactive)
  (org-capture nil "m"))

(bind-key "C-c m" #'my-org-capture-meeting)

(defun my-org-capture-inbox ()
  (interactive)
  (org-capture nil "i"))

(bind-key "C-c i" #'my-org-capture-inbox)

#+end_src

Here we orverwrite the [[help:org-capture-place-template][org-capture-place-template]] to have the capture window below the current one. There must be a better way to do that but I did not find it yet. Since we are in org-agenda deferred mode, we need to cancel epiloque/prologue.

#+begin_src emacs-lisp :prologue "" :epilogue ""

(with-eval-after-load 'org-capture

  (defun org-capture-place-template (&optional inhibit-wconf-store)
    "Insert the template at the target location, and display the buffer.
when `inhibit-wconf-store', don't store the window configuration, as it
may have been stored before."
    (unless inhibit-wconf-store
      (org-capture-put :return-to-wconf (current-window-configuration)))
    ;; (delete-other-windows)
    ;; (org-switch-to-buffer-other-window
    ;;  (org-capture-get-indirect-buffer (org-capture-get :buffer) "CAPTURE"))
    (select-window (split-window-below -6))
    (switch-to-buffer
     (org-capture-get-indirect-buffer (org-capture-get :buffer) "CAPTURE"))
    (widen)
    (org-show-all)
    (goto-char (org-capture-get :pos))
    (setq-local outline-level 'org-outline-level)
    (pcase (org-capture-get :type)
      ((or `nil `entry) (org-capture-place-entry))
      (`table-line (org-capture-place-table-line))
      (`plain (org-capture-place-plain-text))
      (`item (org-capture-place-item))
      (`checkitem (org-capture-place-item)))
    (setq-local org-capture-current-plist org-capture-plist)
    (org-capture-mode 1)))

#+end_src

** Capture 2 :ADVICE:BINDING:

#+begin_src emacs-lisp

(defun my-org-capture-frame (orig-fun &optional goto keys)
  (if (not (org-capture-get :description))
      (funcall orig-fun goto keys))
  (progn
    (select-frame (my-mini-frame 8))
    (let ((split-width-threshold nil)
          (split-height-threshold 0))
      (funcall orig-fun goto keys))
    (delete-other-windows)
    (setq word-wrap nil)
    (setq truncate-lines nil)
    (nano-modeline--update-selected-window)
    (let* ((left (concat (propertize " "
                                     'face '(nano-subtle)
                                     'display '(raise +0.20))
                         (propertize " Capture"
                                     'face '(nano-strong nano-subtle))
                         (propertize " "
                                     'face 'nano-subtle
                                     'display '(raise -0.30))
                         (propertize (org-capture-get :description)
                                     'face 'nano-default)))
                 (right (propertize "C-c C-c: capture, C-c C-k: abort "
                                    'face '(:inherit (nano-faded nano-subtle)
                                            :weight light)))
         (spacer (propertize (make-string (- (window-width)
                                             (length left)
                                             (length right)
                                             0) ?\ )
                             'face 'nano-subtle))
         (header (concat left spacer right " ")))
    (setq-local header-line-format header))

    (set-window-dedicated-p nil t)
    (set-frame-parameter (selected-frame) 'height 5)
    (face-remap-add-relative 'mode-line :background (face-background 'highlight))
    (save-excursion
      (goto-char (point-min))
      (let ((overlay (make-overlay
                      (line-beginning-position) (line-end-position))))
        (overlay-put overlay 'display '(raise -0.5))))))

#+end_src

#+begin_src emacs-lisp

(defun my-org-capture (goto key)
  (interactive)
  (unwind-protect
      (progn
        (advice-add 'org-capture :around #'my-org-capture-frame)
        (org-capture goto key))
    (advice-remove 'org-capture #'my-org-capture-frame)))

(require 'org-capture)

;; (bind-key "C-c m" #'(lambda ()
;;                       (interactive)
;;                       (my-org-capture nil "m")))

;; (bind-key "C-c i" #'(lambda ()
;;                       (interactive)
;;                       (my-org-capture nil "i")))

;; (bind-key "C-g" #'org-capture-kill 'org-capture-mode-map)

#+end_src

** Navigation :ADVICE:

The default [[help:org-agenda-goto][org-agenda-goto]], which is used when =tab= key is pressed or when follow mode (F) is active open a window at a non specific place. Here, we make sure the window is opened where we want. In this case, this is below the agenda window.

#+begin_src emacs-lisp

(defun my-org-agenda-goto (buffer args)
  "Open a headline in a window below the current window"

  (setq-local mode-line-format nil)
  (select-window (or (window-in-direction 'below (selected-window))
                     (split-window nil -6 'below)))
  (switch-to-buffer buffer)
  (setq-local header-line-format
              '((:eval
                 (let ((nano-modeline-prefix 'none)
                       (nano-modeline-prefix-padding 0)
                       (outline-path (org-with-point-at (org-get-at-bol'org-marker)
                                       (org-display-outline-path nil nil " » " t))))
                   (nano-modeline-render
                    ""
                    (file-name-nondirectory
                     (buffer-file-name (buffer-base-buffer)))
                    (format "/ %s" (substring-no-properties outline-path))
                    "")))))
  (selected-window))

#+end_src

Install the new function as an advice around [[help:org-agenda-goto][org-agenda-goto]] and apply a narrow to subtree after

#+begin_src emacs-lisp

(define-advice org-agenda-goto (:around (orig-fn &rest args) "my-org-agenda-goto")
  (let ((display-buffer-overriding-action '(my-org-agenda-goto)))
    (apply orig-fn args)
    (org-narrow-to-subtree)))

#+end_src


Finally, we disable [[help:org-agenda-show-outline-path][org-agenda-show-outline-path]] since this is now redundant with the header line.

#+begin_src emacs-lisp

(setq org-agenda-show-outline-path nil)

#+end_src

** Nano agenda :BINDING:

#+header: :prologue "" :epilogue ""
#+begin_src emacs-lisp

(bind-key "C-c n" #'nano-agenda)

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "Agenda")

#+end_src


* Versioning

#+begin_src emacs-lisp :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** Magit :ADVICE:HOOK:

Prevent magit from writing in the header line.

#+begin_src emacs-lisp

(advice-add 'magit-set-header-line-format :override #'ignore)

#+end_src

Add fringe on the left side of magit windows such that we can highlight region using the fringe.

#+begin_src emacs-lisp

(add-hook 'magit-mode-setup-hook
          #'(lambda ()
              (interactive)
              (set-window-fringes nil (* 2 (window-font-width)) 0)))

#+end_src
** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "Versioning")

#+end_src


* News :DEFER:
:PROPERTIES:
:header-args:emacs-lisp: :prologue "(with-eval-after-load 'elfeed" :epilogue ")"
:END:

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** Read :HOOK:BINDING:

Alternative print entry function using [[https://github.com/rougier/svg-tag-mode][svg-tag-mode]].

#+begin_src emacs-lisp

(require 'elfeed)
(require 'svg-tag-mode)

(defun my-elfeed-search-print-entry (entry)
  "Alternative printing of elfeed entries using SVG tags."

  (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title (or (elfeed-meta entry :title)
                    (elfeed-entry-title entry) ""))
         (unread (member 'unread (elfeed-entry-tags entry)))
         (feed (elfeed-entry-feed entry))
         (feed-title (when feed
                       (or (elfeed-meta feed :title)
                           (elfeed-feed-title feed))))
         (title-face (if unread 'nano-default 'nano-faded))
         (date-face (if unread 'nano-salient 'nano-faded))
         (feed-title-face (if unread 'nano-strong '(nano-strong nano-faded)))
         (tag-face (if unread 'nano-popout 'nano-faded))
         (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
         (tags (delete "unread" tags))
         (tags-svg (mapconcat
                    (lambda (s)
                      (propertize (concat (upcase s) " ")
                                  'display (svg-tag-make (upcase s)
                                                         :margin 0
                                                         :padding 1
                                                         :inverse 1
                                                         :face tag-face)))
                    tags " "))
         (left (concat
                (when feed-title
                  (propertize feed-title 'face feed-title-face))
                " " tags-svg " "
                (propertize title 'face title-face 'kbd-help title)))
         (right (propertize date 'face date-face)))
    (insert (my-string-join -1 left right))))

#+end_src

Elfeed setup.

#+begin_src emacs-lisp

(setq elfeed-search-title-max-width 80    ; Maximum titles width
      elfeed-search-title-min-width 40    ; Minimum titles width
      elfeed-search-trailing-width 24     ; Space reserved for feed & tag
      elfeed-search-filter                ; Default filter
          "@1-weeks-ago +unread"
      elfeed-search-print-entry-function  ; Alternative print function
           #'my-elfeed-search-print-entry)


; Bind "U" to update feeds on main screen
(bind-key "U" #'elfeed-update elfeed-search-mode-map)

#+end_src

Hook on elfeed main screen (hl-line mode).

#+name: my-elfeed-search-mode-hook
#+begin_src emacs-lisp

(defun my-elfeed-search-mode-hook ()
  (hl-line-mode t)
  (face-remap-add-relative 'hl-line :inherit 'nano-subtle)
  (set-window-fringes nil 0 1) ; One pixel right fringe to avoid ellipsis
  (setq cursor-type nil))

(add-hook 'elfeed-search-mode-hook  #'my-elfeed-search-mode-hook)

#+end_src

Hook on elfeed post screen (visual mode).

#+name: my-elfeed-show-mode-hook
#+begin_src emacs-lisp

(defun my-elfeed-show-mode-hook ()
  (visual-line-mode)
;;  (setq truncate-lines t)

  (let ((inhibit-read-only t)
        (inhibit-modification-hooks t))
    (setq-local truncate-lines nil)
    (setq-local shr-width 79)
    (set-buffer-modified-p nil)))

(add-hook 'elfeed-show-mode-hook #'my-elfeed-show-mode-hook)

#+end_src

** Bookmarks

Setup bookmarlks ([[file:elfeed.org][elfeed.org]]) using [[https://github.com/remyhonig/elfeed-org][elfeed-org]]. It is important to load it after elfeed such as to not load org immediately.

#+begin_src emacs-lisp

(with-eval-after-load 'elfeed
  (require 'elfeed-org)
  (setq rmh-elfeed-org-files (list (expand-file-name "elfeed.org" user-emacs-directory)))
  (elfeed-org))

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "News")

#+end_src


# * Notes (denote) :DEFER:
# :PROPERTIES:
# :header-args:emacs-lisp: :prologue "(with-eval-after-load 'denote" :epilogue ")"
# :END:

# #+begin_src emacs-lisp  :prologue "" :epilogue ""

# (setq my-section-start-time (current-time))

# #+end_src

# ** Configuration

# Samplet configuration from https://protesilaos.com/emacs/denote

# #+begin_src emacs-lisp

# (require 'denote)

# ;; Remember to check the doc strings of those variables.
# (setq denote-directory (expand-file-name "~/Documents/Denote/"))
# (setq denote-known-keywords
#       '("emacs" "research" "visualisation"))
# (setq denote-infer-keywords t)
# (setq denote-sort-keywords t)
# (setq denote-file-type nil) ; Org is the default, set others here

# ;; We allow multi-word keywords by default.  The author's personal
# ;; preference is for single-word keywords for a more rigid workflow.
# (setq denote-allow-multi-word-keywords t)

# (setq denote-front-matter-date-format nil) ; change this to `org-timestamp' or custom string

# ;; You will not need to `require' all those individually once the
# ;; package is available.
# (require 'denote-retrieve)
# (require 'denote-link)
# (require 'denote-dired)
# (setq denote-dired-rename-expert nil)

# ;; We use different ways to specify a path for demo purposes.
# (setq denote-dired-directories
#       (list denote-directory
#             (thread-last denote-directory (expand-file-name "attachments"))
#             (expand-file-name "~/Documents/vlog")))

# ;; Generic:
# ;; (add-hook 'dired-mode-hook #'denote-dired-mode)
# ;;
# ;; OR better:
# (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)

# ;; Here is a custom, user-level command from one of the examples we
# ;; showed in this manual.  We define it here and add it to a key binding
# ;; below.
# (defun my-denote-journal ()
#   "Create an entry tagged 'journal', while prompting for a title."
#   (interactive)
#   (denote
#    (denote--title-prompt)
#    "journal"))

# ;; Denote does not define any key bindings.  This is for the user to
# ;; decide.  For example:
# (let ((map global-map))
#   (define-key map (kbd "C-c n j") #'my-denote-journal) ; our custom command
#   (define-key map (kbd "C-c n n") #'denote)
#   (define-key map (kbd "C-c n N") #'denote-type)
#   (define-key map (kbd "C-c n d") #'denote-date)
#   ;; If you intend to use Denote with a variety of file types, it is
#   ;; easier to bind the link-related commands to the `global-map', as
#   ;; shown here.  Otherwise follow the same pattern for `org-mode-map',
#   ;; `markdown-mode-map', and/or `text-mode-map'.
#   (define-key map (kbd "C-c n i") #'denote-link) ; "insert" mnemonic
#   (define-key map (kbd "C-c n I") #'denote-link-add-links)
#   (define-key map (kbd "C-c n l") #'denote-link-find-file) ; "list" links
#   (define-key map (kbd "C-c n b") #'denote-link-backlinks)
#   ;; Note that `denote-dired-rename-file' can work from any context, not
#   ;; just Dired bufffers.  That is why we bind it here to the
#   ;; `global-map'.
#   (define-key map (kbd "C-c n r") #'denote-dired-rename-file))

# (with-eval-after-load 'org-capture
#   (require 'denote-org-capture)
#   (setq denote-org-capture-specifiers "%l\n%i\n%?")
#   (add-to-list 'org-capture-templates
#                '("n" "New note (with denote.el)" plain
#                  (file denote-last-path)
#                  #'denote-org-capture
#                  :no-save t
#                  :immediate-finish nil
#                  :kill-buffer t
#                  :jump-to-captured t)))

# #+end_src


# ** Benchmark

# #+begin_src emacs-lisp  :prologue "" :epilogue ""

# (my-report-time "Notes")

# #+end_src



# * Notes (deft) :DEFER:
# :PROPERTIES:
# :header-args:emacs-lisp: :prologue "(with-eval-after-load 'deft" :epilogue ")"
# :END:

# #+begin_src emacs-lisp  :prologue "" :epilogue ""

# (setq my-section-start-time (current-time))

# #+end_src

# ** Read :HOOK:BUGFIX:

# Deft setup

# #+begin_src emacs-lisp

# (setq deft-default-extension "org"
#       deft-extensions '("org")
#       deft-recursive nil
#       deft-use-filename-as-title nil
#       deft-use-filter-string-for-filename t
#       deft-file-naming-rules '((noslash . "-")
#                                (nospace . "-")
#                                (case-fn . downcase))
#       deft-separator " "
#       deft-time-format " %d %b %Y")

# #+end_src

# Rewrite the ~deft-print-header~ function to get rid of "Deft\n"

# #+begin_src emacs-lisp

# (defun deft-print-header ()
#   (force-mode-line-update))

# #+end_src

# Bug fix (see https://github.com/jrblevin/deft/issues/73)

# #+begin_src emacs-lisp

# (defun org-open-file-with-emacs (path)
#   (org-open-file path t))

# #+end_src

# A small bugfix for header that are too long by one character.

# #+begin_src emacs-lisp
# (defun deft-setup ()

#   (face-remap-add-relative 'hl-line :inherit 'nano-salient-i)
#   (set-window-fringes nil 0 1)
#   (set-default 'truncate-lines t))

# (add-hook 'deft-mode-hook #'deft-setup)

# #+end_src

# ** Keywords :ADVICE:

# #+begin_src emacs-lisp

# (defun my-deft-parse-summary (orig-fun contents title)
#   "Filter deft summary in order to extract the first dot
# terminated sentence and add tags if any."

#   (let ((summary (apply orig-fun (list contents title)))
#         (tags nil))
#     (when (and (stringp contents)
#                (string-match "#\\+TAGS:\\(.*\\)$" contents))
#       (setq tags (split-string (string-trim (match-string 1 contents))
#                                  "[ ,]")))
#     (if (and (stringp summary)
#              (string-match "\\(.*?\\)\\. " summary))
#         (concat
#          (when tags
#            (concat (propertize (car tags)
#                                'display (svg-tag-make (car tags)
#                                                       :face 'nano-popout
#                                                       :inverse t))
#                    " "))
#          (match-string 1 summary))
#       summary)))

# (advice-add 'deft-parse-summary :around #'my-deft-parse-summary)

# #+end_src


# #+begin_src emacs-lisp

# (defun deft-note-toggle-keywords ()
#   "Toggle visibility of all keywords."

#   (interactive)
#   (save-excursion
#     (goto-char (point-min))
#     (re-search-forward "^\\(#\\+.*\\)$" nil t)
#     (if (get-text-property (match-beginning 1) 'display)
#         (deft-note-show-keywords)
#       (deft-note-hide-keywords))))

# (defun deft-note-hide-keywords ()
#   "Hide all keywords."

#   (interactive)
#   (save-excursion
#     (goto-char (point-min))
#     (while (re-search-forward "^\\(#\\+.*\\)$" nil t)
#       ;; (message (format "Hiding keyword %s" (match-string 1)))
#       (put-text-property
#         (match-beginning 1) (+ (match-end 1) 1) 'display ""))))

# (defun deft-note-show-keywords ()
#   "Show all keywords."

#   (interactive)
#   (save-excursion
#     (goto-char (point-min))
#     (while (re-search-forward "^\\(#\\+.*\\)$" nil t)
#       ;; (message (format "Showing keyword %s" (match-string 1)))
#       (remove-text-properties
#         (match-beginning 1) (+ (match-end 1) 1) '(display)))))

# (defun deft-note-get-keyword (keyword)
#   "Get the value of a KEYWORD"

#   (interactive)
#   (let ((case-fold-search t)
#         (re (format "^#\\+%s:[ \t]+\\([^\t\n]+\\)" keyword)))
#     (if (save-excursion (or (re-search-forward re nil t)
#                             (re-search-backward re nil t)))
#         (substring-no-properties (match-string 1)))))

# (defun deft-note-set-keyword (keyword value)
#   "Set the VALUE of KEYWORD, creates it if absent."
#   (interactive)
#   (save-excursion
#     (goto-char (point-min))
#     (if (deft-note-get-keyword keyword)
#         (replace-match value t nil nil 1)
#       (insert (format "#+%s: %s\n" keyword value)))))

# #+end_src

# ** Write :HOOK:

# Setup note modes and ask for a title if the file does not exist

# #+begin_src emacs-lisp
# (defun my-deft-open-file ()
#   "Setup note modes and ask for a title if the file does not exist."

#   (when (= (buffer-size (current-buffer)) 0)
#     (setq title (read-from-minibuffer "Note title: "))
#     (deft-note-set-keyword "DATE" (format-time-string "[%Y-%m-%d %a]"))
#     (deft-note-set-keyword "TITLE" (if (> (length title) 0)
#                                        title
#                                      "New note"))
#     (org-mode)
#     (org-indent-mode)
#     (visual-line-mode)))

# (add-hook 'deft-open-file-hook 'my-deft-open-file)

# #+end_src

# ** Benchmark

# #+begin_src emacs-lisp  :prologue "" :epilogue ""

# (my-report-time "Notes")

# #+end_src


* System
#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** Term & shell :ADVICE:

Set default shell (zsh)

#+begin_src emacs-lisp

(setq-default shell-file-name          "/bin/zsh"
              explicit-shell-file-name "/bin/zsh")

#+end_src

Make sure our environment variables are set properly

#+begin_src emacs-lisp

;; (require 'exec-path-from-shell)
;; (exec-path-from-shell-copy-envs '("LANG" "LC_ALL" "LC_CTYPES"))

#+end_src


Kill term buffer when exiting.

#+begin_src emacs-lisp

(defun my-term-handle-exit (&optional proc msg)
  "Kill term buffer (advice)."

  (message "%s | %s" proc msg)
  (kill-buffer (current-buffer)))

(advice-add 'term-handle-exit :after 'my-term-handle-exit)

#+end_src

** OSX :OS:

Open an iterm (OSX) and go to the curent directory

#+begin_src emacs-lisp

(defun my-iterm-here ()
  (interactive)

  (shell-command "open -a iTerm $PWD" nil nil))

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "System")

#+end_src


* Profiling

** Final report

#+begin_src emacs-lisp

(let ((init-time (float-time (time-subtract (current-time) my-init-start-time)))
      (total-time (string-to-number (emacs-init-time "%f"))))

  (message "---------------------------------------------------------------")
  (message "Initialisation time:                 %.2fs (+ %.2f system time)"
           init-time (- total-time init-time)))
  (message "---------------------------------------------------------------")

#+end_src

* NOT YET INTEGRATED

 #+begin_src emacs-lisp
   ;;; -*- coding: utf-8; lexical-binding: t -*-

   ;;; Commentary
   ;;
   ;; This file is heavily inspired by:
   ;; i)   Nicolas Rougier -> https://github.com/rougier/dotemacs/blob/master/dotemacs.org
   ;; ii)  https://blog.sumtypeofway.com/posts/emacs-config.html
   ;; iii) https://blog.d46.us/advanced-emacs-startup/
   ;; iv)
   ;; This init file covers the following topics
   ;;
   ;; I)     GENERAL SETTINGS AND OPTIMISATIONS
   ;; I.1)    GARBADGE COLLECTION
   ;; I.2)    ENCODING
   ;; I.3)    LOCALE
   ;; I.4)    GENERAL SETTINGS
   ;; I.5)    PACKAGE REPOSITORY MANAGMENT
   ;; II)    FILE MANAGMENT, VERSION CONTROL AND BACKUPS
   ;; II.1)   AUTO-SAVE
   ;; II.2)   USE BACKUPS
   ;; II.3)   RECENT FILES
   ;; II.4)   HISTORY
   ;; II.5)   DIRVISH
   ;; II.6)   MISC
   ;; III)   OWN ELISP PACKAGES
   ;; III.1)  SETUP
   ;; III.2)  KEYBINDINGS
   ;; III.3)  CUSTOM EMACS SETTINGS
   ;; III.4)  COMPLETION
   ;; III.5)  PARATHESES
   ;; III.6)  LATEX CUSTOMISATION
   ;; III.7)  ORG-AGENDA CUSTOMISATION
   ;; III.8)  MU4E CONFIGURATION
   ;; III.9)  PYTHON CUSTOMISATION
   ;; III.10)  EMACS PDF CUSTOMISATION
   ;; III.11) STARTUP WINDOW
   ;; III.12) BEAUTIFICATION
   ;; III.13) THEME CUSTOMISATION
   ;;
   ;;; CODE
   ;;
   ;;; I) GENERAL SETTINGS AND OPTIMISATIONS
   ;;  I.1) Garbage collection
   ;;(setq gc-cons-threshold (* 10 1024 1024))

   ;;  I.2) UTF-8 encoding
   (set-default-coding-systems 'utf-8)     ; Set default value of various coding systems
   (prefer-coding-system       'utf-8)     ; Add utf-8 at the front for automatic detection.
   (set-terminal-coding-system 'utf-8)     ; Set coding system of terminal output
   (set-keyboard-coding-system 'utf-8)     ; Set coding system for keyboard input on TERMINAL

   ;;  I.3) Locale
   (set-language-environment "English")    ; Preferred language is english
   (setq calendar-date-style 'european)    ; European style calenders
   (setq calendar-week-start-day '1)       ; The week starts on Monday

   ;;  I.4) EMACS general settings
   (setq-default fill-column 100)                ; Default column line length
   (setq words-include-escapes nil)              ; Don't treat escape chars as part of words
   (setq use-short-answers     t)                ; Why would you ever want to type a full yes?
   (setq user-emacs-directory '"~/.emacs.d/")    ;User emacs directory
   (add-hook 'before-save-hook 'delete-trailing-whitespace) ; On save, delete trailing whitespaces
   (setq require-final-newline t)                ; Require a final newline—POSIX BOIS
   (setq-default cursor-type 'bar)               ; Cursor is presented by a (blinking) bar
   (setq mouse-yank-at-point   t)                ; Yank text to point, not to mouse cursor


   ;;; II) FILE MANAGMENT, VERSION CONTROL AND BACKUPS
   ;;  II.1) Auto-save setup
   (setq auto-save-list-file-prefix ; Prefix for generating auto-save-list-file-name
         (expand-file-name ".auto-save-list/.saves-" user-emacs-directory)
         auto-save-default t        ; Auto-save every buffer that visits a file
         auto-save-timeout 20       ; Number of seconds between auto-save
         auto-save-interval 200)    ; Number of keystrokes between auto-saves

   ;;  II.2) Create and use backups
   (require 'vc-backup)               ; Version control for files
   (setq backup-directory-alist       ; File name patterns and backup directory names.
         `(("." . ,(expand-file-name "backups" user-emacs-directory)))
         make-backup-files t          ; Backup of a file the first time it is saved.
         vc-make-backup-files t       ; No backup of files under version contr
         backup-by-copying t          ; Don't clobber symlinks
         version-control t            ; Version numbers for backup files
         delete-old-versions t        ; Delete excess backup files silently
         kept-old-versions 6          ; Number of old versions to keep
         kept-new-versions 9          ; Number of new versions to keep
         delete-by-moving-to-trash t) ; Delete files to trash

   ;;  II.3) Keeping track of recent files
   (require 'recentf)
   (setq recentf-max-menu-items 10             ; Maximal number of items in the recentf menu
         recentf-max-saved-items 100           ; Maximal number of items for the recentf list
         recentf-exclude '("~/Documents/.*" )) ;

   (let (message-log-max)
     (recentf-mode 1))

   ;; II.4) History
   (defun unpropertize-kill-ring ()    ; Optimise the kill-ring
     (setq kill-ring (mapcar 'substring-no-properties kill-ring)))
   (add-hook 'kill-emacs-hook 'unpropertize-kill-ring)
   ;; The above code removes text properties for kill ring entries.
   ;; See https://emacs.stackexchange.com/questions/4187.
   ;; This saves a lot of time when loading it.

   (require 'savehist)

   (setq kill-ring-max 50      ; Length of the kill ring.
         history-length 50)    ; Maximal length of the history before it is truncated.

   (setq savehist-additional-variables    ; We save the history of the following lists
         '(kill-ring                      ; History of the kill-ring
           command-history                ; History of executed command
           set-variable-value-history     ; History of variables changed with set-variable
           custom-variable-history        ; History of custom variables
           query-replace-history          ; History of query replacements
           read-expression-history        ; History of lisp expressions
           minibuffer-history             ; History of the minibuffer
           read-char-history              ; History of the `read-char-from-minibuffer' function
           face-name-history              ; History of commands that read face names
           bookmark-history               ; History of bookmarks
           file-name-history))            ; History of file-names entered into the minibuffer

    (put 'minibuffer-history         'history-length 50)
    (put 'file-name-history          'history-length 50)
    (put 'set-variable-value-history 'history-length 25)
    (put 'custom-variable-history    'history-length 25)
    (put 'query-replace-history      'history-length 25)
    (put 'read-expression-history    'history-length 25)
    (put 'read-char-history          'history-length 25)
    (put 'face-name-history          'history-length 25)
    (put 'bookmark-history           'history-length 25)

   (setq history-delete-duplicates t)     ; No duplicates in history

   ;; II.5) Dirvish
   (use-package files
     :config
     (auto-save-visited-mode)
     (setq my-files-dir-alist
           '(((title . "  Research")       (path . "~/Documents/mathematics/research"))
             ((title . "  Literature")   (path . "~/Documents/mathematics/literature"))
             ;; ((title . "  Notes")        (path . "~/Documents/notes"))
             ((title . "  Photos")       (path . "~/Documents/Pictures"))
             ((title . "  Downloads")    (path . "~/Downloads"))))
     (setq confirm-kill-processes nil)
     (setq large-file-warning-threshold 50000000)
     (setq permanently-enabled-local-variables '(lexical-binding encoding))
     :preface
     (setq auto-save-default nil)
     (setq make-backup-files nil))

   ;; (defcustom my-files-dir-alist
   ;;   '(((title . "  Photos")       (path . "~/Pictures/"))
   ;;     ((title . "  Videos")       (path . "~/Video/"))
   ;;     ((title . "  Downloads")    (path . "~/Downloads/")))
   ;;   "Doc."
   ;;   :group 'my :type '(repeat list))

   ;; TODO SAVEPLACE
   (use-package saveplace
     :config
     (setq save-place-file (locate-user-emacs-file "saveplace"))
     (setq save-place-forget-unreadable-files t)
     (save-place-mode 1))

   (use-package autorevert
     :config
     (setq auto-revert-verbose t)
     (global-auto-revert-mode))

   (use-package dired
     ;; :bind
     ;; (nil
     ;;  :map dired-mode-map
     ;;  ("/" . dired-goto-file)
     ;;  ("." . dired-create-empty-file)
     ;;  ("+" . dired-create-directory)
     ;;  ("i" . wdired-change-to-wdired-mode)
     ;;  ("I" . dired-insert-subdir)
     ;;  ("K" . dired-kill-subdir)
     ;;  ("O" . dired-find-file-other-window)
     ;;  ("[" . dired-prev-dirline)
     ;;  ("]" . dired-next-dirline)
     ;;  ("o" . dired-up-directory)
     ;;  ("^" . mode-line-other-buffer)
     ;;  ("x" . dired-do-delete)
     ;;  ("X" . dired-do-flagged-delete)
     ;;  ("y" . dired-do-copy))
     :config
     ;; (setq dired-mouse-drag-files t) ; added in Emacs 29
     ;; (setq mouse-drag-and-drop-region-cross-program t) ; added in Emacs 29
     (setq dired-kill-when-opening-new-dired-buffer t) ; added in Emacs 28
     (setq dired-recursive-copies 'always)
     (setq dired-recursive-deletes 'always)
     (setq delete-by-moving-to-trash t)
     (setq dired-dwim-target t)
     (setq dired-listing-switches
           "-g --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group"))

   (use-package dired-x
     :after dired
     :init
     (setq dired-bind-info nil)
     (setq dired-bind-man nil)
     :config
     (setq dired-clean-confirm-killing-deleted-buffers nil)
     ;; (setq dired-omit-files
     ;;       (concat dired-omit-files "\\|^\\..*$"))
     )

   (use-package dired-aux
     :after dired
     :config
     (setq dired-do-revert-buffer t))

   (use-package dirvish
     :defer 0.5
     :hook (dirvish-setup . dirvish-emerge-mode)
     :bind
     (nil
      :map dirvish-mode-map
      ("SPC" . consult-buffer)
      ("M-n" . dirvish-history-go-forward)
      ("M-p" . dirvish-history-go-backward)
      ("h"   . dirvish-history-jump)
      ("^"   . dirvish-history-last)
      ("TAB" . dirvish-subtree-toggle)
      ("a"   . dirvish-quick-access)
      ("f"   . dirvish-file-info-menu)
      ("*"   . dirvish-mark-menu)
      ("N"   . dirvish-narrow)
      ("M-e" . dirvish-emerge-menu)
      ("M-f" . dirvish-layout-toggle)
      ("M-s" . dirvish-setup-menu)
      ("M-j" . dirvish-fd-jump)
      ([remap dired-sort-toggle-or-edit] . dirvish-quicksort)
      ([remap dired-do-redisplay] . dirvish-ls-switches-menu)
      ([remap dired-do-copy] . dirvish-yank-menu)
      :map mode-specific-map
      ("e" . dirvish-dwim))
     :config
     (dirvish-override-dired-mode)
     (dirvish-peek-mode)
     (dirvish-define-preview exa (file)
       "Use `exa' to generate directory preview."
       :require ("exa")
       (when (file-directory-p file)
         `(shell . ("exa" "--color=always" "-al" "--group-directories-first" ,file))))
     (add-to-list 'dirvish-preview-dispatchers 'exa)
     (setq dirvish-mode-line-format
            '(:left (sort file-time " " file-size symlink) :right (vc-info yank index)))
     (setq dirvish-header-line-format '(:left (path) :right (free-space)))
     (setq dirvish-quick-access-entries
            '(("o" "~/"                                "Home")
              ;;("d" "/opt/dotfiles/"                    "Dotfiles")
              ;;("u" "~/.cache/emacs/"                   "Emacs cache")
              ;;("p" "~/Code/"                           "Code")
              ;;("n" "~/Downloads/"                      "Downloads")
              ;;("w" "~/Pictures/wallpaper/"             "Wallpaper")
              ;;("m" "/mnt/"                             "Drives")
              ;;("a" "FD####~/Documents/####\\\\.org$"   "All org files in ~/Documents")
              ;;("t" "~/.local/share/Trash/files/" "Trash")))
     (setq dirvish-open-with-programs
            `((,dirvish-video-exts . ("tdrop" "-h" "25%" "-w" "25%" "-x" "1000" "-y" "1000" "mpv" "%f"))
              (,dirvish-audio-exts . ("tdrop" "-h" "25%" "-w" "25%" "-x" "1000" "-y" "1000" "mpv" "%f"))))
     (setq dirvish-attributes '(vc-state file-size git-msg subtree-state all-the-icons collapse))
     (setq dirvish-all-the-icons-height 0.8)
     (setq dirvish-side-attributes dirvish-attributes)
     (setq dirvish-side-preview-dispatchers (append '(vc-diff) dirvish-preview-dispatchers))
     (setq dirvish-side-display-alist '((side . left) (slot . -1) (window-width . 0.2)))
     (setq dirvish-side-header-line-format '(:left (project) :right (vc-info)))
     (setq dirvish-side-mode-line-format '(:left (sort omit) :right (index))))))

   ;;  II.6) Misc
   (setq create-lockfiles t) ; Create lockfiles to interact nicely with different editors operating on the same file.

   (defun unwords (&rest words)        ;;unwords seems to be missing this function takes care of it.
     (mapconcat #'identity words " ")) ;; it joins a list of strings with a blank space as seperator.

   ;;; III OWN LISP SETUP
   ;;  III.1) Setup
   (add-to-list 'load-path (concat user-emacs-directory "lisp/" ))                ; Path for custom packages
   (add-to-list 'custom-theme-load-path (concat user-emacs-directory "lisp/"))    ; Path for custom themes

   ;;; TEST OF OTHER SETUPS ;;;


   ;; HELPFUL SETUP
   (setq help-window-select t)             ; Focus new help windows when opened

   (bind-key "C-h f"   #'helpful-callable) ; Look up callable
   (bind-key "C-h v"   #'helpful-variable) ; Look up variable
   (bind-key "C-h k"   #'helpful-key)      ; Look up key
   (bind-key "C-c C-d" #'helpful-at-point) ; Look up the current symbol at point
   (bind-key "C-h F"   #'helpful-function) ; Look up *F*unctions (excludes macros).
   (bind-key "C-h C"   #'helpful-command)  ; Look up *C*ommands.

   (require 'flyspell)
   (require 'guess-language)
   (require 'flyspell-correct-popup)

   ;; ;; Automatically detect language for Flyspell
   (with-eval-after-load 'guess-language
     (add-hook 'text-mode-hook #'guess-language-mode)
     (setq guess-language-langcodes '((en . ("en_GB" "English"))
                                      (de . ("de_DE" "German")))
           guess-language-languages '(en de)
           guess-language-min-paragraph-length 45))

   (use-package emacs
     :init (column-number-mode)
     )

   (use-package fira-code-mode
     :custom (fira-code-mode-disabled-ligatures '("[]" "#{" "#(" "#_" "#_(" "x" "{-" "-}" )) ;; List of ligatures to turn off
     ;; :config (global-fira-code-mode)
   )

    ;; https://www.emacswiki.org/emacs/SavePlace
     (save-place-mode 1)

     (global-set-key (kbd "M-/") 'hippie-expand)
     (global-set-key (kbd "C-x C-b") 'ibuffer)
     (global-set-key (kbd "M-z") 'zap-up-to-char)

     (global-set-key (kbd "C-s") 'isearch-forward-regexp)
     (global-set-key (kbd "C-r") 'isearch-backward-regexp)
     (global-set-key (kbd "C-M-s") 'isearch-forward)
     (global-set-key (kbd "C-M-r") 'isearch-backward)

     (show-paren-mode 1)
     (setq-default indent-tabs-mode nil)
     (savehist-mode 1)
     (setq save-interprogram-paste-before-kill t
           apropos-do-all t
           mouse-yank-at-point t
           require-final-newline t
           visible-bell t
           load-prefer-newer t
           backup-by-copying t
           ediff-window-setup-function 'ediff-setup-windows-plain
           custom-file (expand-file-name "custom.el" user-emacs-directory))

     (unless backup-directory-alist
       (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                      "backups")))))



   ;; Language checking with flyspell
   (use-package flyspell-lazy
     :config
     (flyspell-lazy-mode 1)
     )

   ;; We don't want auto-fill mode; we don't need auto-fill mode
   (auto-fill-mode -1)
   (remove-hook 'text-mode-hook 'turn-on-auto-fill)
   (remove-hook 'LaTeX-mode-hook 'turn-on-auto-fill)

   (global-visual-line-mode 1); Proper line wrapping
   (global-hl-line-mode 1); Highlight current line
   (setq visible-bell t); Flashes on error
   (setq calendar-week-start-day 1); Calendar starts on Monday

   ;; Keybindings
   ;; Overwriten rules:
   (define-key key-translation-map (kbd "<AltGr>") (kbd "<menu>")) ;; To allow for menu modifier on laptops
   (bind-key (kbd "C-)") nil 'ergoemacs-override-keymap)
   (bind-key (kbd "M-<right>") nil 'ergoemacs-override-keymap)
   (bind-key (kbd "M-<left>") nil 'ergoemacs-override-keymap)
   (bind-key (kbd "M-T") nil 'ergoemacs-override-keymap)
   (global-set-key (kbd "M-T") 'flyspell-correct-wrapper)

   ;; Startup window

   (require 'all-the-icons)      ;; Better handeling of icons
   (require 'projectile)         ;; Projectile offers a 'project-based' logic
   ;; (require 'dashboard)          ;; Dashboard for the startup buffer

   ;; Where the projects are to be searched
   (setq projectile-project-search-path '(("~/Documents/mathematics/research/" . 3)))

   ;; Startup window config
   ;; (dashboard-setup-startup-hook)
   ;; (setq dashboard-center-content t)
   ;; (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
   ;; (setq dashboard-set-heading-icons t)
   ;; (setq dashboard-set-file-icons t)
   ;; (setq dashboard-week-agenda t)
   ;; (setq dashboard-filter-agenda-entry 'dashboard-no-filter-agenda)
   ;; (setq dashboard-items '((projects . 5)
   ;;                         (agenda . 5)
   ;;                         (recents  . 5)))


   ;; Paranthesis

   ;; Enable smart parentheses mode globally
   ;; (smartparens-global-mode 1)
   (show-paren-mode 1); Matches parentheses and such in every mode

   ;; Use rainbow-delimiters

   (use-package rainbow-delimiters
     :hook ((prog-mode text-mode LaTeX-mode) . rainbow-delimiters-mode))

   ;; (use-package rainbow-delimiters
   ;;  :init
   ;;   (add-hook 'emacs-lisp-mode-hook #'(lambda() (rainbow-delimiters-mode)))
   ;;   (add-hook 'LaTeX-mode-hook #'(lambda() (rainbow-delimiters-mode))))

   (use-package puni
     :hook ((text-mode prog-mode LaTeX-mode org-mode eval-expression-minibuffer-setup haskell-interactive-mode) . puni-mode)
     :bind (:map puni-mode-map
                 ("C-<right>" . puni-slurp-forward)
                 ("C-<left>"  . puni-barf-forward)
                 ("M-<left>"  . puni-slurp-backward)
                 ("M-<right>" . puni-barf-backward)
                 ("C-x C-d"   . puni-splice)
                 ("M-i"       . puni-squeeze)
                 ("C-<up>"    . puni-rewrap)))

   (defun puni-rewrap ()
     (interactive)
     (pcase-let* ((c (read-char "Replace with? "))
                  (`(,fst . ,lst) (pcase c
                                    (?\( '("(" . ")"))
                                    (?\) '("(" . ")"))
                                    (?\{ '("{" . "}"))
                                    (?\} '("{" . "}"))
                                    (?\[ '("[" . "]"))
                                    (?\] '("[" . "]"))
                                    (?\< '("<" . ">"))
                                    (?\> '("<" . ">"))
                                    (?\" '("\"" . "\"")))))
       (puni-squeeze)
       (insert fst)
       (yank)
       (insert lst)))

   ;; Org-Agenda

   (use-package org
     :pin gnu
     :commands (org-capture org-agenda)
     :config
     (setq org-ellipsis " ▾")

     (setq org-agenda-start-with-log-mode t)
     (setq org-log-done 'time)
     (setq org-log-into-drawer t)

     (setq org-agenda-files '("~/Documents/org-files/agenda"))

     (setq org-agenda-include-diary t) ;; allows you to integrate your calendar into the agenda
     (setq org-use-fast-todo-selection t)

     (setq org-todo-keywords
           '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)")
            (sequence "PENDING(p)" "DEFERRED(D)" "OCCURING (o)" "|" "COMPLETED(c)")
            (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
            (sequence "|" "CANCELED(C)")))



     (setq org-todo-keyword-faces
         '(("TODO" :foreground "tomato4" :weight bold)
           ("DONE" :foreground "PaleGreen4" :weight bold)
           ("REVIEW" :foreground "LightGoldenrod3" :weight bold)
           ("WAITING" :foreground "peru" :weight bold)
           ("INACTIVE" :foreground "coral" :weight bold)
           ("CANCELLED" :foreground "sienna" :weight bold)))

   ;;  Auto-update tags whenever the state is changed
   (setq org-todo-state-tags-triggers
         '(("CANCELLED" ("CANCELLED" . t))
      ("WAITING" ("SOMEDAY") ("INACTIVE") ("WAITING" . t))
      ("INACTIVE" ("WAITING") ("SOMEDAY") ("INACTIVE" . t))
      ("SOMEDAY" ("WAITING") ("INACTIVE") ("SOMEDAY" . t))
      (done ("WAITING") ("INACTIVE") ("SOMEDAY"))
      ("TODO" ("WAITING") ("CANCELLED") ("INACTIVE") ("SOMEDAY"))
           ("REVIEW" ("WAITING") ("CANCELLED") ("INACTIVE") ("SOMEDAY"))
      ("DONE" ("WAITING") ("CANCELLED") ("INACTIVE") ("SOMEDAY"))))

     (setq org-tag-alist
       '((:startgroup)
          ; Put mutually exclusive tags here
         (:endgroup)
         ("short"        . ?s)
         ("necessary"    . ?n)
         ("extension"    . ?e)
         ("idea"         . ?i)
         ("polish"       . ?p)
         ("internal"     . ?I)
         ("organisation" . ?o)
         ("meetings"     . ?m)
         ("feedback"     . ?f)
         ("regularly"    . ?r)
         ))

     (setq org-capture-templates
           `(
             ("t" "Tasks / Projects")
             ("tt" "Task" entry (file+olp "~/Documents/org-files/agenda" "Tasks")
              "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

         ("j" "Journal Entries")
         ("jj" "Journal" entry
              (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
              "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
              ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
              :clock-in :clock-resume
              :empty-lines 1)
         ("jm" "Meeting" entry
              (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
              "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
              :clock-in :clock-resume
              :empty-lines 1)

         ("w" "Workflows")
         ("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
              "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

         ("m" "Metrics Capture")
         ("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org" "Weight")
          "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

     (define-key global-map (kbd "C-c j")
       (lambda () (interactive) (org-capture nil "jj")))
   )

   (use-package org-bullets
     :ensure t
     :hook (org-mode . org-bullets-mode)
     :custom
     (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

   (require 'org-super-agenda)

   (setq org-agenda-skip-scheduled-if-done t
         org-agenda-skip-deadline-if-done t
         org-agenda-include-deadlines t
         org-agenda-block-separator #x2501
         org-agenda-compact-blocks t
         org-agenda-start-with-log-mode t)
   (setq org-agenda-deadline-faces
         '((1.0001 . org-warning)              ; due yesterday or before
           (0.0    . org-upcoming-deadline)))  ; due today or later



   (defun style-org-agenda()
     (set-face-attribute 'org-agenda-date nil :height 1.1)
     (set-face-attribute 'org-agenda-date-today nil :height 1.1 :weight 'bold)
     (set-face-attribute 'org-agenda-date-weekend nil :height 1.1))

   (add-hook 'org-agenda-mode-hook 'style-org-agenda)

   (setq org-agenda-breadcrumbs-separator " ❱ "
         org-agenda-current-time-string " ┈┈┈┈┈┈┈┈┈┈┈┈┈ now"
         org-agenda-time-grid '((weekly today require-timed)
                                (800 1000 1200 1400 1600 1800 2000)
                                "---" "┈┈┈┈┈┈┈┈┈┈┈┈┈")
         org-agenda-prefix-format '((agenda . "%i %-12:c%?-12t%b% s")
                                    (todo . " %i %-12:c")
                                    (tags . " %i %-12:c")
                                    (search . " %i %-12:c")))

   (setq org-agenda-format-date (lambda (date) (concat "\n" (make-string (window-width) 9472)
                                                       "\n"
                                                       (org-agenda-format-date-aligned date))))
   (setq org-cycle-separator-lines 2)




   (setq org-agenda-custom-commands
         '(("o" "Overview"
            ((agenda "" ((org-agenda-span 'day)
                         (org-super-agenda-groups
                          '((:name "Today"
                             :time-grid t
                             :date today
                             :todo "TODAY"
                             :scheduled today
                             :deadline today
                             :order 1)))))
             (alltodo "" ((org-agenda-overriding-header "")
                          (org-super-agenda-groups
                           '(;; Each group has an implicit boolean OR operator between its selectors.
                             (:name "Today"
                              :face (:weight "semi-bold"))
                             (:name "Behind deadline"
                              :and (:deadline past :todo ("TODO" "WAITING" "HOLD" "NEXT"))
                              :face (:background "#7f1b19"))
                             (:name "Work important"
                              :and (:priority>= "B" :category "Work" :todo ("TODO" "NEXT")))
                             (:name "Work other"
                              :and (:category "Work" :todo ("TODO" "NEXT")))
                             (:name "Important"
                              :priority "A")
                             (:priority<= "B"
                              ;; Show this section after "Today" and "Important", because
                              ;; their order is unspecified, defaulting to 0. Sections
                              ;; are displayed lowest-number-first.
                              :order 1)
                             (:name "Papers"
                              :file-path "org/roam/notes")
                             (:name "Waiting"
                              :todo "WAITING"
                              :order 9)
                             (:name "On hold"
                              :todo "HOLD"
                              :order 10)))))))))
   (add-hook 'org-agenda-mode-hook 'org-super-agenda-mode)

   ;; Mu4e conf

   ;; Latex-smart-keys

   ;;; Description:

   ;; The following code allows for two functionalities:

   ;; 1) cycle through environments.
   ;; 2) smartly interpret newline and space insertions

   (defconst default-math-env '("$" "$" t nil)
     "The default math environment.
      This defines the fall-back option for the math environment insertion."
     )

   (defconst custom-env-plist'(
       :ams-env: (("definition" nil nil "def")
                  ("lemma" nil nil "lem")
                  ("corollary" nil nil "cor")
                  ("theorem" nil nil "thm"))
       :math: (("$" "$" t nil)
               ("equation" nil nil "eq")
               ("align" nil nil "eq")
               ("gather" nil nil "eq")
               ("equation*" nil nil nil)
               ("align*" nil nil nil)
               ("gather*" nil nil nil)
               )
       :parens:  (("(" ")" t nil ))
       )
     "A plist with environment-type as key and a list of such environments as value.
      Every entry in such a list consists of 4 elements:
      i)  the name of the environment, e.g. `equation' or `$'.
      ii) the reprenstation of the ending delimitier of the environment.
          If the environment is bounded by `\begin{...}' and `\end{...}',
          its value is nil. Otherwise it could be for example`$'.
      iii)A boolean variable indicating wether the environment is an inline environment.
          That is t=`inline' and `nil' otherwise.
      iv) A representation of the label-tag used for this environment, e.g. `eq'.
          If the environment has no label, the value is nil."
     )

   ;; Global variables that allow us to
   (setq custom-env-starting-delimiters '())
   (setq custom-env-ending-delimiters '())
   (setq number-envs-of-type '())

   (setq env-at-point-name nil)
   (setq env-at-point-start nil)


   (defun generate-expanded-delimiters-lists()

     (dotimes (i (length custom-env-plist))
       (when(cl-oddp i)
         (progn
           (setq hierarchy (/ (- i 1) 2))
           (setq environments (nth i custom-env-plist))
           ;; Generate some statistics about the saved environments
           (add-to-list 'number-envs-of-type (nth (- i 1) custom-env-plist) t)
           (add-to-list 'number-envs-of-type (length environments) t)
           (dotimes (j (length environments))
             (progn
               (setq starting-del (nth 0 (nth j environments)))
               (setq ending-del (nth 1 (nth j environments)))
               (setq starting-del-exp (expand-delimiters starting-del ending-del -1))
               (setq ending-del-exp (expand-delimiters starting-del ending-del 1))
               (add-to-list 'custom-env-starting-delimiters starting-del t)
               (add-to-list 'custom-env-starting-delimiters (list starting-del-exp hierarchy) t)
               (add-to-list 'custom-env-ending-delimiters starting-del t)
               (add-to-list 'custom-env-ending-delimiters (list ending-del-exp hierarchy) t)
               )))))
     )

   (defun cycle-texmath()
     "This function cycles through the math environments defined in custom-env-plist"
     (interactive)
     (cycle-env :math:)
     )

   (defun cycle-env(type)
     (get-env-at-point type)
     (if env-number
         (if ending-pos
             (if (and (> (- ending-pos-wrapped-text starting-pos-wrapped-text) 0)
                         (looking-at-p (concat "[[:blank:]\n]*" (regexp-quote ending-del-expanded))))
                 (cdlatex-tab)
               (next-environment type))
           (progn
             (save-excursion (end-env (nth 0 current-env) (nth 1 current-env) inline))
             (LaTeX-indent-line))
         )
       (progn
           (apply 'build-env  (insert-after (insert-after default-math-env 0 starting-pos-wrapped-text) 1 ending-pos-wrapped-text)) ;; TODO make this non math specific
           ))
     )

   (defun next-environment (type)
     (setq next-env-number (mod (1+ env-number) (plist-get number-envs-of-type type)))
     (setq next-env (nth next-env-number (plist-get custom-env-plist type)))
     (setq label-begin (+ starting-pos (length starting-del-expanded)))

     (goto-char starting-pos)
     (delete-region starting-pos label-begin)
     (start-env (nth 0 next-env) (nth 1 next-env) (nth 2 next-env))

     (delete-region (point) (+ (point) (- starting-pos-wrapped-text label-begin)))
     (setq label-pos (generate-label (nth 3 next-env) label-text (nth 2 next-env)))
     ;; TODO globally update the label if it is changed

     (setq new-starting-pos (point))
     (setq wrap-offset (- new-starting-pos starting-pos-wrapped-text))
     (goto-char (+ ending-pos-wrapped-text wrap-offset))
     (delete-region (point) (+ ending-pos wrap-offset))
     (save-excursion (end-env (nth 0 next-env) (nth 1 next-env) (nth 2 next-env)))
     (LaTeX-indent-line)
     (if point-relative-to-start
         (goto-char (+ new-starting-pos point-relative-to-start))
       (goto-char new-starting-pos))
     )

   (defun get-env-at-point (type)
     " Produces all relevant-information about the current environment."

     (is-pt-in-env type)
     (setq current-env (get-env-by-name type env-at-point-name))
     (setq starting-del-expanded (nth 0 (plist-get custom-env-starting-delimiters (nth 0 current-env))))
     (setq ending-del-expanded (nth 0 (plist-get custom-env-ending-delimiters (nth 0 current-env))))
     (setq inline (nth 2 current-env))
     (setq label-tag (nth 3 current-env))
     (setq env-number (nth 4 current-env))
     (setq starting-pos env-at-point-start)

     (if starting-pos
         (save-excursion
           (setq ending-pos (environment-balanced current-env (1+ starting-pos)));; We do not want to start at the left boarder of the env as this might cause some problems
           (goto-char (+ starting-pos (length starting-del-expanded)))
           (skip-chars-forward "[:blank:]\n")
           (if (looking-at-p "\\\\label{")
               (progn
                 (skip-chars-forward "^:")
                 (skip-chars-forward "[:blank:]:")
                 (if (looking-at "[^}]+")
                     (progn
                       (setq label-text (match-string 0))
                       (goto-char (match-end 0)))
                   (progn
                     (setq label-text nil)
                     (forward-char)))
                 (skip-chars-forward "}[:blank:]\n")
                 )
             (setq label-text nil))
           (setq starting-pos-wrapped-text (point))
           )
       (progn
         (setq ending-pos nil)
         (setq label-text nil)
         (if (use-region-p)
             (setq starting-pos-wrapped-text (region-beginning))
           (setq starting-pos-wrapped-text nil))
         )
       )

     (if ending-pos
         (save-excursion
           (goto-char (- ending-pos (length ending-del-expanded)))
           (skip-chars-backward "[:blank:]\n")
           (setq ending-pos-wrapped-text (max (point) starting-pos-wrapped-text))
           )
       (progn
         (if (use-region-p)
             (setq ending-pos-wrapped-text (region-end))
           (setq ending-pos-wrapped-text nil))
         )
       )
     (if (and ending-pos-wrapped-text
              (< starting-pos-wrapped-text ending-pos-wrapped-text )
              (< (point) ending-pos-wrapped-text ) )
         (setq point-relative-to-start (- (point) starting-pos-wrapped-text))
       (setq point-relative-to-start nil))
     )

   (defun environment-balanced (current-env starting-pos &optional hierarchy)
     (when (and current-env starting-pos)
       (save-excursion
         (setq hierarchy (nth 1 (plist-get custom-env-starting-delimiters (car current-env))))
         (goto-char starting-pos)
         (setq ending-pos (re-search-forward (regexp-quote (nth 0 (plist-get custom-env-ending-delimiters (car current-env)))) nil  t))
         (if ending-pos
             (progn
               ;; TODO search between start and end if there is a starting delimiter of same or lower hierarchy
               ending-pos
               )
           nil)
         ))
     )

   (defun get-env-by-name (type starting-del)
     (when starting-del
       (setq environments (plist-get custom-env-plist type))
       (setq position 0)
       (setq return-env (car environments))
       (while (and (> (length environments) 0)(not (string= (car return-env) starting-del)))
         (setq environments (cdr environments))
         (setq position (1+ position))
         (setq return-env (car environments))
         )
       (when return-env (insert-after return-env 3 position)))
     )

   (defun build-env (starting-del &optional starting-pos-wrapped-text ending-pos-wrapped-text ending-del inline label-tag label-text)
     "This function build an environment with 'starting-del' and 'ending-del' delemiters,
      a possible label with a tag and a text and some text in the middle."

     (setq start (point))
     (setq distance 0)

     (when starting-pos-wrapped-text
       (setq start starting-pos-wrapped-text)
       (when ending-pos-wrapped-text
         (setq distance (- ending-pos-wrapped-text start)))
       )

     (goto-char start)
     (start-env starting-del ending-del inline)
     (setq pointer-pos (generate-label label-tag label-text inline))
     (forward-char distance)
     (save-excursion (end-env starting-del ending-del inline))

     (unless inline (LaTeX-indent-line))
     (when (and (= distance 0) pointer-pos)
       (goto-char pointer-pos))
     )

   (defun start-env (starting-del ending-del inline)
     (deactivate-mark)
     (unless (current-line-empty -1)
       (if inline (just-one-space) (TeX-newline)))
     (insert (expand-delimiters starting-del ending-del -1))
     )

   (defun generate-label (&optional label-tag label-text inline)
     (setq point-pos nil)
     (when label-tag
       (just-one-space)
       (insert (concat "\\label{" label-tag ":" label-text "}"))
       (unless label-text (setq point-pos (- (point) 1)))
       )
     (unless inline
       (save-excursion
         (forward-line)
         (setq next-line-empty (current-line-empty)))
         (unless next-line-empty (TeX-newline)))
     (or point-pos nil)
     )

   (defun end-env (starting-del ending-del inline)
     (deactivate-mark)
     (unless inline
       (if (current-line-empty)
           (progn
             (save-excursion
              (previous-line)
              (setq need-line-break (current-line-empty)))
             (unless need-line-break (TeX-newline)))
         (TeX-newline))
       )
     (insert (expand-delimiters starting-del ending-del 1))
     (LaTeX-indent-line)
     (unless (current-line-empty 1)
       (if inline (just-one-space) (TeX-newline)))
     )

   (defun current-line-empty (&optional direction)
     "This function checks wether the current line is empty.
      The optional variable 'direction' takes values +1 and -1.
      In the first case only the line from the point onward is considered.
      If 'direction' is -1, the line up until the point is checked:
      ,*'direction =-1' "
     (if direction
         (if (eq direction -1)
             (looking-back "^[[:blank:]]*" ) (looking-at-p "[[:blank:]]*$"))
       (progn
         (save-excursion
       (beginning-of-line)
       (looking-at-p "[[:blank:]]*$")))))

   (defun insert-after (input-list index val)
     "This function produces a copy of the input list with the given value `val' at the position `index'."
     (setq output-list (copy-sequence input-list))
     (push val (cdr (nthcdr index output-list)))
     output-list)

   (defun expand-delimiters (starting-del ending-del se-flag)
     "This function produces an output string of the environment determined by the starting and ending-delimiters.
   The staring delimiter is produced if se-flag= -1, if se-flag = 1 the function returns the ending delimiter."
     (if (eq se-flag -1)
         (if ending-del (progn starting-del)(progn (concat "\\begin{" starting-del "}")))
       (if ending-del (progn ending-del)(progn (concat "\\end{" starting-del "}")))
       )
     )

   (defun is-pt-in-env (type)
     (cond
      ((eq type :math:)
       (if (texmathp)
           (progn
             (setq env-at-point-name (car texmathp-why))
             (setq env-at-point-start (cdr texmathp-why)))
         (progn
           (setq env-at-point-name nil)
           (setq env-at-point-start nil))))
      )
     )

   (defun smart-enter ()
     (interactive)
     (if (texmathp)
         (progn
           (if (current-line-empty)
               (progn
                 (insert "\\\\")
                 )
             )
           (progn
             (TeX-newline))
           )
       ;; (if = LaTeX-current-environment =
       ;; )
       (progn
         (TeX-newline)
         ))
     )

   ;; (add-hook 'cdlatex-mode-hook  #'(lambda() (bind-key (kbd "$") nil 'cdlatex-mode-map)))

   (use-package cdlatex
     :config
     (bind-key (kbd "$") nil 'cdlatex-mode-map)
     )
   (eval-after-load 'latex
     '(bind-key (kbd "$") #'cycle-texmath 'LaTeX-mode-map))
   (eval-after-load 'latex
     '(bind-key (kbd "RET") #'smart-enter 'LaTeX-mode-map))

   ;; (bind-key (kbd "$") #'cycle-texmath 'LaTeX-mode-map)
   ;; (bind-key (kbd "RET") #'smart-enter 'LaTeX-mode-map)

   (generate-expanded-delimiters-lists)

   ;; Latex expansions

   (defun latex-regexp-prettify ()
     (highlight-regexp "{" 'custom-comment)
     (highlight-regexp "}" 'custom-comment)
     (highlight-regexp "[[:space:]]*\\\\quad[[:space:]]+" 'custom-comment)
     (highlight-regexp "[[:space:]]*\\\\qquad[[:space:]]+" 'custom-comment)
     (highlight-regexp "[[:space:]]*\\\\,[[:space:]]+" 'custom-comment)
     (highlight-regexp "[[:space:]]*\\\\;[[:space:]]+" 'custom-comment)
     (highlight-regexp "[[:space:]]*\\\\enspace[[:space:]]+" 'custom-comment)
     (highlight-regexp "[[:space:]]*\\\\emspace[[:space:]]+" 'custom-comment)
   )

   (defun latex-symbols-prettify ()
     (mapc (lambda (pair) (add-to-list 'prettify-symbols-alist pair))
           ;; ARROWS
           '(("\\to"                  32 (Br . Bl) 32 (Br . Br) 57620)
             ("\\rightarrow"          32 (Br . Bl) 32 (Br . Br) 57620)
             ("\\mapsto"              8870 (cr  cl 16 0) 57620)
             ("\\longmapsto"          32 (Br . Bl)  8866 (cr . cl) 32 (Br . Bl)  32 (Br . Br)  57619)
             ("\\inj"                 5308 (tl  tl 20 0) 32 (tr  tl 0 -5) 57620)
             ("\\emb"                 5308 (tl  tl 20 0) 32 (tr  tl 0 5) 57620)
             ("\\hookrightarrow"      5354 (tl . tl) 32 (tr . tl) 57620)
             ("\\surj"                32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57621)
             ("\\proj"                32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57621)
             ("\\twoheadrightarrow"   32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57621)
             ("\\twoheadleftarrow"    32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57693)
             ("\\longrightarrow"      32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57619)
             ("\\rightsquigarrow"     32 (Br . Bl) 32 (Br . Br) 57703)
             ("\\leftarrow"           32 (Br . Bl) 32 (Br . Br) 57682)
             ("\\longleftarrow"       32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57683)
             ("\\leftrightarrow"      32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57684)
             ("\\leftsquigarrow"      32 (Br . Bl) 32 (Br . Br) 57696)
             ("\\Rightarrow"          32 (Br . Bl) 32 (Br . Br) 57663)
             ("\\Longrightarrow"      32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57662)
             ("\\implies"             32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57662)
             ("\\Leftarrow"           32 (Br . Bl) 32 (Br . Br) 57688)
             ("\\Longleftarrow"       32 (Br . Bl) 32 (Br . Br) 57688)
             ("\\impliedby"           32 (Br . Bl) 32 (Br . Br) 57688)
             ("\\Leftrightarrow"      32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57689)
             ("\\upharpoonleft"       ?↿)
             ("\\upharpoonright"      ?↾)
             ("\\downharpoonleft"     ?⇃)
             ("\\downharpoonright"    ?⇂)
             ("\\hookleftarrow"       ?↩)
             ("\\looparrowleft"       ?↫)
             ("\\looparrowright"      ?↬)
             ("\\leftrightsquigarrow" ?↭)
             ("\\leftleftarrows"      ?⇇)
             ("\\rightrightarrows"    ?⇉)
             ("\\leftrightarrows"     ?⇆)
             ("\\rightleftarrows"     ?⇄)
             ("\\Lleftarrow"         ?⇚)
             ("\\Rrightarrow"        ?⇛)
             ;; ENVIRONMENTS
             ("\\part"                ?#)
             ("\\section"             32 (Br . Bl) 32 (Br . Br) 57627)
             ("\\subsection"          32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57628)
             ("\\subsubsection"       32 (Br . Bl) 32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57629)
             ("\\begin"               32 (Br . Bl) 32 (Br . Br) 57653)
             ("\\end"                 32 (Br . Bl) 32 (Br . Br) 57677)
             ("\\item"                32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57686)
             ;; SPACING
             ("\\,"                  8194 (Bc . Bc) 8231)
             ("\\:"                  8194 (Bc . Bc) 8231)
             ("\\;"                  8194 (Bc . Bc) 8231)
             ("\\enspace"            8194 (Bc . Bc) 8231)
             ("\\emspace"            8195 (Bc . Bc) 8231)
             ("\\quad"               8231 (Bc . Bc) 8195 (Br . Bl) 8231 (Bc . Bc) 8195)
             ("\\qquad"              8231 (Bc . Bc) 8195 (Br . Bl) 8231 (Bc . Bc) 8195 (Br . Bl) 8231 (Bc . Bc) 8195 (Br . Bl) 8231 (Bc . Bc) 8195)
             ;; SETS
             ("\\mathbb{N}"           ?\u2115)
             ("\\mathbb{R}"           ?\u211D)
             ("\\mathbb{C}"           8450)
             ("\\mathbb{P}"           8473)
             ("\\mathcal{C}"          120018)
             ("\\cat{C}"              120018)
             ("\\mathcal{D}"          120019)
             ("\\cat{D}"              120019)
             ("\\cat{E}"              120020)
             ("\\cat{M}"              120028)
             ("\\cat{N}"              120029)
             ("\\mathfrak{C}"         120174)
             ("\\mathfrak{D}"         120175)
             ("\\ZCat"                120041)
             ;; OPERATORS
             ("\\defeq"               32 (Br . Bl) 32 (Br . Br) 57612)
             ("\\eq"                  ?=)
             ("\\neq"                 32 (Br . Bl) 32 (Br . Br) 57614)
             ("\\blank"               8212)
             ("\\from"                32 (Br . Br) 57708)
             ("\\colon"               32 (Br . Br) 57708)
             ("\\lact"                9655)
             ("\\blact"               9654)
             ("\\ract"                9665)
             ("\\bract"               9664)
             ("\\unlhd"               ?⊴)
             ("\\unrhd"               ?⊵)
             ("\\cdot "               8226)
             (" \\cdot "              8226)
             ("\\times "              215)
             (" \\times "             215)
             ("\\parallel"            ?∥)
             ("\\notni"               8260 (cc . cc) ?∋)
             ("\\sqcup"               ?⊔)
             ("\\bigsqcup"            ?⊔)
             ("\\sqcap"               ?⊓)
             ("\\bigsqcap"            ?⊓)
             ("\\biguplus"            ?⨄)
             ("\\land"                ?∧)
             ("\\lor"                 ?∨)
             ("\\odot"                ?⊙)
             ("\\bigodot"             ?⊙)
             ("\\otimes"              ?⊗)
             ("\\bigotimes"           ?⊗)
             ("\\oplus"               ?⊕)
             ("\\bigoplus"            ?⊕)
             ("\\sqrt"                ?√)
             ("\\iint"                ?∬)
             ("\\iiint"               ?∭)
             ("\\iiiint"              ?⨌)
             ("\\oiint"               ?∯)
             ("\\oiiint"              ?∰)
             ("\\ointclockwise"       ?∲)
             ("\\ointctrclockwise"    ?∳)
             ;; BETTER SUB AND SUPERSCRIPTS
             ("^0"                    8304)
             ("^1"                    185)
             ("^2"                    178)
             ("^3"                    179)
             ("^4"                    8308)
             ("^5"                    8309)
             ("^6"                    8310)
             ("^7"                    8311)
             ("^8"                    8312)
             ("^9"                    8313)
             ("^l"                    ?\u02E1)
             ("^r"                    ?\u02B3)
             ("^T"                    ?\u1d40)
             ("_0"                    8320)
             ("_1"                    8321)
             ("_2"                    8322)
             ("_3"                    8323)
             ("_4"                    8324)
             ("_5"                    8325)
             ("_6"                    8326)
             ("_7"                    8327)
             ("_8"                    8328)
             ("_9"                    8329)
             ;; GREEK UPPER CASES
             ("\\Alpha"               ?Α)
             ("\\Beta"                ?Β)
             ("\\Gamma"               ?Γ)
             ("\\Delta"               ?Δ)
             ("\\Epsilon"             ?Ε)
             ("\\Zeta"                ?Ζ)
             ("\\Eta"                 ?Η)
             ("\\Theta"               ?Θ)
             ("\\Iota"                ?Ι)
             ("\\Kappa"               ?Κ)
             ("\\Lambda"              ?Λ)
             ("\\Mu"                  ?Μ)
             ("\\Nu"                  ?Ν)
             ("\\Xi"                  ?Ξ)
             ("\\Omicron"             ?Ο)
             ("\\Pi"                  ?Π)
             ("\\Rho"                 ?Ρ)
             ("\\Sigma"               ?Σ)
             ("\\Tau"                 ?Τ)
             ("\\Upsilon"             ?Υ)
             ("\\Phi"                 ?Φ)
             ("\\Chi"                 ?Χ)
             ("\\Psi"                 ?Ψ)
             ("\\Omega"               ?Ω)
             ;; SPECIAL SYMBOLS
             ("\\ss"                  ?ß)
             ("\\aa"                  ?å)
             ("\\AA"                  ?Å)
             ("\\ae"                  ?æ)
             ("\\oe"                  ?œ)
             ("\\AE"                  ?Æ)
             ("\\OE"                  ?Œ)
             ("\\o"                   ?ø)
             ("\\O"                   ?Ø)
             ("\\l"                   ?ł)
             ("\\L"                   ?Ł)
             ("\\S"                   ?§)
             ;; ESCAPED SYMBOLS
             ("\\$"                   ?＄)
             ("\\%"                   ?％)
             ("\\#"                   ?＃)
             ("\\_"                   ?＿)
             ("\\&"                   ?& (Bc . Bc) ?|)
             ;;REFERECING
             ("\\ref"                 ?☞)
             ("\\cite"                ?†)
             ("\\footnote"            ?‡)
             ("\\label"               43 (cc . cc) ?‡)
             ("\\TeX"                 ?T (cr cl -20 -45) ?E (cr cl -20 24) ?X)
             ("\\LaTeX"               ?L (cr cl -60 35) ?A (cr cl -18 -20) ?T (cr cl -18 -60) ?E (cr cl -20 5) ?X)
             ;; PARENTHESES
             ("{"                     ?⎨)
             ("}"                     ?⎬)
             ("\\{"                   ?{)
             ("\\}"                   ?})
             ("\\lbrace"              ?{)
             ("\\rbrace"              ?})
             ("\\{"                   ?{)
             ("\\}"                   ?})
             ("\\|" .                 ?║)
             ;; Misc
             ("\\dots"                ?…)
             ("\\textbackslash"       ?＼)
             ("\\backslash"           ?＼)
             ("\\qed"                 ?□)
             ("\\lightning"           ?Ϟ)
             ("\\copyright"           ?©)
             ("\\texistregistered"    ?®)
             ("\\texttrademark"       ?™)
             ("\\euro"                8364)
             ("\\pounds"              ?£)
             ("\\lvert"               ?|)
             ("\\rvert"               ?|)
             ("\\lVert"               ?ǁ)
             ("\\rVert"               ?ǁ)
             )))



   ;; This is like the best thing ever.  It defines all kinds of
   ;; abbreviations, key shortcuts etc.
   (use-package cdlatex
     :bind (:map cdlatex-mode-map ("$" . nil))
     :hook
     (LaTeX-mode . turn-on-cdlatex    ) ; with AUCTeX LaTeX mode
     (org-mode   . turn-on-org-cdlatex) ; Use subset of cdlatex for org mode
     :custom
     ;; Pair (almost) all the things.
     (cdlatex-paired-parens "$([{")
     ;; Custom bindings for the math modify list, accessed with '
     (cdlatex-math-modify-alist
      '(;;  MATHCMD      TEXTCMD    ARG RMDOT IT
        (?b "\\mathbb"   "\\textbf" t   nil   nil)
        (?f "\\mathbf"   "\\textsf" t   nil   nil)
        (?l "\\ld"       "\\textsl" t   nil   nil)
        (?k "\\mathfrak" nil        t   nil   nil)
        (?t "\\text"     nil        t   nil   nil)
        (?u "\\lld"      ""         t   nil   nil)
        ))
     ;; Custom bindings for the symbol list, accessed with `.  You may add
     ;; additional layers here.  Also, some of these are user-defined
     ;; commands.
     (cdlatex-math-symbol-alist
      '(;;    LAYER 1        LAYER 2      LAYER 3
        (?c  ("\\circ"       ""           "\\cos"   ))
        (?C  ("\\coprod"     ""           "\\arccos"))
        (?e  ("\\varepsilon" "\\epsilon"  "\\exp"   ))
        (?f  ("\\varphi"     "\\phi"      ""        ))
        (?F  ("\\Phi"        ""           ""        ))
        (?R  ("\\real"       "\\Re"       ""        ))
        (?N  ("\\nat"        "\\nabla"    "\\exp"   ))
        (?Z  ("\\integer"    ""           ""        ))
        (?Q  ("\\rat"        "\\Theta"    ""        ))
        (?0  ("\\varnothing" ""           ""        ))
        (?{  ("\\subseteq"   "\\subset"   ""        ))
        (?}  ("\\supseteq"   "\\supset"   ""        ))
        (?.  ("\\cdot"       "\\dots"     ""        ))
        (?^  ("\\otimes"     ""           ""        ))
        (?ö  ("\\odot"       ""           ""        ))
        )))


   (require 'dash)

   ;;; `aas': sane auto-expanding snippets
   (use-package aas
     :hook ((LaTeX-mode org-mode) . aas-activate-for-major-mode)
     :config
     (--each '(latex-mode org-mode)
       (aas-set-snippets it
         :cond #'texmathp
         ":"      "\\from "
         "**"     "\\star"
         "mm"     "\\mid "
         "->"     "\\to "
         "mt"     "\\mapsto "
         "=>"     "\\implies "
         "..."    "\\dots"
         "bln"    "\\blank"
         "def"    "\\defeq"
         "~"      "\\sim"
         "=="     "\\cong"
         "ot"     "\otimes"
         "bz"     "\\mathbb{Z}"
         "bq"     "\\mathbb{Q}"
         "br"     "\\mathbb{R}"
         "bc"     "\\mathbb{C}"
         "bf"     "\\mathbb{F}"
         "bp"     "\\mathbb{P}"
         "fg"     "\\mathfrak{g}"
         "fh"     "\\mathfrak{h}"
         "cc"     "\\cat{C}"
         "cd"     "\\cat{D}"
         "cm"     "\\cat{M}"
         "zc"     "\\ZCat{C}"
         "subset" "\\subset"
         "supset" "\\supset"
         "<>"    (lambda () (interactive)
                   (yas-expand-snippet "\\langle $0 \\rangle"))
         "adj"   (lambda () (interactive)
                   (yas-expand-snippet "\\adj{${1:F}}{${2:U}}{${3:\\cc}}{${4:\\mm}} $0"))
         "hom"  (lambda () (interactive)
                  (yas-expand-snippet "${1:\\cc}(${2:s}, ${3:t})"))
         "coend" (lambda () (interactive)
                   (yas-expand-snippet "\\int^{${2:C \\in \\cc}}"))
         "end"   (lambda () (interactive)
                   (yas-expand-snippet "\\int_{${2:C \\in \\cc}}"))
         "set"   (lambda () (interactive)
                   (yas-expand-snippet "\\\\{$0"))
         "sum"   (lambda () (interactive)
                   (yas-expand-snippet "\\sum_{${1:i=1}}^{${2:n}}$0"))
         ;;"gl"    (lambda () (interactive)
         ;;          (yas-expand-snippet "\\mathfrak{gl}_{${1:n}}$0"))
         ;;"//"    (lambda () (interactive)
         ;;          (yas-expand-snippet "\\frac{$1}{$2}$0"))
         "cat"   (lambda () (interactive)
                   (yas-expand-snippet "\\cat{$1}$0")))))

   ;; LaTeX- customisation

   (require 'auctex-latexmk)     ;; LatexMk integration into auctex
   (require 'cdlatex)            ;; Makes (La)TeX editing much better
   (require 'adaptive-wrap)      ;; Wrapping without introducing linebreaks.
   (require 'laas)               ;; LaTeX snipets
   (require 'tex-site)
   (require 'latex)
   (require 'reftex)             ;; sane referencing tool


   ;; LaTeX settings
   (setq TeX-auto-save t
         TeX-parse-self t
         TeX-PDF-mode t
         TeX-source-correlate-mode t
         TeX-source-correlate-start-server nil
         font-latex-fontify-sectioning 1.0)

   (setq-default TeX-master nil)

   ;; Auctex settings
   (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
   (add-to-list 'TeX-command-list '("LatexMk" "latexmk %(-PDF)%S%(mode) -pv -view=pdf  -interaction=nonstopmode -synctex=1 %(file-line-error) %(extraopts) %t"
            TeX-run-latexmk nil
            (plain-tex-mode latex-mode doctex-mode) :help "Run LatexMk"))

   (add-hook 'TeX-after-compilation-finished-functions
              #'TeX-revert-document-buffer)

   ;; for single quotation marks

   (setq TeX-open-quote "`")
   (setq TeX-close-quote "'")

   (auctex-latexmk-setup)
   (setq reftex-plug-into-AUCTeX t)

   (add-hook 'LaTeX-mode-hook
     #'(lambda()
       (setq ispell-dictionary "british")
       (yas-minor-mode 1)
       (laas-mode 1)
       (cdlatex-mode 1)
       (reftex-mode 1)
       (reftex-set-cite-format "\\cite[][]{%l}")
       (setq reftex-ref-macro-prompt nil
             reftex-label-alist                  ; tell reftex about some environments
             '(("section"     ?s "sec:"  "~\\ref{%s}" t (regexp "[Ss]ection\\(s\\)?"       ))
               ("definition"  ?d "def:"  "~\\ref{%s}" t (regexp "[Dd]efinition\\(s\\)?"    ))
               ("example"     ?x "ex:"   "~\\ref{%s}" t (regexp "[Ee]xample\\(s\\)?"       ))
               ("lemma"       ?l "lem:"  "~\\ref{%s}" t (regexp "[Ll]emma\\(s\\|ta\\)?"    ))
               ("proposition" ?p "prop:" "~\\ref{%s}" t (regexp "[Pp]roposition\\(s\\)?"   ))
               ("theorem"     ?h "thm:"  "~\\ref{%s}" t (regexp "[Tt]heorem\\(s\\)?"       ))
               ("remark"      ?r "rem:"  "~\\ref{%s}" t (regexp "[Rr]emark\\(s\\)?"        ))
               ("corollary"   ?c "cor:"  "~\\ref{%s}" t (regexp "[Cc]orollar\\(y\\|ies\\)?"))))
       (flyspell-mode 1)
       (auto-fill-mode -1)
       (latex-symbols-prettify)
       (latex-regexp-prettify)
       (TeX-fold-mode)
       (TeX-fold-region-comment (point-min) (point-max))
       (setq-local TeX-fold-env-spec-list-internal
                   '(("≪commutative diagram≫" ("tikzcd"))))
       (TeX-fold-region-macro-or-env (point-min) (point-max) 'env)
       ))

   (eval-after-load 'latex
     '(define-key LaTeX-mode-map (kbd "<f5>") 'latex-compile))

   (setq cdlatex-tab-hook '(yas-expand
                            pabbrev-expand))


   (add-hook 'cdlatex-mode-hook
       #'(lambda()
       (bind-key (kbd "$") nil 'cdlatex-mode-map)
       ))

   (defun latex-compile ()
     (interactive)
     (save-buffer)
     (TeX-command "LatexMk" 'TeX-master-file)
    )


   ;; Modern org mode

   ;; Minimal UI
   (menu-bar-mode -1)
   (tool-bar-mode -1)
   (scroll-bar-mode -1)

   (setq
    ;; Edit settings
    ;; org-auto-align-tags nil
    org-tags-column 0
    org-catch-invisible-edits 'show-and-error
    org-special-ctrl-a/e t
    org-insert-heading-respect-content t

    ;; Org styling, hide markup etc.
    org-hide-emphasis-markers t
    org-pretty-entities t
    org-ellipsis "…"

    ;; Agenda styling
    org-agenda-tags-column 0
    org-agenda-block-separator ?─
    org-agenda-time-grid
    '((daily today require-timed)
      (800 1000 1200 1400 1600 1800 2000)
      " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
    org-agenda-current-time-string
    "⭠ now ─────────────────────")

   (global-org-modern-mode)


   (use-package org-recur
    :hook ((org-mode . org-recur-mode)
           (org-agenda-mode . org-recur-agenda-mode))
    :demand t
    :config
    (define-key org-recur-mode-map (kbd "C-c d") 'org-recur-finish)

    ;; Rebind the 'd' key in org-agenda (default: `org-agenda-day-view').
    (define-key org-recur-agenda-mode-map (kbd "d") 'org-recur-finish)
    (define-key org-recur-agenda-mode-map (kbd "C-c d") 'org-recur-finish)

    (setq org-recur-finish-done t
          org-recur-finish-archive t))

  ;; Refresh org-agenda after rescheduling a task.
  (defun org-agenda-refresh ()
    "Refresh all `org-agenda' buffers."
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (derived-mode-p 'org-agenda-mode)
          (org-agenda-maybe-redo)))))

  (defadvice org-schedule (after refresh-agenda activate)
    "Refresh org-agenda."
    (org-agenda-refresh))

  ;; Log time a task was set to Done.
 (setq org-log-done (quote time))

 ;; Don't log the time a task was rescheduled or redeadlined.
 (setq org-log-redeadline nil)
 (setq org-log-reschedule nil)

 (setq org-read-date-prefer-future 'time)

#+end_src
