#+TITLE: Emacs literate configuration
#+AUTHOR: Sebastian Halbig
#+DATE: 04/2022
#+STARTUP: show2levels indent hidestars
#+PROPERTY: header-args :tangle (let ((org-use-tag-inheritance t)) (if (member "INACTIVE" (org-get-tags))  "no" "~/.emacs.d/init.el")))

* Documentation
** Forewords

This document is a literate configuration for GNU Emacs written in [[https://orgmode.org/][org]] format. It is an adaptation of Nicolas P. Rougier's brilliant work. It cannot be used directly and needs to be transformed to extract all the different code blocks into a single configuration file. This is done using the [[help:org-babel-tangle][org-babel-Utangle]] function that "extract the bodies of all source code blocks from the current file into their own source-specific files". You can try by yourself by typing the sequence: =C-c C-v t= (org-babel-execute-subtree).

However, on my Emacs (28.1), there seems to be a bug that prevent a proper tangling. You'll thus need to go to the [[Configuration]] section and execute it using =C-c C-v s= to fix this bug before tangling the file.

Each subsection may be tagged with:

- =:BINDING:=  The section defines some key binding
- =:HOOK:=     The section installs some hook
- =:ADVICE:=   The section installs some advice
- =:FACE:=     The section modifies some face
- =:MODE:=     The section activates a mode
- =:DEFER:=    The content of the section is deferred (lazy load)
- =:PERSONAL:= The content is personal and should be adapted
- =:INACTIVE:= The content of the section won't be exported
- =:BUGFIX:=   The section contains (temporary) bug fix code
- =:OTHER:=    The section will be exported to a different file than default
- =:TIMER:=    The section installs a timer
- =:OS:=       The section contains some system specific code

There is also a configuration mode defined in the section below to ease the writing.

When tangled, the process will create the files[[file:~/.emacs.d/init.el][~/.emacs.d/init.el]] and [[file:~/.emacs.d/early-init.el][~/.emacs.d/early-init.el]] (from the [[Early init]] section).

Note also that the first time you will start emacs using this configuration, *it will take a long time* because a lof of packages will be dowloaded, installed and possibly compiled (if you use Emacs 28 and above).

** To sort :INACTIVE:

#+begin_src emacs-lisp

(setq-default
 ad-redefinition-action 'accept         ; Silence warnings for redefinition
 custom-unlispify-menu-entries nil      ; Prefer kebab-case for titles
 custom-unlispify-tag-names nil         ; Prefer kebab-case for symbols
 (put 'downcase-region 'disabled nil)    ; Enable downcase-region
 (put 'upcase-region 'disabled nil)      ; Enable upcase-region
 native-comp-async-report-warnings-errors nil ; Skip compilation error buffers
 read-process-output-max (* 1024 1024)  ; Increase read size per process

#+end_src

** To do [5/12] :INACTIVE:

- [X] Tangle file when saving (org-auto-tangle)
- [X] Hitting `space` on top node should open the node (instead of folding)
- [X] Dim inactive entries in the sidebar
- [X] Shift-tab to toggle sidebar (all entries)
- [X] Filter sidebar (`f` key)
- [ ] Integrate  LaTeX settings into this config
- [ ] Configure the mail settings
- [ ] Build a usefull startup screen
- [ ] Work on the agenda settings
- [ ] Work on org-roam settings
- [ ] Setup dirvish
- [ ] Fix keybindings
- [ ] use use-package consequently


* Core

** Header

This will generate a header at the top of the tangled file to indicate it is generated and is not meant to be modified directly.

#+begin_src emacs-lisp :epilogue (format-time-string ";; Last generated on %c")

;; -*- lexical-binding: t -*-
;; This file has been generated from dotemacs.org file. DO NOT EDIT.
;; Based on from https://github.com/rougier/dotemacs

;; Copyright (C) 2022 Nicolas P. Rougier

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; For a full copy of the GNU General Public License
;; see <https://www.gnu.org/licenses/>.

#+end_src

#+begin_src emacs-lisp

(defvar my-init-start-time (current-time) "Time when init.el was started")
(defvar my-section-start-time (current-time) "Time when section was started")
(defun my-report-time (section)
  (message "%-36s %.2fs"
           (concat section " " "section time: ")
           (float-time (time-subtract (current-time) my-section-start-time))))
(message "---------------------------------------------------------------")

#+end_src

** Packages management :PERSONAL:

Using [[https://github.com/raxod502/straight.el][straight.el]] for package management and disable checking (for speedup).

#+begin_src emacs-lisp

(setq straight-check-for-modifications nil)

#+end_src

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+end_src

Library and theme load paths with a special case for mu4e (you may need to adapt this path).

#+begin_src emacs-lisp

(add-to-list 'load-path
             (expand-file-name "lisp" user-emacs-directory))
(add-to-list 'custom-theme-load-path
             (expand-file-name "theme" user-emacs-directory))
(add-to-list 'load-path
             "/usr/share/emacs/site-lisp/mu4e/mu4e.el")

#+end_src

Load uses the newest version possible.

#+begin_src emacs-lisp

(setq load-prefer-newer t) ; always choose the newest version of a package

#+end_src

** Packages installation :CLEANUP:

Packages used in this specific configuration. You may want to adapt this list. The first time this sequence will be executed, *it will take a long time*. Then, at next restart, it should be very fast (less than 1 second because it won't install anything basically).

#+begin_src emacs-lisp

(setq package-list
      '(all-the-icons       ; ICONS
        projectile          ; TODO
        dash                ; Better list handling
        adaptive-wrap       ; A version of adaptive-line-wrap that does not alter the text.
        visual-fill-column  ; Visual line wrapping according to fill-column.
        dirvish             ; A modern file manager
        anzu                ; Show number of matches in modeline
        swiper              ; Better search with swiper
        lsp-mode            ; Implementation of language server protocol
        lsp-ui              ; TODO
        rainbow-mode        ; TODO
        dictcc              ; Online DE/EN dictionary interface
        flyspell-lazy       ; Lazy flyspell-completion
        puni                ; Parenthesis handeling
        rainbow-delimiters  ; Make parentheses sexy
        cdlatex             ; LaTeX features
        laas                ; LaTeX autocompleting snippes
        latex-extra         ; Addons for LaTeX-mode
        ergoemacs-mode      ; "Modern" key-bindings
        fira-code-mode      ; Fira code ligatures
        oauth               ; Oauth library
        offlineimap         ; OfflineIMAP from Emacs
        no-littering        ;
        org-msg             ; Write mails with org mode.
        org-modern          ; Nicer org mode
        org-super-agenda    ; TODO ???
        org-recur           ; For recurring tasks
        selectrum           ; TODO REMOVE?
        selectrum-prescient ; TODO REMOVE?
        wgrep               ; TODO REMOVE?
        undo-tree           ; Undo history presented in a tree
        cape                ; Completion At Point Extensions
        orderless           ; Completion style for matching regexps in any order
        ;; vertico          ; VERTical Interactive COmpletion
                            ; We use a customised version. Thus it is commented out here.
        marginalia          ; Enrich existing commands with completion annotations
        embark
        consult             ; Consulting completing-read
        embark-consult      ; Consult integration into embark
        ;; corfu            ; Completion Overlay Region FUnction.
                            ; We use a special build. Thus its commented out.
          company           ; We can integrate company backends into corfu...
          company-auctex
          company-reftex
        all-the-icons-completion  ; All the icons for marginalia
        ;;deft                ; Quickly browse, filter, and edit plain text notes
        ;;elpher              ; A friendly gopher and gemini client
        smudge              ; Spotify for emacs
        elpy                ; Python in Emacs
        elfeed              ; Emacs Atom/RSS feed reader
        elfeed-org          ; Configure elfeed with one or more org-mode files
        elfeed-dashboard    ; Elfeed with a mu4e feeling
        ;;f                   ; Modern API for working with files and directories
        citar               ; Citation-related commands for org, latex, markdown
        ;;citeproc            ; A CSL 1.0.2 Citation Processor
        flyspell-correct-popup ; Correcting words with flyspell via popup interface
        flyspell-popup      ; Correcting words with Flyspell in popup menus
        guess-language      ; Robust automatic language detection
        helpful             ; A better help buffer
        htmlize             ; Convert buffer text and decorations to HTML
        mini-frame          ; Show minibuffer in child frame on read-from-minibuffer
        imenu-list          ; Show imenu entries in a separate buffer
        magit               ; A Git porcelain inside Emacs.
        ;;markdown-mode       ; Major mode for Markdown-formatted text
        multi-term          ; Managing multiple terminal buffers in Emacs.
        pinentry            ; GnuPG Pinentry server implementation
        use-package         ; A configuration macro for simplifying your .emacs
        vc-backup           ; VC backend for versioned backups
        ;;yaml-mode           ; YAML mode
        ;;consult-recoll      ; Consult interface for recoll query
        org-auto-tangle     ; Tangle org file when it is saved
        exec-path-from-shell; Get environment variables such as $PATH from the shell
        which-key))         ; Display available keybindings in popup

;; Install packages that are not yet installed
(dolist (package package-list)
  (straight-use-package package))

;; AucTeX-LaTeXmk fork
(provide 'tex-buf)
(straight-use-package
 '(auctex-latexmk :type git :host github :repo "aam-at/auctex-latexmk"))

;; Browsing nerd-fonts within emacs
(straight-use-package
 '(nerd-fonts :type git :host github :repo "twlz0ne/nerd-fonts.el"))

;; Special case for pdf-tools that has recently (2022) changed maintainer
(straight-use-package
 '(pdf-tools :type git :host github :repo "vedang/pdf-tools"))

;; Denote not yet on ELPA (2022-06-19)
(straight-use-package
 '(denote :type git :host github :repo "protesilaos/denote"))

;; The newes compat version is not on ELPA
(straight-use-package
 '(compat :type git :host github :repo "emacs-straight/compat"))

#+end_src

Packages of N. Rougier

#+begin_src emacs-lisp

;; Display org properties in the agenda buffer (modified version)
(straight-use-package
 '(org-agenda-property :type git :host github :repo "Malabarba/org-agenda-property"
                       :fork (:host github :repo "rougier/org-agenda-property")))

;; NANO splash
(straight-use-package
 '(nano-splash :type git :host github :repo "rougier/nano-splash"))

;; NANO theme
(straight-use-package
 '(nano-theme :type git :host github :repo "rougier/nano-theme"))

;; NANO modeline
(straight-use-package
 '(nano-modeline :type git :host github :repo "rougier/nano-modeline"))

;; NANO agenda
(straight-use-package
 '(nano-agenda :type git :host github :repo "rougier/nano-agenda"))

;; NANO agenda
(straight-use-package
 '(minibuffer-header :type git :host github :repo "rougier/minibuffer-header"))

;; SVG tags, progress bars & icons
(straight-use-package
 '(svg-lib :type git :host github :repo "rougier/svg-lib"))

;; Replace keywords with SVG tags
(straight-use-package
 '(svg-tag-mode :type git :host github :repo "rougier/svg-tag-mode"))

;; Dashboard for mu4e
(straight-use-package
 '(mu4e-dashboard :type git :host github :repo "rougier/mu4e-dashboard"))

;; Folding mode for mu4e
(straight-use-package
 '(mu4e-folding :type git :host github :repo "rougier/mu4e-folding"))

;; Relative date formatting
(straight-use-package
 '(relative-date :type git :host github :repo "rougier/relative-date"))

;; org imenu
(straight-use-package
 '(org-imenu :type git :host github :repo "rougier/org-imenu"))

;; pdf-drop-mode
(straight-use-package
 '(pdf-drop-mode :type git :host github :repo "rougier/pdf-drop-mode"))


;; Bilbliography manager in org mode
(straight-use-package
 '(org-bib :type git :host github :branch "org-imenu" :repo "rougier/org-bib-mode"))

#+end_src

My latex-specific auto-expanding-snippets and the <tab> and <return> functionalities:

#+begin_src emacs-lisp

(straight-use-package
  '(smart-keys-for-latex :type git :host github :repo "SebastianHalbig/smart-keys-for-latex"))

#+end_src

** TODO Startup :ENHANCE:

Emacs does a lot of things at startup and here, we disable pretty much everything.

#+begin_src emacs-lisp

(setq
 inhibit-startup-screen t               ; Disable start-up screen
 inhibit-startup-message t              ; Disable startup message
 inhibit-startup-echo-area-message t    ; Disable initial echo message
 initial-scratch-message ""             ; Empty the initial *scratch* buffer
 initial-buffer-choice t                ; Open *scratch* buffer at init
 native-comp-async-report-warnings-errors 'silent ; Do not focus the warnings buffer
 confirm-kill-processes nil) ; Emacs should not ask for confiration to kill a process.

(add-hook 'after-init-hook (lambda () (org-agenda nil "a")))
(setq org-agenda-window-setup 'current-window)

#+end_src

All fancy clickable things are unnecessary so we remove them
#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook #'(lambda()
                                  (when window-system
                                    (menu-bar-mode -1)
                                    (scroll-bar-mode -1)
                                    (tool-bar-mode -1)
                                    (tooltip-mode -1))))

#+end_src

We want to ensure that there is no littering. Hereto we enable no-littering.

#+begin_src emacs-lisp

(require 'no-littering)

#+end_src

** Encoding

We tell emacs to use UTF-8 encoding as much as possible.

#+begin_src emacs-lisp

(set-default-coding-systems 'utf-8)     ; Default to utf-8 encoding
(prefer-coding-system       'utf-8)     ; Add utf-8 at the front for automatic detection.
(set-terminal-coding-system 'utf-8)     ; Set coding system of terminal output
(set-keyboard-coding-system 'utf-8)     ; Set coding system for keyboard input on TERMINAL

#+end_src

Furthermore, we fix English as the default language.

#+begin_src emacs-lisp

(set-language-environment "English")    ; Set up multilingual environment

#+end_src

** Recovery

If Emacs or the computer crashes, you can recover the files you were editing at the time of the crash from their auto-save files. To do this, start Emacs again and type the command ~M-x recover-session~. Here, we parameterise how files are saved in the background.

#+begin_src emacs-lisp

(setq auto-save-list-file-prefix ; Prefix for generating auto-save-list-file-name
               (expand-file-name ".auto-save-list/.saves-" user-emacs-directory)
      ;; auto-save-file-name-transforms ; An alternative to the above prefix.
	  ;; `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))
      auto-save-default t        ; Auto-save every buffer that visits a file
      auto-save-timeout 20       ; Number of seconds between auto-save
      auto-save-interval 200     ; Number of keystrokes between auto-saves
      create-lockfiles t)        ; Create lockfiles to interact nicely with different editors operating on the same file.

#+end_src

** Backups

Emacs carefully copies the old contents to another file, called the “backup” file, before actually saving. Emacs makes a backup for a file only the first time the file is saved from a buffer. No matter how many times you subsequently save the file, its backup remains unchanged. However, if you kill the buffer and then visit the file again, a new backup file will be made. Here, we activate backup and parameterise the number of backups to keep.

#+begin_src emacs-lisp


(setq backup-directory-alist       ; File name patterns and backup directory names.
      `(("." . ,(expand-file-name "backups" user-emacs-directory)))
      make-backup-files t          ; Backup of a file the first time it is saved.
      vc-make-backup-files t       ; No backup of files under version contr
      backup-by-copying t          ; Don't clobber symlinks
      version-control t            ; Version numbers for backup files
      delete-old-versions t        ; Delete excess backup files silently
      kept-old-versions 6          ; Number of old versions to keep
      kept-new-versions 9          ; Number of new versions to keep
      delete-by-moving-to-trash t) ; Delete files to trash

;; Back
(require 'vc-backup)

#+end_src

** Bookmarks

#+begin_src emacs-lisp

(setq bookmark-default-file (expand-file-name "bookmark" user-emacs-directory))

#+end_src

** Recent files

50 Recents files with some exclusion (regex patterns).

#+begin_src emacs-lisp

(require 'recentf)

(add-to-list 'recentf-exclude no-littering-var-directory)
(add-to-list 'recentf-exclude no-littering-etc-directory)

(setq recentf-max-menu-items 10
      recentf-max-saved-items 100
      recentf-exclude '("~/Documents/.*/"))

(let (message-log-max)
  (recentf-mode 1))

#+end_src

** History :HOOK:

Remove text properties for kill ring entries (see https://emacs.stackexchange.com/questions/4187). This saves a lot of time when loading it.

#+begin_src emacs-lisp

(defun unpropertise-kill-ring ()
  (setq kill-ring (mapcar 'substring-no-properties kill-ring)))

(add-hook 'kill-emacs-hook 'unpropertise-kill-ring)

#+end_src

We save every possible history we can think of.

#+begin_src emacs-lisp

(setq kill-ring-max 50
      history-length 50)

(setq savehist-additional-variables
      '(kill-ring
        command-history
        set-variable-value-history
        custom-variable-history
        query-replace-history
        read-expression-history
        minibuffer-history
        read-char-history
        face-name-history
        bookmark-history
        file-name-history))

(put 'minibuffer-history         'history-length 50)
(put 'file-name-history          'history-length 50)
(put 'set-variable-value-history 'history-length 25)
(put 'custom-variable-history    'history-length 25)
(put 'query-replace-history      'history-length 25)
(put 'read-expression-history    'history-length 25)
(put 'read-char-history          'history-length 25)
(put 'face-name-history          'history-length 25)
(put 'bookmark-history           'history-length 25)

#+end_src

No duplicates in history

#+begin_src emacs-lisp

(setq history-delete-duplicates t)

#+end_src

Start history mode.

#+begin_src emacs-lisp

(let (message-log-max)
  (savehist-mode))

(setq savehist-file (concat user-emacs-directory "history.el"))


#+end_src

Enable auto-save-visited-mode

#+begin_src emacs-lisp

(auto-save-visited-mode)

#+end_src

A buffer can get out of sync with respect to its visited file on disk if that file is changed by another program. This is prevented by auto revert mode

#+begin_src emacs-lisp

(use-package autorevert
:config
(setq auto-revert-verbose t)
(global-auto-revert-mode))

#+end_src

** Saving

#+begin_src emacs-lisp

(add-hook 'before-save-hook 'delete-trailing-whitespace) ; On save, delete trailing whitespaces
(setq require-final-newline t)                ; Require a final newline—POSIX BOIS

#+end_src

** Cursor

Record cursor position from one session ot the other

#+begin_src emacs-lisp

(use-package saveplace
  :config
  (setq save-place-file (expand-file-name "saveplace" user-emacs-directory))
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))

#+end_src

** Customisation

Since init.el will be generated from this file, we save customisation in a dedicated file.

#+begin_src emacs-lisp

(setq custom-file (concat user-emacs-directory "custom.el"))

(when (file-exists-p custom-file)
  (load custom-file nil t))

#+end_src

** Server

Server start.

#+begin_src emacs-lisp

(require 'server)

(unless (server-running-p)
  (server-start))

#+end_src

** Keybindings :BUGFIX:

A "modern" keyboard layout is provided by ergoemacs.
Sadly it does things quite noisily.
We suppress this with a bit of "hacking".

#+begin_src emacs-lisp
(let ((message-log-max nil))             ; We suppress the output to *messages*
  (use-package ergoemacs-mode
    :config
    (setq ergoemacs-theme nil)            ; Uses Standard Ergoemacs keyboard theme
    (setq ergoemacs-keyboard-layout "us") ; Assumes QWERTY keyboard layout
    (ergoemacs-mode 1)))                  ; Globally enables ergoemacs-mode

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Core")

#+end_src


* Personal library

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

Some functions that are used throughout this configuration.

** String related

A set of functions to join two strings such as to fit a given width. This will be used for displaying elfeed posts, privileging the right part (tag and feed).

#+name: my-string-pad-right
#+begin_src emacs-lisp

(defun my-string-pad-right (len s)
  "If S is shorter than LEN, pad it on the right,
   if S is longer than LEN, truncate it on the right."

  (if (> (length s) len)
      (concat (substring s 0 (- len 1)) "…")
    (concat s (make-string (max 0 (- len (length s))) ?\ ))))

#+end_src

#+name: my-string-pad-left
#+begin_src emacs-lisp

(defun my-string-pad-left (len s)
  "If S is shorter than LEN, pad it on the left,
   if S is longer than LEN, truncate it on the left."

  (if (> (length s) len)
      (concat  "…" (substring s (- (length s) len -1)))
    (concat (make-string (max 0 (- len (length s))) ?\ ) s)))

#+end_src

#+name: my-string-join
#+begin_src emacs-lisp

(defun my-string-join (len left right &optional spacing)
  "Join LEFT and RIGHT strings to fit LEN characters with at least SPACING characters
between them. If len is negative, it is retrieved from current window width."

  (let* ((spacing (or spacing 3))
         (len (or len (window-body-width)))
         (len (if (< len 0)
                  (+ (window-body-width) len)
                len)))
    (cond ((> (length right) len)
           (my-string-pad-left len right))

          ((> (length right) (- len spacing))
           (my-string-pad-left len (concat (make-string spacing ?\ )
                                           right)))

          ((> (length left) (- len spacing (length right)))
           (concat (my-string-pad-right (- len spacing (length right)) left)
                   (concat (make-string spacing ?\ )
                           right)))
          (t
           (concat left
                   (make-string (- len (length right) (length left)) ?\ )
                   right)))))

#+end_src

Unwords seems to be undefined we remodel it here


#+begin_src emacs-lisp

(defun unwords (&rest words)        ;; unwords seems to be missing this function takes care of it.
  (mapconcat #'identity words " ")) ;; it joins a list of strings with a blank space as seperator.

#+end_src

** Date related

A set of date related functions, mostly used for mail display.

#+name: my-date-day
#+begin_src emacs-lisp

(defun my-date-day (date)
  "Return DATE day of month (1-31)."

  (nth 3 (decode-time date)))

#+end_src

#+name: my-date-month
#+begin_src emacs-lisp

(defun my-date-month (date)
  "Return DATE month number (1-12)."

  (nth 4 (decode-time date)))

#+end_src

#+name: my-date-year
#+begin_src emacs-lisp

(defun my-date-year (date)
  "Return DATE year."

  (nth 5 (decode-time date)))

#+end_src

#+name: my-date-equal
#+begin_src emacs-lisp

(defun my-date-equal (date1 date2)
  "Check if DATE1 is equal to DATE2."

  (and (eq (my-date-day date1)
           (my-date-day date2))
       (eq (my-date-month date1)
           (my-date-month date2))
       (eq (my-date-year date1)
           (my-date-year date2))))

#+end_src

#+name: my-date-inc
#+begin_src emacs-lisp

(defun my-date-inc (date &optional days months years)
  "Return DATE + DAYS day & MONTH months & YEARS years"

  (let ((days (or days 0))
        (months (or months 0))
        (years (or years 0))
        (day (my-date-day date))
        (month (my-date-month date))
        (year (my-date-year date)))
    (encode-time 0 0 0 (+ day days) (+ month months) (+ year years))))

#+end_src

#+name: my-date-dec
#+begin_src emacs-lisp

(defun my-date-dec (date &optional days months years)
  "Return DATE - DAYS day & MONTH months & YEARS years"

  (let ((days (or days 0))
        (months (or months 0))
        (years (or years 0)))
    (my-date-inc date (- days) (- months) (- years))))

#+end_src

#+name: my-date-today
#+begin_src emacs-lisp

(defun my-date-today ()
  "Return today date."

  (current-time))

#+end_src

#+name: my-date-is-today
#+begin_src emacs-lisp

(defun my-date-is-today (date)
  "Check if DATE is today."

  (my-date-equal (current-time) date))

#+end_src

#+name: my-date-is-yesterday
#+begin_src emacs-lisp

(defun my-date-is-yesterday (date)
  "Check if DATE is yesterday."

  (my-date-equal (my-date-dec (my-date-today) 1) date))

#+end_src

#+name: my-date-relative
#+begin_src emacs-lisp

(defun my-date-relative (date)
  "Return a string with a relative date format."

  (let* ((now (current-time))
         (delta (float-time (time-subtract now date)))
         (days (ceiling (/ (float-time (time-subtract now date)) (* 60 60 24)))))
    (cond ((< delta (*       3 60))     "now")
          ((< delta (*      60 60))     (format "%d minutes ago" (/ delta   60)))
          ;;  ((< delta (*    6 60 60))     (format "%d hours ago"   (/ delta 3600)))
          ((my-date-is-today date)      (format-time-string "%H:%M" date))
          ((my-date-is-yesterday date)  (format "Yesterday"))
          ((< delta (* 4 24 60 60))     (format "%d days ago" (+ days 1)))
          (t                            (format-time-string "%d %b %Y" date)))))

#+end_src

** Mini frame

A set of functions to create a mini-frame over the header line.

#+begin_src emacs-lisp

(defun my-mini-frame (&optional height foreground background border)
  "Create a child frame positioned over the header line whose
width corresponds to the width of the current selected window.

The HEIGHT in lines can be specified, as well as the BACKGROUND
color of the frame. BORDER width (pixels) and color (FOREGROUND)
can be also specified."

  (interactive)
  (let* ((foreground (or foreground
                         (face-foreground 'font-lock-comment-face nil t)))
         (background (or background (face-background 'highlight nil t)))
         (border (or border 1))
         (height (round (* (or height 8) (window-font-height))))
         (edges (window-pixel-edges))
         (body-edges (window-body-pixel-edges))
         (top (nth 1 edges))
         (bottom (nth 3 body-edges))
         (left (- (nth 0 edges) (or left-fringe-width 0)))
         (right (+ (nth 2 edges) (or right-fringe-width 0)))
         (width (- right left))

         ;; Window divider mode
         (width (- width (if (and (bound-and-true-p window-divider-mode)
                                  (or (eq window-divider-default-places 'right-only)
                                      (eq window-divider-default-places t))
                                  (window-in-direction 'right (selected-window)))
                             window-divider-default-right-width
                           0)))
         (y (- top border))
         (child-frame-border (face-attribute 'child-frame-border :background)))
    (set-face-attribute 'child-frame-border t :background foreground)
    (let ((frame (make-frame
                  `((parent-frame . ,(window-frame))
                    (delete-before . ,(window-frame))
                    (minibuffer . nil)
                    (modeline . nil)
                    (left . ,(- left border))
                    (top . ,y)
                    (width . (text-pixels . ,width))
                    (height . (text-pixels . ,height))
                    ;; (height . ,height)
                    (child-frame-border-width . ,border)
                    (internal-border-width . ,border)
                    (background-color . ,background)
                    (horizontal-scroll-bars . nil)
                    (menu-bar-lines . 0)
                    (tool-bar-lines . 0)
                    (desktop-dont-save . t)
                    (unsplittable . nil)
                    (no-other-frame . t)
                    (undecorated . t)
                    (pixelwise . t)
                    (visibility . t)))))
      (set-face-attribute 'child-frame-border t :background child-frame-border)
      frame)))

#+end_src

#+begin_src emacs-lisp

(defun my-mini-frame-reset (frame)
  "Reset FRAME size and position.

  Move frame at the top of parent frame and resize it
  horizontally to fit the width of current selected window."

  (interactive)
  (let* ((border (frame-parameter frame 'internal-border-width))
         (height (frame-parameter frame 'height)))
    (with-selected-frame (frame-parent frame)
      (let* ((edges (window-pixel-edges))
             (body-edges (window-body-pixel-edges))
             (top (nth 1 edges))
             (bottom (nth 3 body-edges))
             (left (- (nth 0 edges) (or left-fringe-width 0)))
             (right (+ (nth 2 edges) (or right-fringe-width 0)))
             (width (- right left))
             (y (- top border)))
        (set-frame-width frame width nil t)
        (set-frame-height frame height)
        (set-frame-position frame (- left border) y)))))

#+end_src

#+begin_src emacs-lisp

(defun my-mini-frame-shrink (frame &optional delta)
  "Make the FRAME DELTA lines smaller.

  If no argument is given, make the frame one line smaller. If
  DELTA is negative, enlarge frame by -DELTA lines."

  (interactive)
  (let ((delta (or delta -1)))
    (when (and (framep frame)
               (frame-live-p frame)
               (frame-visible-p frame))
      (set-frame-parameter frame 'height
                           (+ (frame-parameter frame 'height) delta)))))

#+end_src

** Mu4e related

A set of mail (mu4e) related functions.

#+name: my-mu4e-get-account
#+begin_src emacs-lisp

(defun my-mu4e-get-account (msg)
  "Get MSG related account."

  (let* ((maildir (mu4e-message-field msg :maildir))
         (maildir (substring maildir 1)))
    (nth 0 (split-string maildir "/"))))

#+end_src

#+name: my-mu4e-get-maildir
#+begin_src emacs-lisp

(defun my-mu4e-get-maildir (msg)
  "Get MSG related maildir."

  (let* ((maildir (mu4e-message-field msg :maildir))
         (maildir (substring maildir 1)))
    (nth 0 (reverse (split-string maildir "/")))))

#+end_src

#+name: my-mu4e-get-mailbox
#+begin_src emacs-lisp

(defun my-mu4e-get-mailbox (msg)
  "Get MSG related mailbox as 'account - maildir' "

  (format "%s - %s" (mu4e-get-account msg) (mu4e-get-maildir msg)))

#+end_src

#+name: my-mu4e-get-sender
#+begin_src emacs-lisp

(defun my-mu4e-get-sender (msg)
  "Get MSG sender."

  (let ((addr (cdr-safe (car-safe (mu4e-message-field msg :from)))))
    (mu4e~headers-contact-str (mu4e-message-field msg :from))))

#+end_src

** TODO Better search :BINDING:

Bound to the =C-s=, this function provides an integrated search and regexp-replace environment. Invoking it once opens the search with the active region as its default input. Typing a new string, deletes the default query and replaces it. If there is no default input, the arrow keys allow to navigate the search history (of the active buffer). Iterated calling of ~my-search()~, toggles between search and regexp-replace mode.

#+begin_src emacs-lisp

(bind-key "C-f" #'my-consult-line `ergoemacs-override-keymap)

#+end_src

** TODO Configuration :BINDING:HOOK:DEFER:
# :PROPERTIES:
# :header-args:emacs-lisp: :prologue "(with-eval-after-load 'org" :epilogue ")"
# :END:

*** General

This section is meant to ease the writing of the configuration file using a dedicated minor mode (~my-config-mode~) with a few key bindings:

=C-`=       : Toggle navigation sidebar
=C-c C-p=   : Go to previous subsection
=C-c C-n=   : Go to next subsection
=C-c C-S-p= : Go to previous section
=C-c C-S-n= : Go to next section
=C-c t=     : Fold code blocks
=C-c f=     : Filter block visibility (sidebar)
=C-c C-v t= : Export (tangle) code
=C-c C-v s= : Execute current subsection

Before being able to use it, you need to execute the whole subtree using [[help:org-babel-execute-subtree][org-babel-execute-subtree]] (generally bound to =C-c C-v s=).

*** Sidebar :BINDING:

This defines an org sidebar using imenu-list.

#+name: my-org-sidebar
#+begin_src emacs-lisp

(require 'imenu)
(require 'imenu-list)

(defun my-org-tree-to-indirect-buffer ()
  "Create indirect buffer, narrow it to current subtree and unfold blocks"

  (org-tree-to-indirect-buffer)
  (org-show-block-all)
  (setq-local my-org-blocks-hidden nil))

(defun my-org-sidebar ()
  "Open an imenu list on the left that allow navigation."

  (interactive)
  (setq imenu-list-after-jump-hook #'my-org-tree-to-indirect-buffer
        imenu-list-position 'left
        imenu-list-size 36
        imenu-list-focus-after-activation t)

  (let ((heading (substring-no-properties (or (org-get-heading t t t t) ""))))
    (when (buffer-base-buffer)
      (switch-to-buffer (buffer-base-buffer)))
    (imenu-list-minor-mode)
    (imenu-list-stop-timer)
    (hl-line-mode)
    (face-remap-add-relative 'hl-line :inherit 'nano-subtle)
    (setq header-line-format
          '(:eval
            (nano-modeline-render nil
                                  (buffer-name imenu-list--displayed-buffer)
                                  "(outline)"
                                  "")))
    (setq-local cursor-type nil)
    (when (> (length heading) 0)
      (goto-char (point-min))
      (search-forward heading)
      (imenu-list-display-dwim))))

#+end_src

#+RESULTS: my-org-sidebar
: my-org-sidebar

This toggles the org-sidebar.

#+name: org-sidebar-toggle
#+begin_src emacs-lisp

(defun my-org-sidebar-toggle ()
  "Toggle the org-sidebar"

  (interactive)
  (if (get-buffer-window "*Ilist*")
      (progn
        (quit-window nil (get-buffer-window "*Ilist*"))
        (switch-to-buffer (buffer-base-buffer)))
    (my-org-sidebar)))

#+end_src

#+RESULTS: org-sidebar-toggle
: my-org-sidebar-toggle

Make sure tangle is applied to the base buffer and not the subtree.

#+name: my-org-babel-tangle
#+begin_src emacs-lisp

(defun my-org-babel-tangle ()
  "Write code blocks to source-specific files from the base buffer."

  (interactive)
  (with-current-buffer (or (buffer-base-buffer)
                           (current-buffer))
    (org-babel-tangle)))

#+end_src

#+RESULTS: my-org-babel-tangle
: my-org-babel-tangle


Toggle code blocks folding, starting folded.

#+name: my-org-toggle-blocks
#+begin_src emacs-lisp

(defvar my-org-blocks-hidden nil)

(defun my-org-toggle-blocks ()
  "Toggle code blocks folding."

  (interactive)
  (if my-org-blocks-hidden
      (org-show-block-all)
    (org-hide-block-all))
  (setq-local my-org-blocks-hidden (not my-org-blocks-hidden)))

(add-hook 'config-mode-hook #'my-org-toggle-blocks)

#+end_src

#+RESULTS: my-org-toggle-blocks
| my-org-toggle-blocks |


#+begin_src emacs-lisp

(defvar my-imenu-list-folding-status t
  "Folding status of the imenu-list")

(defun my-imenu-list-toggle-folding ()
  "Toggle top level nodes of the imenu-list buffer"

  (interactive)
  (with-current-buffer "*Ilist*"
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\+ " nil t)
        (if my-imenu-list-folding-status
            (hs-hide-block)
          (hs-show-block)))
      (setq my-imenu-list-folding-status (not my-imenu-list-folding-status)))))

(bind-key "S-<tab>" #'my-imenu-list-toggle-folding imenu-list-major-mode-map)

#+end_src

#+RESULTS:
: my-imenu-list-toggle-folding

Some information for when a top node is closed

#+begin_src emacs-lisp

(defun my-display-code-line-counts (ov)
  (when (eq 'code (overlay-get ov 'hs))
    (overlay-put ov 'display
                 (propertize
                  (format " [%d sections] … "
                          (- (count-lines (overlay-start ov)
                                          (overlay-end ov)) 1))
                  'face 'nano-faded))))

(setq hs-set-up-overlay #'my-display-code-line-counts)

#+end_src

#+RESULTS:
: my-display-code-line-counts

#+begin_src emacs-lisp

(defun my-imenu-list-display-dwim ()
  "Display or toggle the entry at `point'."
  (interactive)
  (save-selected-window
    (save-excursion
      (my-imenu-list-ret-dwim))))

(defun my-imenu-list-ret-dwim ()
  "Jump to or toggle the entry at `point'."
  (interactive)
  (save-excursion
    (let ((entry (imenu-list--find-entry)))
      (when (imenu--subalist-p entry)
        (setq entry (cons
                     (car entry)
                     (get-text-property 0 'marker (car entry)))))
      (imenu-list--goto-entry entry))))

(bind-key "<SPC>" #'my-imenu-list-display-dwim imenu-list-major-mode-map)
(bind-key "<return>" #'my-imenu-list-ret-dwim imenu-list-major-mode-map)

#+end_src

#+RESULTS:
: my-imenu-list-ret-dwim

*** Filter :BINDING:

This provide the ~my-org-imenu-filter~ that allow to filter sidebar entries using the specified expression (e.g. "+HOOK +DEFER").

#+begin_src emacs-lisp

(bind-key "C-c f" #'my-org-imenu-filter)
(bind-key "f" #'my-org-imenu-filter imenu-list-major-mode-map)
(bind-key "U" #'imenu-list-refresh imenu-list-major-mode-map)

#+end_src

#+RESULTS:
: imenu-list-refresh

3 levels for org-imenu

#+begin_src emacs-lisp

(setq org-imenu-depth 3)

#+end_src

#+RESULTS:
: 3


#+begin_src emacs-lisp

(require 'svg-tag-mode)

(defvar my-org-imenu-filter-history
  '("BINDING" "HOOK" "ADVICE" "FACE" "MODE" "DEFER"
    "PERSONAL" "INACTIVE" "BUGFIX" "OTHER" "TIMER" "OS")
  "Filter history list.")

(with-eval-after-load 'org
  (defvar my-org-imenu-filter-function
    (cdr (org-make-tags-matcher "*"))
    "Filter function to decide if a headline is kept"))

(defun my-org-imenu-filter ()
  "Define and apply a new filter"

  (interactive)
  (let* ((match (completing-read-multiple
                 "FILTER: "
                 my-org-imenu-filter-history
                 nil nil nil
                 'my-org-imenu-filter-history))
         (match (mapconcat #'identity match " ")))
    (when (string= "" match)
      (setq match "*"))
    (setq my-org-imenu-filter-function
          (cdr (org-make-tags-matcher match)))
    (imenu-list-refresh)))


(defun my-org-imenu-filter-tree (&optional bound parent-match)
  "Build a imenu list using current filter function"

  (let* ((headlines '()))
    (save-excursion
      (org-with-wide-buffer
       (unless bound
         (setq bound (point-max))
         (goto-char (point-min)))
       (while (re-search-forward org-heading-regexp bound t)
         (let* ((element (org-element-at-point))
                (begin (org-element-property :begin element))
                (end (org-element-property :end element))
                (marker (copy-marker begin))
                (level (org-element-property :level element))
                (tags (save-excursion
                        (goto-char begin)
                        (org-get-tags)))
                (match (save-excursion
                         (goto-char begin)
                         (funcall my-org-imenu-filter-function
                                  nil (org-get-tags) level)))

                (title (org-element-property :raw-value element))
                (title (org-link-display-format
                        (substring-no-properties title)))
                (title (propertize title 'org-imenu-marker marker
                                   'org-imenu t))
                (title (if (member "INACTIVE" tags)
                           (propertize title 'face 'nano-faded)
                         title))
                (svg-tags (mapconcat #'(lambda (tag)
                                         (propertize tag 'display (svg-tag-make tag :face 'nano-faded)))
                                     tags " "))
                (title (if tags (format "%s %s" title svg-tags) title))
                (title (propertize title 'marker marker))
                (children (my-org-imenu-filter-tree end match)))
           (goto-char end)

           (cond ((> level org-imenu-depth)
                  nil)
                 ((> (length children) 0)
                  (add-to-list 'headlines (append (list title) children) t))
                 ((or match parent-match)
                  (add-to-list 'headlines (cons title marker) t)))))))
    headlines))

(advice-add #'org-imenu-get-tree :override #'my-org-imenu-filter-tree)

#+end_src

#+RESULTS:

*** Configuration mode

This section defines the ~my-config-mode~ to ease navigating and interacting with the configuration file.

Navigation commands using the ilist menu.

#+begin_src emacs-lisp

(defun my-config-mode-prev-header ()
  "Move to previous header"

  (interactive)
  (with-current-buffer "*Ilist*"
    (search-backward-regexp "^  ")
    (imenu-list-display-dwim)))

(defun my-config-mode-next-header ()
  "Move to next header"

  (interactive)
  (with-current-buffer "*Ilist*"
    (forward-line)
    (search-forward-regexp "^  ")
    (imenu-list-display-dwim)))

(defun my-config-mode-prev-section ()
  "Move to previous section"

  (interactive)
  (with-current-buffer "*Ilist*"
    (search-backward-regexp "\\+ " nil nil 2)
    (forward-line)
    (imenu-list-display-dwim)))

(defun my-config-mode-next-section ()
  "Move to next section"

  (interactive)
  (with-current-buffer "*Ilist*"
    (previous-line)
    (search-forward-regexp "\\+ ")
    (forward-line)
    (imenu-list-display-dwim)))

#+end_src

#+RESULTS:
: my-config-mode-next-section

A minor mode for configuration

#+name: config-mode
#+begin_src emacs-lisp

(define-minor-mode my-config-mode
  "Configuration mode"

  :init-value nil
  :global nil
  :keymap (let* ((map (make-sparse-keymap)))
            (bind-key "C-c C-p"   #'my-config-mode-prev-header map)
            (bind-key "C-c C-n"   #'my-config-mode-next-header map)
            (bind-key "C-c C-S-p" #'my-config-mode-prev-section map)
            (bind-key "C-c C-S-n" #'my-config-mode-next-section map)
            (bind-key "C-`"       #'my-org-sidebar-toggle map)
            (bind-key "C-c C-v t" #'my-org-babel-tangle map)
            (bind-key "C-c t"     #'my-org-toggle-blocks map)
            map)

  (require 'org)
  (if my-config-mode
      (my-org-sidebar)))


#+end_src

#+RESULTS: config-mode
| my-config-mode         | keymap | (67108960 . my-org-sidebar-toggle)                                                                                                    | (3 keymap (116 . my-org-toggle-blocks) (22 keymap (116 . my-org-babel-tangle)) (33554446 . my-config-mode-next-section) (33554448 . my-config-mode-prev-section) (14 . my-config-mode-next-header) (16 . my-config-mode-prev-header)) |
| vc-dir-git-mode        | keymap | (122 keymap (112 . vc-git-stash-pop) (115 . vc-git-stash-snapshot) (99 . vc-git-stash))                                               |                                                                                                                                       |
| diff-minor-mode        | keymap | (3 keymap (61 keymap (remap keymap (undo . diff-undo)) (82 . diff-reverse-direction) (114 . diff-restrict-view) (65 . diff-ediff-patch) (111 . diff-goto-source) (87 . widen) (mouse-2 . diff-goto-source) (13 . diff-goto-source) (123 . diff-file-prev) (125 . diff-file-next) (75 . diff-file-kill) (107 . diff-hunk-kill) (backtab . diff-hunk-prev) (9 . diff-hunk-next) (80 . diff-file-prev) (112 . diff-hunk-prev) (78 . diff-file-next) (110 . diff-hunk-next) keymap (103 . revert-buffer) (60 . beginning-of-buffer) (62 . end-of-buffer) (104 . describe-mode) (63 . describe-mode) (127 . scroll-down-command) (33554464 . scroll-down-command) (32 . scroll-up-command) (113 . quit-window) (57 . digit-argument) (56 . digit-argument) (55 . digit-argument) (54 . digit-argument) (53 . digit-argument) (52 . digit-argument) (51 . digit-argument) (50 . digit-argument) (49 . digit-argument) (48 . digit-argument) (45 . negative-argument) (remap keymap (self-insert-command . undefined)))) |                                                                                                                                       |
| gnus-dead-summary-mode | keymap | #^nil nil keymap                                                                                                                     |                                                                                                                                       |

A shortcut to edit configuration

#+begin_src emacs-lisp :prologue "" :epilogue ""
(defun my-config ()
  "Create a new for editing configuration"

  (interactive)
  (select-frame (make-frame '((name . "my-config")
                              (width . 150)
                              (height . 45))))
  (find-file "~/Documents/GitHub/dotemacs/dotemacs.org")
  (my-config-mode))

#+end_src

#+RESULTS:
: my-config

An autoload function for my-config (that will load org mode).

#+begin_src emacs-lisp :prologue "" :epilogue ""

(autoload 'my-config
  (expand-file-name "init.el" user-emacs-directory)
  "Autoloaded my-config command."
  t)

#+end_src

#+RESULTS:

*** Bugfix :BUGFIX:

*Temporary bugfix* for babel emacs-lisp that does not take into account prologue/epilogue.
See https://list.orgmode.org/CA+G3_PNrdhx0Ejzw8UO7DgZ+ju1B7Ar_eTch5MMViEpKGwqq3w@mail.gmail.com/T/
(November 2020)

#+name: org-babel-expand-body:emacs-lisp
#+begin_src emacs-lisp

(defun my-org-babel-expand-body:emacs-lisp (orig-fun body params)
  "Expand BODY according to PARAMS and call original function with new body"

  (let* ((pro (or (cdr (assq :prologue params)) ""))
         (epi (or (cdr (assq :epilogue params)) ""))
         (body (concat pro body epi)))
    (apply orig-fun `(,body ,params))))

(advice-add 'org-babel-expand-body:emacs-lisp
            :around
            #'my-org-babel-expand-body:emacs-lisp)

#+end_src

#+RESULTS: org-babel-expand-body:emacs-lisp


Some compat tools do not work as expected:

#+begin_src emacs-lisp

(defun compat-executable-find (command &optional remote)
  "Search for COMMAND in `exec-path' and return the absolute file name.
Return nil if COMMAND is not found anywhere in `exec-path'.  If
REMOTE is non-nil, search on the remote host indicated by
`default-directory' instead."
  (if (and remote (file-remote-p default-directory))
      (let ((res (locate-file
	          command
	          (mapcar
	           (lambda (x) (concat (file-remote-p default-directory) x))
	           (exec-path))
	          exec-suffixes 'file-executable-p)))
        (when (stringp res) (file-local-name res)))
    ;; Use 1 rather than file-executable-p to better match the
    ;; behavior of call-process.
    (let ((default-directory (file-name-quote default-directory 'top)))
      (locate-file command exec-path exec-suffixes 1))))

#+end_src

*** Auto-tangle

Automatically tangle org-mode files with the option #+auto_tangle: t

#+begin_src emacs-lisp

(add-hook 'org-mode-hook 'org-auto-tangle-mode)

#+end_src

#+RESULTS:
| org-auto-tangle-mode | org-tempo-setup | my-org-mode-hook | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] |

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Personal library")

#+end_src


* Interface

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** TODO Frame :BINDING:

A [[help:make-frame][make-frame]] rewrite that creates the frame and switch to the ~*scratch*~ buffer.

#+name: my-new-frame
#+begin_src emacs-lisp

(defun my-make-frame ()
  "Create a new frame and switch to *scratch* buffer."

  (interactive)
  (select-frame (make-frame))
  (switch-to-buffer "*scratch*"))

#+end_src

A function that close the current frame and kill emacs if it was the last frame.

#+name: my-kill-emacs
#+begin_src emacs-lisp

(defun my-kill-emacs ()
  "Delete frame or kill Emacs if there is only one frame."

  (interactive)
  (condition-case nil
      (delete-frame)
    (error (save-buffers-kill-terminal))))

#+end_src

Default frame geometry (large margin: 24 pixels).

#+begin_src emacs-lisp

(require 'frame)

;; Default frame settings
(setq default-frame-alist '((min-height . 1)  '(height . 45)
                            (min-width  . 1)  '(width  . 81)
                            (vertical-scroll-bars . nil)
                            (internal-border-width . 24)
                            (left-fringe . 0)
                            (right-fringe . 0)
                            (tool-bar-lines . 0)
                            (menu-bar-lines . 1)))

;; Default frame settings
(setq initial-frame-alist default-frame-alist)


#+end_src

Frame related binding (self explanatory).

#+begin_src emacs-lisp


(bind-key "M-n"        #'my-make-frame `ergoemacs-override-keymap)
(bind-key "C-x C-c"    #'my-kill-emacs `ergoemacs-override-keymap)
(bind-key "M-`"        #'other-frame `ergoemacs-override-keymap)
;; (bind-key "<M-return>" #'toggle-frame-maximize `ergoemacs-override-keymap)

#+end_src

For frame maximisation, we have to make a specific case for [[help:org-mode][org-mode]].

#+begin_src emacs-lisp

(with-eval-after-load 'org
  (bind-key "<M-return>" #'toggle-frame-maximized 'org-mode-map))

#+end_src

** Window :BINDING:MODE:

Margin and divider mode.

#+begin_src emacs-lisp

(setq-default window-divider-default-right-width 24
              window-divider-default-places 'right-only
              left-margin-width 0
              right-margin-width 0
              window-combination-resize nil) ; Do not resize windows proportionally

(window-divider-mode 1)

#+end_src

Toggle the dedicated flag on the current window

#+name: my-toggle-window-dedicated
#+begin_src emacs-lisp

;; Make a window dedicated
(defun my-toggle-window-dedicated ()
  "Toggle whether the current active window is dedicated or not"
  (interactive)
  (message
   (if (let (window (get-buffer-window (current-buffer)))
         (set-window-dedicated-p window (not (window-dedicated-p window))))
       "Window '%s' is dedicated"
     "Window '%s' is normal")
   (current-buffer))
  (force-window-update))

(bind-key "C-c d" #'my-toggle-window-dedicated `ergoemacs-override-keymap)

#+end_src

Close the window and kill the buffer if its title matches a certain regular expression.
This functionality is bound to ~C-w~.

#+name: my-delete-window
#+begin_src emacs-lisp
(defvar my-kill-buffer-by-regexp "^\*.+\*" "Buffers whose name matches this regular expression are killed upon closing their window")

(defun my-delete-window()
  (interactive)
  "Close the active window. If the buffer-name matches the my-kill-buffer-by-regexp variable, close the buffer first."
  (let ((currently-active-windows (count-windows)))
    (when (or (eq currently-active-windows 1)
              (string-match my-kill-buffer-by-regexp (buffer-name)))
      (ergoemacs-close-current-buffer))
    (unless (eq currently-active-windows 1) (delete-window))))

(bind-key "C-w" #'my-delete-window `ergoemacs-override-keymap)
(bind-key "M-w" #'ergoemacs-close-current-buffer `ergoemacs-override-keymap)
#+end_src

** Buffer :BINDING:

Size of temporary buffers

#+begin_src emacs-lisp

(temp-buffer-resize-mode)
(setq temp-buffer-max-height 8)

#+end_src

Unique buffer names

#+begin_src emacs-lisp

(require 'uniquify)

(setq uniquify-buffer-name-style 'reverse
      uniquify-separator " • "
      uniquify-after-kill-buffer-p t
      uniquify-ignore-buffers-re "^\\*")

#+end_src

No question after killing a buffer (kill-buffer asks you which buffer to switch to)

#+begin_src emacs-lisp

(bind-key "C-x k" #'kill-current-buffer `ergoemacs-override-keymap)

#+end_src
** TODO Files :BINDING:PERSONAL:

We first set some settings for dired,

#+begin_src emacs-lisp

(use-package dired
  :bind
  (nil
   :map dired-mode-map
   ("c"      . dired-do-copy)
   ("/"      . dired-goto-file)
   ("+"      . dired-create-empty-file)
   ("n"      . dired-create-directory)
   ("p"      . dired-insert-subdir)
   ("d"      . dired-kill-subdir)
   ("f"      . dired-find-file-other-window)
   ("<up>"   . (lambda () (interactive) (dired-next-line -1)))
   ("<down>" . dired-next-line)
   ("<left>" . dired-up-directory)
   ("x"      . dired-do-delete)
   ("X"      . dired-do-flagged-delete))
  :config
  (setq dired-mouse-drag-files t) ; added in Emacs 29
  (setq mouse-drag-and-drop-region-cross-program t) ; added in Emacs 29
  (setq dired-kill-when-opening-new-dired-buffer t) ; added in Emacs 28
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-dwim-target t)
  (setq dired-listing-switches
        "-g --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group"))

#+end_src

We define some standard directories.

#+begin_src emacs-lisp

(use-package files
  :config
  ;; (setq my-files-dir-alist
  ;;       '(((title . "  Research")     (path . "~/Documents/mathematics/research"))
  ;;         ((title . "  Teaching")     (path . "~/Documents/mathematics/research"))
  ;;         ((title . "  Literature")   (path . "~/Documents/mathematics/literature"))
  ;;         ((title . "  Notes")        (path . "~/Documents/org-files"))
  ;;         ((title . "  Photos")       (path . "~/Documents/Pictures"))
  ;;         ((title . "ﱘ  Music")        (path . "~/Documents/Music"))
  ;;         ((title . "  Downloads")    (path . "~/Downloads"))))
  (setq large-file-warning-threshold (* 16 1024 1024))
  )

#+end_src

TODO: Defining a nano-modeline for the dirvish mode.

#+begin_src emacs-lisp

(defun my-nano-modeline-dirvish-list-mode-p ()
  (derived-mode-p 'dirvish-mode)
  )

(defun my-nano-modeline-dirvish-list-mode (&optional icon)
  (let* ((icon (or icon
                   (plist-get (cdr (assoc 'dirvish-mode nano-modeline-mode-formats)) :icon)))
         (cur-file-name (when dired-mode (dired-file-name-at-point)))
         (cur-file-attr (when cur-file-name (file-attributes cur-file-name)))
         (cur-file-last-acc (when cur-file-attr (file-attribute-access-time cur-file-attr)))
         (cur-file-str (when cur-file-last-acc (concat cur-file-name " last accessed: " cur-file-last-acc)))
         )(
         (nano-modeline-render icon
                               cur-file-name
                               cur-file-last-acc
                               ""))))
#+end_src

Thanks to dirvish, navigating through files is now like dancing.

#+begin_src emacs-lisp

(use-package dirvish
  :hook ((dirvish-setup . dirvish-emerge-mode)
         (dirvish-mode  . my-thin-modeline)
         (dired-mode    . my-thin-modeline))
  :bind
  (:map ergoemacs-override-keymap
        ("C-x d" . dirvish)
        ("C-x D" . dirvish-side)
        ("C-x a" . dirvish-quick-access)
   :map dirvish-mode-map
        ("SPC"      . consult-buffer)
        ("C-<up>"   . dirvish-history-go-forward)
        ("C-<down>" . dirvish-history-go-backward)
        ("TAB"      . dirvish-subtree-toggle)
        ("a"        . dirvish-quick-access)
        ("p"        . dirvish-move)
        ("P"        . dirvish-yank-menu)
        ("f"        . dirvish-file-info-menu)
        ("*"        . dirvish-mark-menu)
        ("M-e"      . dirvish-emerge-menu)
        ([remap dired-sort-toggle-or-edit] . dirvish-quicksort)
        ([remap dired-do-redisplay] . dirvish-ls-switches-menu)
        ([remap dired-do-copy] . dirvish-yank-menu)
        :map mode-specific-map
        ("e" . dirvish-dwim))
  :config
  (dirvish-override-dired-mode)
  (dirvish-define-preview exa (file)
                          "Use `exa' to generate directory preview."
                          :require ("exa")
                          (when (file-directory-p file)
                            `(shell . ("exa" "--color=always" "-al" "--group-directories-first" ,file))))
  (add-to-list 'dirvish-preview-dispatchers 'exa)
  (add-to-list 'nano-modeline-mode-formats '(dirvish-mode
                                             :mode-p my-nano-modeline-dirvish-list-mode-p
                                             :format my-nano-modeline-dirvish-list-mode
                                             :icon "") t)
  (setq dirvish-quick-access-entries
        '(("h" "~/"                                " Home")
          ("e" "~/.emacs.d/    "                   " Emacs cache")
          ("r" "~/Documents/mathematics/research"  " Research")
          ("t" "~/Documents/mathematics/teaching"  " Teaching")
          ("d" "~/Documents/organisation"          " Organisation")
          ;; ("o" "fd -e org"   "All org files in ~/Documents") TODO
          ("t" "~/.local/share/Trash/files/" "Trash")))
  (setq dirvish-emerge-groups '(("Research documents"
                                 (extensions "tex" "bib")
                                 nil nil)
                                ("Plaintext documents"
                                 (extensions "pdf" "epub" "org" "txt")
                                 nil nil)
                                ("Recent files"
                                 (predicate . recent-files-today)
                                 nil nil)
                                ("Directories"
                                 (predicate . directories)
                                 nil nil)
                                ("Pictures"
                                 (extensions "jpg" "png" "svg" "gif")
                                 t t)
                                ("Video"
                                 (extensions "mp4" "mkv" "webm")
                                 t t)
                                ("Audio"
                                 (extensions "mp3" "flac" "wav" "ape" "aac")
                                 t t)
                                ("Archives"
                                 (extensions "gz" "rar" "zip")
                                 t t)
                                ("Auxiliary files"
                                 (extensions "aux" "auxlock" "bbl" "blg" "fls" "log" "out" "latexmkrc")
                                 t t)
                                ("other files"
                                 (regex . ".*")
                                 t t)
                                ))
  (setq dirvish-open-with-programs
        `((,dirvish-video-exts . ("tdrop" "-h" "25%" "-w" "25%" "-x" "1000" "-y" "1000" "mpv" "%f"))
          (,dirvish-audio-exts . ("tdrop" "-h" "25%" "-w" "25%" "-x" "1000" "-y" "1000" "mpv" "%f"))))
  (setq dirvish-attributes '(vc-state file-size git-msg subtree-state all-the-icons collapse))
  (setq dirvish-all-the-icons-height 0.8)
  (setq dirvish-side-attributes dirvish-attributes)
  (setq dirvish-side-preview-dispatchers (append '(vc-diff) dirvish-preview-dispatchers))
  (setq dirvish-side-display-alist '((side . left) (slot . -1) (window-width . 0.2)))
  (setq dirvish-side-header-line-format '(:left (project) :right (vc-info)))
  (setq dirvish-side-mode-line-format '(:left (sort omit) :right (index)))
  )

#+end_src

Follow symlinks without prompt

#+begin_src emacs-lisp

(setq vc-follow-symlinks t)

#+end_src

** Dialogues :OS:

Emacs can use a large number of dialogs and popups. Here we get rid of them.

#+begin_src emacs-lisp

(setq-default show-help-function nil    ; No help text
              use-file-dialog nil       ; No file dialog
              use-dialog-box nil        ; No dialog box
              pop-up-windows nil)       ; No popup windows

#+end_src

** Keyboard :MODE:

The mode displays the key bindings following your currently entered incomplete command (a ;; prefix) in a popup.

#+begin_src emacs-lisp

(require 'which-key)

(which-key-mode)

#+end_src

** Cursor :MODE:

We set the appearance of the cursor: vertical line, 3 pixels thick, no blinking

#+begin_src emacs-lisp

(setq-default cursor-in-non-selected-windows nil ; Hide the cursor in inactive windows
              cursor-type '(bar . 3)             ; Vertical cursor
              cursor-intangible-mode t           ; Enforce cursor intangibility
              x-stretch-cursor nil)
                                        ; Don't stretch cursor to the glyph width

(blink-cursor-mode 0)                            ; Blinking cursor

#+end_src

** Text :BINDING:

Pretty self-explanatory

#+begin_src emacs-lisp

(setq-default use-short-answers t ; Replace yes/no prompts with y/n
              confirm-nonexistent-file-or-buffer nil ; Ok to visit non existent files
              words-include-escapes nil) ; Don't treat escape chars as part of words

#+end_src

Replace region when inserting text

#+begin_src emacs-lisp

(delete-selection-mode 1)

#+end_src

A smarter fill/unfill command

#+begin_src emacs-lisp

(defun my-fill-unfill ()
  "Like `fill-paragraph', but unfill if used twice."

  (interactive)
  (let ((fill-column
         (if (eq last-command #'my-fill-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'fill-paragraph)))

(bind-key "M-q"  #'my-fill-unfill)
;; (bind-key [remap fill-paragraph]  #'my-fill-unfill)

#+end_src

** Sound

Disable the bell (auditory or visual).

#+begin_src emacs-lisp

(setq-default visible-bell nil             ; No visual bell
              ring-bell-function 'ignore)  ; No bell

#+end_src

** Mouse :MODE:

Mouse behavior can be finely controlled using the [[help:mouse-avoidance-mode][mouse-avoidance-mode]].

#+begin_src emacs-lisp

(setq-default mouse-yank-at-point t) ; Yank at point rather than pointer
(mouse-avoidance-mode 'exile)        ; Avoid collision of mouse with point

#+end_src

Mouse active in tty mode.

#+begin_src emacs-lisp

(unless (display-graphic-p)
  (xterm-mouse-mode 1)
  (global-set-key (kbd "<mouse-4>") #'scroll-down-line)
  (global-set-key (kbd "<mouse-5>") #'scroll-up-line))

#+end_src

** Scroll

Smoother scrolling.

#+begin_src emacs-lisp

(setq-default scroll-conservatively 101       ; Avoid recentering when scrolling far
              scroll-margin 2                 ; Add a margin when scrolling vertically
              recenter-positions '(5 bottom)) ; Set re-centering positions

#+end_src

** Clipboard :OS:

Allows system and Emacs clipboard to communicate smoothly (both ways)

#+begin_src emacs-lisp

(setq-default select-enable-clipboard t) ; Merge system's and Emacs' clipboard

#+end_src

Make sure clipboard works properly in tty mode on OSX.

#+begin_src emacs-lisp

(defun my-paste-from-osx ()
  (shell-command-to-string "pbpaste"))

(defun my-copy-to-osx (text &optional push)
  (let ((process-connection-type nil))
    (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
      (process-send-string proc text)
      (process-send-eof proc))))

(when (and (not (display-graphic-p))
           (eq system-type 'darwin))
  (setq interprogram-cut-function   #'my-copy-to-osx
        interprogram-paste-function #'my-paste-from-osx))

#+end_src

** Help :BINDING:

[[https://github.com/Wilfred/helpful][Helpful]] is an alternative to the built-in Emacs help that provides much more contextual information.
It is a bit slow to load so we do need load it explicitely.

#+begin_src emacs-lisp

(setq help-window-select t)             ; Focus new help windows when opened

(bind-key "C-h f"   #'helpful-callable) ; Look up callable
(bind-key "C-h v"   #'helpful-variable) ; Look up variable
(bind-key "C-h k"   #'helpful-key)      ; Look up key
(bind-key "C-c C-d" #'helpful-at-point) ; Look up the current symbol at point
(bind-key "C-h F"   #'helpful-function) ; Look up *F*unctions (excludes macros).
(bind-key "C-h C"   #'helpful-command)  ; Look up *C*ommands.

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Interface")

#+end_src


* Visual


#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** TODO Colours :MODE:TIMER:

A consistent theme for GNU Emacs. The light theme is based on Material colors and the dark theme is based on Nord colors. The theme is based on a set of six faces (only).

#+begin_src lisp

(require 'nano-theme)
(setq nano-fonts-use t) ; Use theme font stack
;;(nano-mode)             ; Recommended settings


(defun my-set-face (face style)
  "Reset FACE and make it inherit STYLE."
  (set-face-attribute face nil
                      :foreground 'unspecified :background 'unspecified
                      :family     'unspecified :slant      'unspecified
                      :weight     'unspecified :height     'unspecified
                      :underline  'unspecified :overline   'unspecified
                      :box        'unspecified :inherit    style))
(my-set-face 'italic 'nano-faded)

#+end_src

We define a set of colours as defined by Paul Tol in his blog [[https://personal.sron.nl/~pault/][]].

#+begin_src emacs-lisp

(setq bright-blue   '"#4477AA"
      bright-cyan   '"#66CCEE"
      bright-green  '"#228833"
      bright-yellow '"#CCBB44"
      bright-red    '"#EE6677"
      bright-purple '"#AA3377"
      bright-grey   '"#BBBBBB")

(setq high-contrast-white  '"#FFFFFF"
      high-contrast-yellow '"#DDAA33"
      high-contrast-red    '"#BB5566"
      high-contrast-blue   '"#004488"
      high-contrast-black  '"#000000")

(setq vibrant-blue    '"#0077BB"
      vibrant-cyan    '"#33BBEE"
      vibrant-teal    '"#009988"
      vibrant-orange  '"#EE7733"
      vibrant-red     '"#CC3311"
      vibrant-magenta '"#EE3377"
      vibrant-gray    '"#BBBBBB")

(setq muted-indigo '"#332288"
      muted-cyan   '"#88CCEE"
      muted-teal   '"#44AA99"
      muted-green  '"#117733"
      muted-olive  '"#999933"
      muted-sand   '"#DDCC77"
      muted-rose   '"#CC6677"
      muted-wine   '"#882255"
      muted-purple '"#AA4499"
      muted-gray   '"#DDDDDD")

(setq medium-contrast-white        '"#FFFFFF"
      medium-contrast-light-yellow '"#EECC66"
      medium-contrast-light-red    '"#EE99AA"
      medium-contrast-light-blue   '"#6699CC"
      medium-contrast-dark-yellow  '"#997700"
      medium-contrast-dark-red     '"#994455"
      medium-contrast-dark-blue    '"#004488"
      medium-contrast-black        '"#000000")

(setq pale-blue   '"#BBCCEE"
      pale-cyan   '"#CCEEFF"
      pale-green  '"#CCDDAA"
      pale-yellow '"#EEEEBB"
      pale-red    '"#FFCCCC"
      pale-gray   '"#DDDDDD")

(setq dark-blue   '"#222255"
      dark-cyan   '"#225555"
      dark-green  '"#225522"
      dark-yellow '"#666633"
      dark-red    '"#663333"
      dark-gray   '"#555555")

(setq light-black  '"#454545"
      light-blue   '"#77AADD"
      light-cyan   '"#99DDFF"
      light-mint   '"#44BB99"
      light-pear   '"#BBCC33"
      light-olive  '"#AAAA00"
      light-yellow '"#EEDD88"
      light-orange '"#EE8866"
      light-pink   '"#FFAABB"
      light-gray   '"#DDDDDD")

(setq almost-black '"#111A1A"
      almost-white '"#FBFAFC"
      almost-blue  '"#4F5565"
      almost-gray  '"#F1F1F1")

#+end_src

#+begin_src emacs-lisp

(defun my-nano-light-muted ()
  (nano-light)
  (my-thin-modeline)
  (set-face-attribute 'nano-critical   nil :foreground muted-rose)
  (set-face-attribute 'nano-critical-i nil :background muted-rose)
  (set-face-attribute 'nano-popout     nil :foreground vibrant-red)
  (set-face-attribute 'nano-popout-i   nil :background vibrant-red)
  (set-face-attribute 'nano-strong     nil :foreground almost-black)
  (set-face-attribute 'nano-strong-i   nil :background almost-black)
  (set-face-attribute 'nano-salient    nil :foreground medium-contrast-light-blue)
  (set-face-attribute 'nano-salient-i  nil :background bright-blue)
  (set-face-attribute 'nano-faded      nil :foreground dark-gray)
  (set-face-attribute 'nano-faded-i    nil :background dark-gray)
  (set-face-attribute 'nano-subtle     nil :foreground light-black)
  (set-face-attribute 'nano-subtle     nil :background almost-gray)
  (set-face-attribute 'nano-subtle-i   nil :foreground almost-gray)
  (set-face-attribute 'nano-subtle-i   nil :background light-black)
  )

(defun my-nano-dark-muted ()
  (nano-dark)
  (my-thin-modeline)
  (set-face-attribute 'nano-critical   nil :foreground muted-rose)
  (set-face-attribute 'nano-critical-i nil :background muted-rose)
  (set-face-attribute 'nano-popout     nil :foreground vibrant-red)
  (set-face-attribute 'nano-popout-i   nil :background vibrant-red)
  (set-face-attribute 'nano-strong     nil :foreground almost-white)
  (set-face-attribute 'nano-strong-i   nil :background almost-white)
  (set-face-attribute 'nano-salient    nil :foreground pale-cyan)
  (set-face-attribute 'nano-salient-i  nil :background pale-cyan)
  (set-face-attribute 'nano-faded      nil :foreground pale-blue)
  (set-face-attribute 'nano-faded-i    nil :background pale-blue)
  (set-face-attribute 'nano-subtle     nil :foreground almost-white)
  (set-face-attribute 'nano-subtle     nil :background almost-blue)
  (set-face-attribute 'nano-subtle-i   nil :foreground almost-blue)
  (set-face-attribute 'nano-subtle-i   nil :background almost-white)
  )

(setq my-current-theme-light t)

(defun my-toggle-theme ()
  (interactive)
  (if my-current-theme-light
      (progn (setq my-current-theme-light nil)
             (my-nano-dark-muted))
    (setq my-current-theme-light t)
    (my-nano-light-muted)))

(bind-key "<f6>" #'my-toggle-theme ergoemacs-override-keymap)

#+end_src

** TODO Fonts :BUGFIX:

This is the font stack we install:

- Default font:  Roboto Mono 14pt Light       [[https://fonts.google.com/specimen/Roboto+Mono][]]
- /Italic font/:   Victor Mono 14pt Semilight   [[https://github.com/rubjo/victor-mono][]]
- *Bold font*:     Roboto Mono 14pt Regular     [[https://fonts.google.com/specimen/Roboto+Mono][]]
- Unicode font:  Inconsolata 16pt Light       [[https://github.com/googlefonts/Inconsolata][]] TODO: Switch to Fira Code?
- Icon font:     Roboto Mono Nerd 12pt Light  [[https://www.nerdfonts.com/][]]
- Serif font:
- math font:

Text excerpt using a /gorgeous/ and true italic font (Victor Mono),
chosen to really *stand out* from the default font (Roboto Mono).
┌─────────────────────────────────────────────────────────────────┐
│  The quick brown fox jumps over the lazy dog │
│  /The quick brown fox jumps over the lazy dog/     ┼─ Victor Mono Italic
│  *The quick brown fox jumps over the lazy dog* ├─ Inconsolata
└──┼────────────────────────────────────────────┼─────────────────┘
Roboto Mono Nerd            Roboto Mono

Note that the Victor Mono needs to be hacked such as to have the same line height as Roboto Mono. To do that, you can use the [[https://github.com/source-foundry/font-line][font-line]] utility (github.com/source-foundry/font-line): copy all the italic faces from the Victor Mono ttf file into a directoy and type: =font-line percent 10 *.ttf=. This will create a new set of files that you can use to replace the Victor Mono italic faces on your system.


#+begin_src lisp

(set-face-attribute 'default nil
                    :family "Roboto Mono"
                    :weight 'light
                    :height 140)

(set-face-attribute 'bold nil
                    :family "Roboto Mono"
                    :weight 'regular)

(set-face-attribute 'italic nil
                    :family "Victor Mono"
                    :weight 'semilight
                    :slant 'italic
                    )

;; For now we use the Emacs "standard" unicode font

;; (set-fontset-font t 'unicode
;;                   (font-spec :name "Inconsolata Light"
;;                              :size 16) nil)


(set-fontset-font t '(#xe000 . #xffdd) "RobotoMono Nerd Font")

(set-fontset-font t 'emoji "Symbola")

#+end_src

** Typography and layout

#+begin_src emacs-lisp

(setq-default fill-column 100                         ; Default line width
              sentence-end-double-space nil           ; Use a single space after dots
              bidi-paragraph-direction 'left-to-right ; Faster
              truncate-string-ellipsis "…")           ; Nicer ellipsis

#+end_src


#+begin_src emacs-lisp

(use-package visual-fill-column
  :ensure adaptive-wrap
  :custom (visual-fill-column-center-text t)
  :hook  (((LaTeX-mode org-mode) . visual-fill-column-mode)
          ((LaTeX-mode org-mode) . adaptive-wrap-prefix-mode)
          )
  )

#+end_src
Changing the symbol for truncation (…) and wrap (↩).

#+begin_src emacs-lisp

(require 'nano-theme)

;; Nicer glyphs for continuation and wrap
(set-display-table-slot standard-display-table
                        'truncation (make-glyph-code ?… 'nano-faded))

(defface wrap-symbol-face
  '((t (:family "Fira Code"
                :inherit nano-faded)))
  "Specific face for wrap symbol")

(set-display-table-slot standard-display-table
                        'wrap (make-glyph-code ?↩ 'wrap-symbol-face))

#+end_src

Fix a bug on OSX in term mode & zsh (spurious "%" after each command)

#+begin_src emacs-lisp

(when (eq system-type 'darwin)
  (add-hook 'term-mode-hook
            (lambda ()
              (setq buffer-display-table (make-display-table)))))

#+end_src

Make sure underline is positioned at the very bottom.

#+begin_src emacs-lisp

(setq x-underline-at-descent-line nil
      x-use-underline-position-properties t
      underline-minimum-offset 10)

#+end_src
** Benchmark

#+begin_src emacs-lisp

(my-report-time "Visual")

#+end_src


* Editing

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** Default mode :HOOK:MODE:

Default & initial mode is text.

#+begin_src emacs-lisp

(setq-default initial-major-mode 'text-mode   ; Initial mode is text
              default-major-mode 'text-mode)  ; Default mode is text

#+end_src

Visual line mode for prog and text modes

#+begin_src emacs-lisp

(add-hook 'text-mode-hook 'visual-line-mode)
(add-hook 'prog-mode-hook 'visual-line-mode)

#+end_src

** Tabulations

No tabulation, ever.

#+begin_src emacs-lisp

(setq-default indent-tabs-mode nil        ; Stop using tabs to indent
              tab-always-indent 'complete ; Indent first then try completions
              tab-width 4)                ; Smaller width for tab characters

;; Let Emacs guess Python indent silently
(setq python-indent-guess-indent-offset t
      python-indent-guess-indent-offset-verbose nil)

#+end_src

** Parenthesis :MODE:

We enable paren mode for highlighting matching parenthesis and rainbow-delimiters in order to be able to visually distinguish delimiters of different depths.

#+begin_src emacs-lisp

(use-package emacs
  :init (show-paren-mode t); Matches parentheses and such in every mode
  )

(use-package rainbow-delimiters
  :hook ((prog-mode org-mode LaTeX-mode) . rainbow-delimiters-mode)
  )

#+end_src

 We need a small helper to distinguish between words and special characters  which should be treated differently.


#+begin_src emacs-lisp

(defvar my-backward-special-characters '".,:;!?(){}[]~@#$%^&*<>_=-+\\\"' \n\t/`")


(defun my-backward-word ()
 " muW4e want to go back by words in a smart way"
  (interactive)
    (if (string-search (string (preceding-char)) my-backward-special-characters)
      (backward-char)
          (backward-word))
)

#+end_src

#+begin_src emacs-lisp

  (use-package puni
    :hook ((text-mode prog-mode LaTeX-mode org-mode eval-expression-minibuffer-setup haskell-interactive-mode) . puni-mode)
    :bind (:map puni-mode-map
                ("C-<right>" . puni-slurp-forward)
                ("C-<left>"  . puni-barf-forward)
                ("M-<left>"  . puni-slurp-backward)
                ("M-<right>" . puni-barf-backward)
                ("C-x C-d"   . puni-splice)
                ("M-i"       . puni-squeeze)
                ("C-<up>"    . my-puni-rewrap)
                ("<left>"    . my-backward-word)
  ))

  (defun my-puni-rewrap ()
    (interactive)
    (let*((next-delimiters (completing-read
                            "Rewrap the sexp at point with: "
                            '("(...)" "{...}" "[...]" "\\langle...\\rangle" "\\|...\\|"  "<...>" "\\left(...\\right)" )
                            nil
                            t
                            ))
          (opening-del "A"))
      (puni-squeeze)
      (insert (car (split-string next-delimiters "\\.+" t)))
      (yank)
      (insert (car (cdr (split-string next-delimiters "\\.+" t))))))

#+end_src

** Spell-checking

We set up multi-language lazy flyspell checks in text modes.

Now we can set up flyspell and guess-language.

#+begin_src emacs-lisp

(use-package flyspell
  :hook (text-mode org-mode latex-mode mu4e-compose-mode)
  :config
  (setq ispell-program-name "aspell")
  (setq ispell-list-command "--list")
  (setq ispell-alternate-dictionary "/usr/share/dict/en_GB.txt")
)

;; (use-package flyspell-lazy
;;   :after flyspell
;;   :hook (text-mode org-mode latex-mode mu4e-compose-mode))

(use-package flyspell-correct
  :after flyspell
  :bind (:map ergoemacs-override-keymap ("M-t" . flyspell-correct-wrapper)))

;; (use-package flyspell-correct-popup
;;   :after flyspell-correct)

(use-package guess-language
  :hook (mu4e-compose-mode)
  :config
(setq guess-language-langcodes '((en . ("en_GB" "English"))
                                 (de . ("de_DE" "German")))
      guess-language-languages '(en de)
      guess-language-min-paragraph-length 45))

(use-package mu4e
  :after flyspell
  :init (setq flyspell-generic-check-word-predicate  'mail-mode-flyspell-verify))
#+end_src

** Imenu list

Imenu setup

#+begin_src emacs-lisp

(require 'imenu-list)

(setq-default imenu-list-position 'left
              imenu-max-item-length 1000)

#+end_src
** Highlighting :MODE:INACTIVE:

Highlighting of the current line (native mode)

#+begin_src emacs-lisp

;; (require 'hl-line)

;; (global-hl-line-mode)

#+end_src

** PDF Tools

For retina display (OSX)

#+begin_src emacs-lisp
;; (require 'pdf-tools)

(add-hook 'doc-view-mode-hook 'pdf-tools-install)

(setq-default pdf-view-use-scaling t
              pdf-view-use-imagemagick nil)

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Editing")

#+end_src


* Completion

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** Cape :MODE:

A completion framework on steroids.
It will need some tweaking in the future.
Starting point is from [[https://kristofferbalintona.me/posts/202203130102/]]
#+begin_src emacs-lisp
(use-package cape
  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("C-c p p" . completion-at-point) ;; capf
         ("C-c p t" . complete-tag)        ;; etags
         ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
         ("C-c p h" . cape-history)
         ("C-c p f" . cape-file)
         ("C-c p k" . cape-keyword)
         ("C-c p s" . cape-symbol)
         ("C-c p a" . cape-abbrev)
         ("C-c p i" . cape-ispell)
         ("C-c p l" . cape-line)
         ("C-c p w" . cape-dict)
         ("C-c p \\" . cape-tex)
         ("C-c p _" . cape-tex)
         ("C-c p ^" . cape-tex)
         ("C-c p &" . cape-sgml)
         ("C-c p r" . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-history)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  (add-to-list 'completion-at-point-functions #'cape-tex)
  (add-to-list 'completion-at-point-functions #'cape-abbrev)
  ;; (add-to-list 'completion-at-point-functions #'cape-dict)
  (add-to-list 'completion-at-point-functions #'cape-symbol)
  (add-to-list 'completion-at-point-functions #'cape-ispell)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
  (defun my-cape-capf-setup-latex ()
    (require 'company-auctex)
    (require 'company-reftex)
    (let ((result))
      (dolist (element (list
                        ;; First add `company-yasnippet'
                        (cape-company-to-capf #'company-yasnippet)
                        ;; Then add `cape-tex'
                        #'cape-tex
                        ;; Then add `company-auctex' in the order it adds its
                        ;; backends.
                        (cape-company-to-capf #'company-auctex-bibs)
                        (cape-company-to-capf #'company-auctex-labels)
                        (cape-company-to-capf #'company-reftex-citations)
                        (cape-company-to-capf #'company-reftex-labels)
                        (cape-company-to-capf
                        (apply-partially #'company--multi-backend-adapter
                                          '(company-auctex-macros
                                            company-auctex-symbols
                                            company-auctex-environments
                                            company-reftex-citations
                                            company-reftex-labels))))
                       result)
        (add-to-list 'completion-at-point-functions element))))
  :hook (LaTeX-mode . my-cape-capf-setup-latex)
  :custom
  (cape-dabbrev-min-length 3))


#+end_src

** Corfu :MODE:BINDING:

[[https://github.com/minad/corfu][Corfu]] enhances completion at point with a small completion popup.
The following code is inspired by [[https://kristofferbalintona.me/posts/202202270056/]]


#+begin_src emacs-lisp
(use-package corfu
  :straight (corfu :files (:defaults "extensions/*")
                   :includes (corfu-info corfu-history corfu-popupinfo))
  ;; :hook (lsp-completion-mode . my-corfu-setup-lsp) ; Use corfu for lsp completion
  :bind (:map corfu-map
              ("<escape>" . corfu-quit)
              ("<return>" . corfu-insert)
              ("M-d" . corfu-show-documentation)
              ("M-l" . corfu-show-location))
  :custom
  ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
  ;; want to perform completion
  (tab-always-indent 'complete)       ; Allows for indetation AND completion on <tab>.
  (completion-cycle-threshold nil)    ; Always show candidates in menu
  (corfu-auto t)                      ; Enable autocompletion
  (corfu-auto-prefix 2)               ; Minimum length of prefix before completion.
  (corfu-auto-delay 20)               ; Delay before auto-completion shows up
  (corfu-min-width 80)                ; Minimal width of corfu popup.
  (corfu-max-width corfu-min-width)   ; Always have the same width
  (corfu-count 10)                    ; Maximal number of candidates.
  (corfu-scroll-margin 5)             ; Use scroll margins
  (read-extended-command-predicate
 #'command-completion-default-include-p) ; Hide corfu commands from  being used via M-x

  (corfu-cycle t)
  (completion-cycle-threshold 3)      ; If there are only 3 candidates, no poup is shown.
  (corfu-quit-at-boundary 'seperator) ; Quits at boundary unless a seperator is used.
  (corfu-separator ?\s)               ; Use space
  (corfu-quit-no-match 'separator)    ; Don't quit if there is `corfu-separator' inserted
  (corfu-preview-current 'insert)     ; Preview first candidate. Insert on input if only one
  (corfu-preselect-first t)           ; Preselect first candidate
  (corfu-popupinfo-delay 0.1)           ; Show some documentation about the candidates.
  (add-to-list 'savehist-additional-variables 'corfu-history)
  ;; Other
  (corfu-echo-documentation nil)      ; Already use corfu-doc
  (lsp-completion-provider :none)     ; Use corfu instead for lsp completions
  :init
  (global-corfu-mode)
  (corfu-popupinfo-mode)
  (corfu-history-mode)
  :hook (lsp-completion-mode . my-corfu-setup-lsp)
  :config
  ;; Setup lsp to use corfu for lsp completion
  (defun my-corfu-setup-lsp ()
    "Use orderless completion style with lsp-capf instead of the
default lsp-passthrough."
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless)))
  )
#+end_src

** Orderless :MODE:

Allow completion based on space-separated tokens, out of order.
Config inspired by [[https://kristofferbalintona.me/posts/202202211546/][https://kristofferbalintona.me/posts/202202211546/]]

#+begin_src emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless))
  (completion-category-defaults nil) ; I want to be in control!
  (orderless-component-separator 'orderless-escapable-split-on-space)
  (orderless-matching-styles
   '(orderless-prefixes
     orderless-literal
     orderless-regexp
     orderless-initialism
     ))
  (orderless-style-dispatchers
    '(orderless-affix-dispatch))
  (orderless-affix-dispatch-alist
   '((33 . orderless-without-literal) ;; "!" at start/end excludes this word from the search
     (37 . char-fold-to-regexp)       ;; "%" at start/end ignores inflections of the word
     (44 . orderless-initialism)      ;; "," at start/end activates initalism
     (61 . orderless-literal)         ;; "=" at start/end makes the word match literally
     (126 . orderless-flex)))         ;; "~" at start/end activate flexible matching.
  (read-file-name-completion-ignore-case t)
  (read-buffer-completion-ignore-case t)
  (completion-ignore-case t)
  (completion-category-overrides '((file (styles . (partial-completion)))))
  )
#+end_src

** LSP-Mode

A few more niceties for our completion setup are provided by using the lsp-mode.
It has a nice and quite useful wiki [[https://emacs-lsp.github.io/lsp-mode/][]]. The following config is derived from Tony Zorman's settings.

#+begin_src emacs-lisp

(use-package lsp-mode
  :preface
  (defun my-lsp-shutdown-last-workspaces ()
    "Shut down the `lsp--last-active-workspaces'."
    (interactive)
    (mapc (lambda (ws)
            (lsp--warn "Stopping %s" (lsp--workspace-print ws))
            (with-lsp-workspace ws (lsp--shutdown-workspace)))
          lsp--last-active-workspaces))
  :hook
  ((latex-mode LaTeX-mode) . lsp-deferred)
  (lsp-mode . (lambda ()
                (setq-local read-process-output-max (* 1024 1024))))
  (lsp-completion-mode ; for corfu compatibility
   . (lambda ()
       (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
             '(flex))))
  :commands (lsp-deferred lsp)
  :bind (:map lsp-mode-map
              ("C-c l i" . lsp-ui-imenu)
              ("C-c C-r" . lsp-execute-code-action)
              ("C-c C-d" . lsp-ui-doc-show)
              ("C-c l s" . (lambda ()
                             (interactive)
                             (lsp-ui-sideline-enable (not lsp-ui-sideline-mode))))
              ("C-c h"   . (lambda ()
                             (interactive)
                             (when lsp-lens-mode
                               (lsp-lens-mode -1))
                             (lsp-lens-hide)))
              ("C-c d"   . (lambda ()
                             (interactive)
                             (when (not lsp-lens-mode)
                               (lsp-lens-mode 1))
                             (lsp-lens-show))))
  :custom
  (lsp-use-plists t)
  (lsp-completion-provider :none)       ; Corfu
  (lsp-keymap-prefix "C-c l")
  (lsp-idle-delay 0.6)
  ;; Disable things I don't care about
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-modeline-code-actions-enable nil)
  (lsp-modeline-diagnostics-enable nil)
  (lsp-enable-symbol-highlighting nil)
  )

(use-package lsp-ui
  :after lsp-mode
  :commands lsp-ui-mode
  :custom
  (lsp-ui-doc-show-with-mouse nil)
  (lsp-ui-sideline-enable nil)
  (lsp-ui-peek-always-show t)
  (lsp-ui-sideline-show-hover t)
  )

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Completion")

#+end_src


* Minibuffer & Modeline

#+begin_src emacs-lisp

(setq my-section-start-time (current-time))

#+end_src

** Consult :BINDING:

We replace some of emacs functions with their consult equivalent

#+begin_src emacs-lisp

(require 'consult)

(setq consult-preview-key nil) ; No live preview

(bind-key "C-x C-r" #'consult-recent-file)
(bind-key "C-x h"   #'consult-outline)
(bind-key "C-x b"   #'consult-buffer)
(bind-key "C-c h"   #'consult-history)
;; (bind-key "M-:"     #'consult-complex-command)

#+end_src

For the [[help:consult-goto-line][consult-goto-line]] and ~consult-line~ commands, we define our owns with live preview (independently of the [[help:consult-preview-key][consult-preview-key]])

#+name: my-consult-line
#+begin_src emacs-lisp

(defun my-consult-line ()
  "Consult line with live preview"

  (interactive)
  (let ((consult-preview-key 'any)
        (mini-frame-resize 'grow-only)) ;; !! Important
    (consult-line)))

(bind-key "C-s"   #'my-consult-line)

#+end_src
#+name: my-consult-goto-line
#+begin_src emacs-lisp

(defun my-consult-goto-line ()
  "Consult goto line with live preview"

  (interactive)
  (let ((consult-preview-key 'any))
    (consult-goto-line)))

(bind-key "M-g g"   #'my-consult-goto-line)
(bind-key "M-g M-g" #'my-consult-goto-line)

#+end_src
** TODO Embark
The following code is taken from the literate config of [[https://protesilaos.com/emacs/dotemacs][Protesilaos Stavrou]].

#+begin_src emacs-lisp
(use-package embark
  :bind (("C-." . embark-act)
         :map minibuffer-local-completion-map
         ("C-." . embark-act)
         ("C->" . embark-become)
         :map embark-region-map
         ("a" . align-regexp)
         ("C" . capitalize-dwim)
         ("SPC" . whitespace-cleanup-region)
         ("RET" . fill-region)
         :map embark-symbol-map
         ("." . embark-find-definition)
         ("k" . describe-keymap)
         )
  :config
  (setq prefix-help-command #'embark-prefix-help-command)
  (setq embark-quit-after-action t)     ; XXX: Read the doc string!
  (setq embark-cycle-key (kbd "M-."))   ; see the `embark-act' key
  (setq embark-confirm-act-all nil)
  (setq embark-indicators
        '(embark-mixed-indicator
          embark-highlight-indicator))
  ;; NOTE 2021-07-31: The mixed indicator starts out with a minimal view
  ;; and then pops up the verbose buffer, so those variables matter.
  (setq embark-verbose-indicator-excluded-actions
        '("\\`customize-" "\\(local\\|global\\)-set-key"
          set-variable embark-cycle embark-keymap-help embark-isearch))
  (setq embark-verbose-indicator-buffer-sections
        `(target "\n" shadowed-targets " " cycle "\n" bindings))
  (setq embark-mixed-indicator-both nil)
  (setq embark-mixed-indicator-delay 1.5)
  ;;  NOTE 2021-07-28: This is used when `embark-indicator' is set to
  ;;  `embark-mixed-indicator' or `embark-verbose-indicator'.  We can
  ;;  specify the window parameters here, but I prefer to do that in my
  ;;  `display-buffer-alist' (search this document) because it is easier
  ;;  to keep track of all my rules in one place.
  (setq embark-verbose-indicator-display-action nil)
  )
#+end_src

** TODO Vertico :ADVICE:HOOK:BINDING:MODE:FACE:


[[https://github.com/minad/vertico][Vertico]] provides a performant and minimalistic vertical completion UI based on the default completion system but aims to be highly flexible, extensible and modular.

For informations on completion-at-point and completion-in-region see:
https://github.com/minad/vertico#completion-at-point-and-completion-in-region
The pointer for the currrent line is derived from: [[
https://github.com/minad/vertico/wiki#prefix-current-candidate-with-arrow]]

There is a hacky code which replaces the numbers in front of the matches with white spaces.
However this assumes as of now that these are one-digit numbers.

#+begin_src emacs-lisp
(use-package vertico
  :demand t                             ; Otherwise won't get loaded immediately
  :straight (vertico :files (:defaults "extensions/*") ; Special recipe to load extensions
                     :includes (vertico-indexed
                                vertico-flat
                                vertico-grid
                                vertico-mouse
                                vertico-quick
                                vertico-buffer
                                vertico-repeat
                                vertico-reverse
                                vertico-directory
                                vertico-multiform
                                vertico-unobtrusive
                                ))
  :bind (("M-." . vertico-repeat)
         :map vertico-map
         ("<tab>" . vertico-insert)
         ("<escape>" . minibuffer-keyboard-quit)
         ("?" . minibuffer-completion-help)
         ( "<backtab>" . minibuffer-complete)
         )
  :hook ((rfn-eshadow-update-overlay . vertico-directory-tidy) ; Clean up file path when typing
         (minibuffer-setup . vertico-repeat-save) ; Make sure vertico state is saved
         )
  :custom
  (vertico-count 10)             ; At most 10 entries are shown
  (vertico-count-format nil)     ; But we do not count them
  (vertico-resize nil)           ; The size of the minbuffer is fixed
  (vertico-cycle t)
  ;; Extensions
  (vertico-grid-separator "       ")
  (vertico-grid-lookahead 50)
  (vertico-buffer-display-action '(display-buffer-reuse-window))
  (vertico-multiform-categories
   '((file grid)
     (consult-grep buffer)
     )
   )
  (completion-in-region-function
   (lambda (&rest args)
     (apply (if vertico-mode
                #'consult-completion-in-region
              #'completion--in-region)
            args)))
  :init
  :config
  (vertico-mode)
  ;; Extensions
  (vertico-multiform-mode)
  ;; Prefix the current candidate with “ ”. From
  ;; https://github.com/minad/vertico/wiki#prefix-current-candidate-with-arrow
  (advice-add #'vertico--format-candidate :around
              (lambda (orig cand prefix suffix index _start)
                (setq cand (funcall orig cand prefix suffix index _start))
                ;; (string-match "[[:digit:]]+" cand)
                ;; ;; We replace (for now) one digit with a properly styled white space.
                ;; (setq cand (replace-match (if (= vertico--index index)
                ;;      (propertize " " 'face 'vertico-current)
                ;;    t" ") nil t cand)) ; Change to multi-digit numbers
                (concat
                 (if (= vertico--index index)
                     (propertize " " 'face 'vertico-current)
                   t"  ")
                 cand)))
  :custom-face
  (vertico-group-separator ((t (:strike-through t))))
  (vertico-current ((t (:inherit 'nano-strong 'nano-subtle))))
  (completions-first-difference ((t (:inherit 'nano-default))))
  )
#+end_src

** Marginalia :MODE:

See https://kristofferbalintona.me/posts/vertico-marginalia-all-the-icons-completion-and-orderless/#vertico
We do not configure marginalia to much. Text on the right. Trying to not show file ages. That's it.

#+begin_src emacs-lisp

(defun vertico--prompt-selection ()
  "Highlight the prompt"

  (let ((inhibit-modification-hooks t))
    (set-text-properties (minibuffer-prompt-end) (point-max)
                         '(face (nano-strong nano-salient)))))

(use-package marginalia
  :init (marginalia-mode)
  :bind (:map minibuffer-local-map
              ("M-A" . marginalia-cycle))
  :custom
  (marginalia--ellipsis "…")      ; Nicer ellipsis
  (marginalia-align 'right)       ; right alignment
  (marginalia-align-offset -1)    ; one space on the right
  (marginalia-max-relative-age 0) ; Supresses showing the file age
  )
#+end_src

See https://github.com/minad/vertico/issues/145
To enhance the visuals, we integrate all the icons into marginalia

#+begin_src emacs-lisp

(defun minibuffer-vertico-setup ()

  (setq truncate-lines t)
  (setq completion-in-region-function
        (if vertico-mode
            #'consult-completion-in-region
          #'completion--in-region)))

(add-hook 'vertico-mode-hook #'minibuffer-vertico-setup)
(add-hook 'minibuffer-setup-hook #'minibuffer-vertico-setup)

(use-package all-the-icons-completion
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :init
  (all-the-icons-completion-mode))
#+end_src

** Modeline :HOOK:MODE:FACE:

We're using [[https://github.com/rougier/nano-modeline][nano-modeline]] and modify some settings here.

#+begin_src emacs-lisp

(require 'nano-theme)
(require 'nano-modeline)

(setq nano-modeline-prefix 'icon)
(setq nano-modeline-prefix-padding 2)

(defun my-face-foreground (face &optional frame inherit)
  (or (face-foreground face frame inherit) 'unspecified))

(defun my-face-background (face &optional frame inherit)
  (or (face-background face frame inherit) 'unspecified))

(set-face-attribute 'header-line nil)
(set-face-attribute 'mode-line nil
                    :foreground (my-face-foreground 'nano-subtle-i)
                    :background (my-face-foreground 'nano-subtle-i)
                    :inherit nil
                    :box nil)

(set-face-attribute 'mode-line-inactive nil
                    :foreground (my-face-foreground 'nano-subtle-i)
                    :background (my-face-foreground 'nano-subtle-i)
                    :inherit nil
                    :box nil)

(set-face-attribute 'nano-modeline-active nil
                    :underline (my-face-foreground 'nano-default-i)
                    :background (my-face-background 'nano-subtle)
                    :inherit '(nano-default-i)
                    :box nil)

(set-face-attribute 'nano-modeline-inactive nil
                    :foreground 'unspecified
                    :underline (my-face-foreground 'nano-default-i)
                    :background (my-face-background 'nano-subtle)
                    :box nil)

(set-face-attribute 'nano-modeline-active-name nil
                    :foreground "black"
                    :inherit '(nano-modeline-active nano-strong))
(set-face-attribute 'nano-modeline-active-primary nil
                    :inherit '(nano-modeline-active))
(set-face-attribute 'nano-modeline-active-secondary nil
                    :inherit '(nano-faded nano-modeline-active))

(set-face-attribute 'nano-modeline-active-status-RW nil
                    :inherit '(nano-faded-i nano-strong nano-modeline-active))
(set-face-attribute 'nano-modeline-active-status-** nil
                    :inherit '(nano-popout-i nano-strong nano-modeline-active))
(set-face-attribute 'nano-modeline-active-status-RO nil
                    :inherit '(nano-default-i nano-strong nano-modeline-active))

(set-face-attribute 'nano-modeline-inactive-name nil
                    :inherit '(nano-faded nano-strong
                                          nano-modeline-inactive))
(set-face-attribute 'nano-modeline-inactive-primary nil
                    :inherit '(nano-faded nano-modeline-inactive))

(set-face-attribute 'nano-modeline-inactive-secondary nil
                    :inherit '(nano-faded nano-modeline-inactive))
(set-face-attribute 'nano-modeline-inactive-status-RW nil
                    :inherit '(nano-modeline-inactive-secondary))
(set-face-attribute 'nano-modeline-inactive-status-** nil
                    :inherit '(nano-modeline-inactive-secondary))
(set-face-attribute 'nano-modeline-inactive-status-RO nil
                    :inherit '(nano-modeline-inactive-secondary))

#+end_src

We set a thin modeline

#+begin_src emacs-lisp

(defun my-thin-modeline ()
  "Transform the modeline in a thin faded line"

  (nano-modeline-face-clear 'mode-line)
  (nano-modeline-face-clear 'mode-line-inactive)
  (setq mode-line-format (list ""))
  (setq-default mode-line-format (list ""))
  (set-face-attribute 'mode-line nil
                      :box nil
                      :inherit nil
                      :foreground (my-face-background 'nano-subtle)
                      :background (my-face-background 'nano-subtle)
                      :height 0.1)
  (set-face-attribute 'mode-line-inactive nil
                      :box nil
                      :inherit nil
                      :foreground (my-face-background 'nano-subtle)
                      :background (my-face-background 'nano-subtle)
                      :height 0.1))

(add-hook 'nano-modeline-mode-hook #'my-thin-modeline)

#+end_src

We start the nano modeline.
#+begin_src emacs-lisp

(nano-modeline-mode 1)

#+end_src

** Minibuffer :MODE:HOOK:

Headerline (fake) for minibuffer

#+begin_src emacs-lisp
(require 'minibuffer-header)

(setq minibuffer-header-show-message t
      minibuffer-header-hide-prompt t
      minibuffer-header-default-message "")

(set-face-attribute 'minibuffer-header-face nil
                    :inherit 'nano-subtle
                    :extend t)
(set-face-attribute 'minibuffer-header-message-face nil
                    :inherit '(nano-subtle nano-faded)
                    :extend t)
#+end_src

This should be an advice but it is simpler to rewrite the function

#+begin_src emacs-lisp

(defun my-minibuffer-header-format (prompt)
  "Minibuffer header"

  (let* ((prompt (replace-regexp-in-string "[: \t]*$" "" prompt))
         (depth (minibuffer-depth))
         (prompt (cond ((string= prompt "M-x") "Extended command")
                       ((string= prompt "Function") "Help on function")
                       ((string= prompt "Callable") "Help on function or macro")
                       ((string= prompt "Variable") "Help on variable")
                       ((string= prompt "Command") "Help on command")
                       ((string= prompt "Eval") "Evaluate lisp expression")
                       (t prompt))))
    (concat
     (propertize (format " %d " depth)
                 'face `(:inherit (nano-salient-i nano-strong)
                                  :extend t))
     (propertize " "
                 'face 'nano-subtle 'display `(raise ,nano-modeline-space-top))

     (propertize prompt
                 'face `(:inherit (nano-subtle nano-strong nano-salient)
                                  :extend t))
     (propertize " "
                 'face 'nano-subtle 'display `(raise ,nano-modeline-space-bottom))
     (propertize "\n" 'face 'highlight)
     (propertize " " 'face 'highlight
                 'display `(raise ,nano-modeline-space-top))
     (propertize "︎︎" 'face '(:inherit (nano-salient nano-strong)))
     (propertize " " 'face 'highlight
                 'display `(raise ,nano-modeline-space-bottom)))))

(setq minibuffer-header-format #'my-minibuffer-header-format)

#+end_src

Activate minibuffer header

#+begin_src emacs-lisp

(minibuffer-header-mode)

#+end_src

Some styling setting for the minibuffer

#+begin_src emacs-lisp

(defun my-minibuffer-setup ()

  (set-window-margins nil 0 0)
  (set-fringe-style '(0 . 0))
  (cursor-intangible-mode t)
  (face-remap-add-relative 'default :inherit 'highlight))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup)

#+end_src

Showing key binding for the current command

#+begin_src emacs-lisp

;; Code from https://stackoverflow.com/questions/965263
(defun my-lookup-function (keymap func)
  (let ((all-bindings (where-is-internal (if (symbolp func)
                                             func
                                           (cl-first func))
                                         keymap))
        keys key-bindings)
    (dolist (binding all-bindings)
      (when (and (vectorp binding)
                 (integerp (aref binding 0)))
        (push binding key-bindings)))
    (push (mapconcat #'key-description key-bindings " or ") keys)
    (car keys)))


(defun my-minibuffer-show-last-command-setup ()
  (setq minibuffer-header-default-message
        (my-lookup-function (current-global-map) this-command)))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-show-last-command-setup)

(defun my-minibuffer-show-last-command-exit ()
  (setq minibuffer-header-default-message ""))
(add-hook 'minibuffer-exit-hook #'my-minibuffer-show-last-command-exit)

#+end_src



Vertico will disable truncate lines when point is too far on the right. Problem is that it'll mess up with our fake headerline. We thus rewrite here the function to have truncate lines always on.

#+begin_src emacs-lisp

(defun my-vertico--resize-window (height)
  "Resize active minibuffer window to HEIGHT."
  ;;  (setq-local truncate-lines (< (point) (* 0.8 (vertico--window-width)))
  (setq-local truncate-lines t
              resize-mini-windows 'grow-only
              max-mini-window-height 1.0)
  (unless (frame-root-window-p (active-minibuffer-window))
    (unless vertico-resize
      (setq height (max height vertico-count)))
    (let* ((window-resize-pixelwise t)
           (dp (- (max (cdr (window-text-pixel-size))
                       (* (default-line-height) (1+ height)))
                  (window-pixel-height))))
      (when (or (and (> dp 0) (/= height 0))
                (and (< dp 0) (eq vertico-resize t)))
        (window-resize nil dp nil nil 'pixelwise)))))

(advice-add #'vertico--resize-window :override #'my-vertico--resize-window)

#+end_src

No prompt editing and recursive minibuffer

#+begin_src emacs-lisp

(setq minibuffer-prompt-properties '(read-only t
                                               cursor-intangible t
                                               face minibuffer-prompt)
      enable-recursive-minibuffers t)

#+end_src

** Miniframe :MODE:FACE:BUGFIX:

#+begin_src emacs-lisp

(require 'mini-frame)

(defun auto-toggle-top-bottom ()
  (if (> (count-screen-lines (window-start) (point)) (/ (count-screen-lines (window-start) (window-end)) 2))
      'bottom
    'top))

;; (defcustom my-minibuffer-position 'top
;;   "Minibuffer position, one of 'top or 'bottom"
;;   :type '(choice (const :tag "Top"    top)
;;                  (const :tag "Bottom" bottom))
;;   :group 'nano-minibuffer)


(defun my-minibuffer--frame-parameters ()
  "Compute minibuffer frame size and position."

  ;; Quite precise computation to align the minibuffer and the
  ;; modeline when they are both at top position
  (let* ((edges (window-pixel-edges)) ;; (left top right bottom)
         (body-edges (window-body-pixel-edges)) ;; (left top right bottom)
         (left (nth 0 edges)) ;; Take margins into account
         (top (nth 1 edges)) ;; Drop header line
         (right (nth 2 edges)) ;; Take margins into account
         (bottom (nth 3 body-edges)) ;; Drop header line
         (left (if (eq left-fringe-width 0)
                   left
                 (- left (frame-parameter nil 'left-fringe))))
         (right (nth 2 edges))
         (right (if (eq right-fringe-width 0)
                    right
                  (+ right (frame-parameter nil 'right-fringe))))
         (border 1)
         (width (- right left (* 1 border)))

         ;; Window divider mode
         (width (- width (if (and (bound-and-true-p window-divider-mode)
                                  (or (eq window-divider-default-places 'right-only)
                                      (eq window-divider-default-places t))
                                  (window-in-direction 'right (selected-window)))
                             window-divider-default-right-width
                           0)))
         (y (- top border)))

    (append `((left-fringe . 0)
              (right-fringe . 0)
              (user-position . t)
              (foreground-color . ,(face-foreground 'highlight nil 'default))
              (background-color . ,(face-background 'highlight nil 'default)))
            (cond ((and (eq (auto-toggle-top-bottom) 'bottom))
                   `((top . -1)
                     (left . 0)
                     (width . 1.0)
                     (child-frame-border-width . 0)
                     (internal-border-width . 0)))
                  (t
                   `((left . ,(- left border))
                     (top . ,y)

                     (width . (text-pixels . ,width))
                     (child-frame-border-width . ,border)
                     (internal-border-width . 0)))))))

(set-face-background 'child-frame-border (face-foreground 'nano-faded))
(setq mini-frame-default-height 3)
(setq mini-frame-create-lazy t)
(setq mini-frame-show-parameters 'my-minibuffer--frame-parameters)
(setq mini-frame-ignore-commands
      '("edebug-eval-expression" debugger-eval-expression))
(setq mini-frame-internal-border-color (face-foreground 'nano-faded))

(setq mini-frame-resize-min-height 3)
(setq mini-frame-resize t)
;; (setq mini-frame-resize 'grow-only)
;; (setq mini-frame-default-height (+ 1 vertico-count))
;; (setq mini-frame-resize-height (+ 1 vertico-count))
;; (setq mini-frame-resize nil)

#+end_src

Mini-frame mode ON

#+begin_src emacs-lisp

(mini-frame-mode 1)

#+end_src


More a hack than a fix but the code below improve the mini-frame resize by
setting position explicity. CURRENTLY INACTIVE

#+begin_src emacs-lisp

(defun my-mini-frame--resize-mini-frame (frame)
  "Resize FRAME vertically only.
This function used as value for `resize-mini-frames' variable."
  (funcall mini-frame--fit-frame-function
           frame
           mini-frame-resize-max-height
           (if (eq mini-frame-resize 'grow-only)
               (max (frame-parameter frame 'height)
                    mini-frame-resize-min-height)
             mini-frame-resize-min-height)
           ;; A max-width must be included to work around a bug in Emacs which
           ;; causes wrapping to not be taken into account in some situations
           ;; https://debbugs.gnu.org/cgi/bugreport.cgi?bug=56102
           (window-body-width)
           nil
           'vertically)

  (if (eq auto-toggle-top-bottom 'top)
      (modify-frame-parameters  mini-frame-completions-frame `((top . 0)))
    (modify-frame-parameters  mini-frame-completions-frame `((top . (- 1))))))

#+end_src

** Benchmark

#+begin_src emacs-lisp

(my-report-time "Minibuffer/Modeline")

#+end_src



* Mail :DEFER:
:PROPERTIES:
:header-args:emacs-lisp: :prologue "(with-eval-after-load 'mu4e" :epilogue ")"
:END:

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** Setup :PERSONAL:BINDING:

Mu4e doesn't come with an autoload function, we declare it here.

#+begin_src emacs-lisp :prologue "" :epilogue ""

(autoload 'mu4e
  "/usr/share/emacs/site-lisp/mu4e/mu4e.el"
  "Start mu4e daemon and show its main window." t)

#+end_src

# Lots of options. Make sure to adapt paths to your system.

#+begin_src emacs-lisp
(setq mu4e-mu-binary "/usr/bin/mu"
      mu4e-maildir "~/Documents/.mails"
      mu4e-attachment-dir "~/Downloads"
      mu4e-get-mail-command "/usr/bin/offlineimap"

      mu4e-update-interval 300            ; Update interval (seconds)
      mu4e-index-cleanup t                ; Cleanup after indexing
      mu4e-index-update-error-warning t   ; Warnings during update
      mu4e-hide-index-messages t          ; Hide indexing messages
      mu4e-index-update-in-background t   ; Background update
      mu4e-index-lazy-check nil           ; Don't be lazy, index everything

      ;;mu4e-confirm-quit nil
      ;;mu4e-split-view 'single-window    ; Breaks the mu4e main page.

      mu4e-headers-auto-update t                ; avoid to type `g' to update
      mu4e-headers-date-format "%d-%m"
      mu4e-headers-time-format "%H:%M"
      mu4e-headers-from-or-to-prefix '("" . "To ")
      mu4e-headers-include-related t
      mu4e-headers-skip-duplicates t

      mu4e-view-show-images t                   ; show images in the view buffer
      mu4e-use-fancy-chars t                    ; allow fancy icons for mail threads
      mu4e-view-html-plaintext-ratio-heuristic  most-positive-fixnum
      mu4e-html2text-command 'mu4e-shr2text
      shr-use-fonts nil   ; Simple HTML Renderer / no font
      shr-use-colors nil) ; Simple HTML Renderer / no color

#+end_src

How to handle various MIME data.

#+begin_src emacs-lisp :prologue "" :epilogue ""

(require 'mailcap)

(push '((viewer . "open %s 2> /dev/null &")
        (type . "application/pdf")
        (test . window-system))
      mailcap-user-mime-data)

(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))

#+end_src

Some bindings to avoid confirmation for execution (headers and message view)

#+begin_src emacs-lisp
(require 'mu4e)
(bind-key "x" (lambda() (interactive) (mu4e-mark-execute-all t)) mu4e-headers-mode-map)
(bind-key "x" (lambda() (interactive) (mu4e-mark-execute-all t)) mu4e-view-mode-map)

#+end_src

** Accounts :PERSONAL:

*** General

We will rely on mu4e as our mail user agent.

#+begin_src emacs-lisp
(setq mail-user-agent 'mu4e-user-agent)
#+end_src

General information about me.

#+begin_src emacs-lisp

;; User name
(setq user-full-name "Sebastian Halbig")

;; Main user mail address
(setq user-mail-address "SebastianHalbig@gmx.de")

;; Common signature for all accounts.
(setq mu4e-signature (concat
                      "Sebastian Halbig — https://sebastianhalbig.github.io/main.html\n"
                      "Philipps-Universität Marburg — Research Group Algebraic Lie Theory\n"
                      "Hans-Meerwein-Straße 6 Room 04C35, 35043 Marburg\n"
                      "BBB home room: https://webconf.hrz.uni-marburg.de/d/seb-omn-wqu-r6k"))

#+end_src

Because we'll use mu4e-contexts, we reset single account settings.

#+begin_src emacs-lisp

(setq mu4e-contexts nil
      mu4e-drafts-folder nil
      mu4e-compose-reply-to-address nil
      mu4e-compose-signature t
      mu4e-compose-signature-auto-include t
      mu4e-sent-folder nil
      mu4e-trash-folder nil)

#+end_src

#+begin_src emacs-lisp

(setq mu4e-context-policy 'pick-first  ; How to determine context when entering headers view
      mu4e-compose-context-policy nil) ; Do not modify context when composing

#+end_src

Refile/archive depending on the context (via maildir)

#+begin_src emacs-lisp

(defun my-mu4e-refile-folder (msg)
  "Contextual refile"

  (let (
        (maildir (mu4e-message-field msg :maildir))
        (tags (mu4e-message-field msg :tags))
        (subfolder "saved")
        )
    (cond
     ((member "ORGANISATIONAL" tags) (setq subfolder "organisational"))
     ((member "INFO" tags) (setq subfolder "info"))
     ((member "TEACHING" tags) (setq subfolder "teaching"))
     ((member "RESEARCH" tags) (setq subfolder "research"))
     ((member "INVOICE" tags) (setq subfolder "invoice"))
     )
    (concat "/" (nth 1 (split-string maildir "/")) "/archive/" subfolder)
    ))

(setq mu4e-refile-folder 'my-mu4e-refile-folder)

(add-to-list 'mu4e-marks
             '(archive
               :char       "r"
               :prompt     "Archive"
               :dyn-target (lambda (target msg) (my-mu4e-refile-folder msg))
               :action      (lambda (docid msg target)
                              (mu4e--server-move docid (my-mu4e-refile-folder msg) "+S-u-N")
                              )))


(mu4e~headers-defun-mark-for archive)
(define-key mu4e-headers-mode-map (kbd "r") 'mu4e-headers-mark-for-archive)

#+end_src

Move emails to the relative spam folder.


#+begin_src emacs-lisp

(defun my-mu4e-spam-folder (msg)
  "Contextual spam handling"

  (let ((maildir (mu4e-message-field msg :maildir)))
    (concat "/" (nth 1 (split-string maildir "/")) "/spam")))

(setq mu4e-spam-folder 'my-mu4e-spam-folder)

#+end_src


*** Web :PERSONAL:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "Spam"
              :enter-func (lambda () (mu4e-message "Entering Spam context"))
              :leave-func (lambda () (mu4e-message "Leaving Spam context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                                                          :to "xolotl.spam@web.de")))
              :vars `((user-mail-address . "xolotl.spam@web.de"  )
                      (user-full-name . "Sebastian Halbig" )
                      (mu4e-compose-signature . nil)
                      (mu4e-sent-folder . "/Web/sent")
                      (mu4e-trash-folder . "/Web/trash")
                      (mu4e-drafts-folder . "/Web/drafts")
                      (mu4e-maildir-shortcuts . (("/Web/inbox" . ?i)
                                                 ("/Web/archive" . ?a)
                                                 ("/Web/sent" . ?s)))
                      (smtpmail-smtp-server . "smtp.staff.uni-marburg.de")
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_src

*** Dresden(deprecated) :PERSONAL:DEPRECATED:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "TUDresden"
              :enter-func (lambda () (mu4e-message "Entering Dresden(deprecated) context"))
              :leave-func (lambda () (mu4e-message "Leaving Dresden(deprecated) context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                                                          :to "sebastian.halbig@tu-dresden.de")))
              :vars `((user-mail-address . "Sebastian.Halbig@uni-marburg.de")
                      (user-full-name . "Sebastian Halbig" )
                      (mu4e-compose-signature . nil)
                      (mu4e-sent-folder . "/TUD/sent")
                      (mu4e-trash-folder . "/TUD/trash")
                      (mu4e-drafts-folder . "/TUD/drafts")
                      (mu4e-maildir-shortcuts . (("/TUD/inbox" . ?i)
                                                 ("/TUD/archive" . ?a)
                                                 ("/TUD/sent" . ?s)))
                      (smtpmail-smtp-server . "smtp.uni-marburg.de")
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_src

*** Private :PERSONAL:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "GMX"
              :enter-func (lambda () (mu4e-message "Entering GMX context"))
              :leave-func (lambda () (mu4e-message "Leaving GMX context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                                                          :to "sebastianhalbig@gmx.de")))
              :vars `((user-mail-address . "SebastianHalbig@gmx.de"  )
                      (user-full-name . "Sebastian Halbig" )
                      (mu4e-compose-signature . nil)
                      (mu4e-sent-folder . "/GMX/sent")
                      (mu4e-trash-folder . "/GMX/trash")
                      (mu4e-drafts-folder . "/GMX/drafts")
                      (mu4e-maildir-shortcuts . (("/GMX/inbox" . ?i)
                                                 ("/GMX/archive" . ?a)
                                                 ("/GMX/sent" . ?s)))
                      (smtpmail-smtp-server . "mail.gmx.net")
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_src
*** TODO Marburg-Internal :PERSONAL:

Currently we reroute the mail to the main account to avoid a bug of the mail server.

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "Internal-Marburg"
              :enter-func (lambda () (mu4e-message "Entering Marburg(general) context"))
              :leave-func (lambda () (mu4e-message "Leaving Marburg(general) context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                                                          :to "halbigs@mathematik.uni-marburg.de")))
              :vars `((user-mail-address . "Sebastian.Halbig@uni-marburg.de") ;;"halbigs@mathematik.uni-marburg.de"
                      (user-full-name . "Sebastian Halbig")
                      (mu4e-compose-signature . ,mu4e-signature)
                      (mu4e-sent-folder . "/MarburgInternal/sent")
                      (mu4e-trash-folder . "/MarburgInternal/trash")
                      (mu4e-drafts-folder . "/MarburgInternal/drafts")
                      (mu4e-maildir-shortcuts . (("/MarburgInternal/inbox" . ?i)
                                                 ("/MarburgInternal/archive" . ?a)
                                                 ("/MarburgInternal/sent" . ?s)))
                      (smtpmail-smtp-server . "smtp.uni-marburg.de") ;; "smtp.mathematik.uni-marburg.de"
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_sr
c
*** Marburg :PERSONAL:

#+begin_src emacs-lisp

(add-to-list 'mu4e-contexts
             (make-mu4e-context
              :name "Marburg"
              :enter-func (lambda () (mu4e-message "Entering Marburg(general) context"))
              :leave-func (lambda () (mu4e-message "Leaving Marburg(general) context"))
              :match-func (lambda (msg)
                            (when msg (mu4e-message-contact-field-matches msg
                                                                          :to "Sebastian.Halbig@uni-marburg.de")))
              :vars `((user-mail-address . "Sebastian.Halbig@uni-marburg.de")
                      (user-full-name . "Sebastian Halbig")
                      (mu4e-compose-signature . ,mu4e-signature)
                      (mu4e-sent-folder . "/Marburg/sent")
                      (mu4e-trash-folder . "/Marburg/trash")
                      (mu4e-drafts-folder . "/Marburg/drafts")
                      (mu4e-maildir-shortcuts . (("/Marburg/inbox" . ?i)
                                                 ("/Marburg/archive" . ?a)
                                                 ("/Marburg/sent" . ?s)))
                      (smtpmail-smtp-server . "smtp.uni-marburg.de")
                      (smtpmail-stream-type . starttls)
                      (smtpmail-smtp-service . 587))))

#+end_src
** TODO Contacts :INACTIVE:

In the future we will use org-contacts and based on them individual greetings and signatures.

#+begin_src emacs-lisp
(use-package org
  :ensure org-contacts
  :after org
  :custom (org-contacts-files '("~/Documents/org-files/contacts.org")))
#+end_src
** Encryption

See https://www.djcbsoftware.nl/code/mu/mu4e/Reading-messages.html

#+begin_src emacs-lisp :prologue "" :epilogue ""

(require 'epg-config)

(setq epg-gpg-program "/usr/bin/gpg"        ; What gpg program to use
      epg-user-id "Sebastian Halbig <Sebastian.Halbig@uni-marburg.de>" ; GnuPG ID of your default identity
      mml2015-use 'epg                      ; The package used for PGP/MIME.
      mml2015-encrypt-to-self t             ; Add our own key ID to recipient list
      mml2015-sign-with-sender t)           ; Use message sender to find a key to sign with.

;;(setq epa-file-cache-passphrase-for-symmetric-encryption nil)
;;(require 'epa-file)
;;(epa-file-enable)
;;(setq epa-file-select-keys nil)
(setq epa-pinentry-mode 'loopback)
(pinentry-start)

#+end_src

** TODO Read :BINDING:FACE:

Various settings

#+begin_src emacs-lisp

(setq mu4e-show-images t
      mu4e-use-fancy-chars nil
      mu4e-view-html-plaintext-ratio-heuristic  most-positive-fixnum
      mu4e-html2text-command 'mu4e-shr2text
      shr-use-fonts nil   ; Simple HTML Renderer / no font
      shr-use-colors nil) ; Simple HTML Renderer / no color

#+end_src

n/p for nevigating unread mails

#+begin_src emacs-lisp

(bind-key "n" #'mu4e-headers-next-unread mu4e-headers-mode-map)
(bind-key "p" #'mu4e-headers-prev-unread mu4e-headers-mode-map)

#+end_src

Custom faces

#+begin_src emacs-lisp

(set-face-attribute 'mu4e-system-face nil :inherit 'nano-critical)
(set-face-attribute 'mu4e-header-marks-face nil :inherit 'nano-critical)
(set-face-attribute 'mu4e-header-highlight-face nil :inherit 'nano-salient-i)

#+end_src
** TODO Write :HOOK:BINDING:

See www.gnu.org/software/emacs/manual/html_node/message/Insertion-Variables.html
We try to sign all mails. Encryption should also be managed automatically

#+begin_src emacs-lisp

(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-servers-requiring-authorization '".*"
      message-cite-reply-position 'below
      message-citation-line-format "%N [%Y-%m-%d at %R] wrote:"
      message-citation-line-function 'message-insert-formatted-citation-line
      message-yank-prefix       "> "
      message-yank-cited-prefix "> "
      message-yank-empty-prefix "> "
      message-indentation-spaces 1
      message-kill-buffer-on-exit t

      mu4e-compose-format-flowed t
      mu4e-compose-complete-only-personal t
      ;; mu4e-compose-complete-only-after "2021-01-01" ; Limit address auto-completion
      mu4e-compose-dont-reply-to-self t
      mu4e-compose-crypto-reply-policy 'sign-and-encrypt)

(add-hook 'message-send-hook 'mml-secure-message-sign-pgpmime)

#+end_src

Setting up mail composition with org mode.

#+name: my-mu4e-compose-hook
#+begin_src emacs-lisp

(defun my-mu4e-compose-hook ()
  "Settings for message composition."

  (auto-save-mode -1)
  (set-fill-column 80)
  ;;(auto-fill-mode)
  (setq flyspell-generic-check-word-predicate
        'mail-mode-flyspell-verify))

(add-hook 'mu4e-compose-mode-hook #'my-mu4e-compose-hook)

#+end_src


#+begin_src emacs-lisp
(use-package org-msg
  :hook (mu4e-main-mode . org-msg-mode)
  :config
  (setq org-msg-startup "content"
        org-msg-options "toc:nil author:nil email:nil \\n:t"
	    org-msg-greeting-fmt "\nHi%s,\n\n"
	    org-msg-greeting-name-limit 3
	    org-msg-default-alternatives '((new		      . (text))
				                       (reply-to-html . (text))
				                       (reply-to-text . (text)))
	    org-msg-convert-citation t
	    org-msg-signature "" )
  (add-to-list 'message-send-actions #' (lambda () (interactive)(kill-buffer '"*Org ASCII Export*")))
 )


#+end_src

** Bookmarks

#+begin_src emacs-lisp

(setq mu4e-bookmarks
      '((:name "Unread"
               :key ?u
               :show-unread t
               :query "flag:unread AND (m:/GMX/inbox or m:/TUD/inbox or m:/Marburg/inbox or m:/MarburgInternal/inbox or m:/Web/inbox) AND NOT flag:trashed")

        (:name "Inbox"
               :key ?i
               :show-unread t
               :query "m:/GMX/inbox or m:/TUD/inbox or m:/Marburg/inbox or m:/MarburgInternal/inbox or m:/Web/inbox")

        (:name "Today"
               :key ?t
               :show-unread t
               :query "date:today..now")

        (:name "Last week"
               :key ?w
               :hide-unread t
               :query "date:7d..now")

        (:name "Sent"
               :key ?s
               :show-unread nil
               :query "from:Sebastian.Halbig or from:halbigs or from: SebastianHalbig")

        (:name "Drafts"
               :key ?d
               :hide-unread t
               :query "flag:draft")

        (:name "Next"
               :key ?N
               :show-unread t
               :query "tags:NEXT")

        (:name "Todo"
               :key ?T
               :show-unread t
               :query "tags:TODO")

        (:name "Done"
               :key ?D
               :show-unread t
               :query "tags:DONE")
        ))
#+end_src

** Tags :BINDING:

This provides a tag action inside the mu4e headers view to quickly tag message. Tags are saved in the ~mu4e-tag-history~ variable that is also saved from one session to the other. We use the ~consult-completing-read-multiple~ function to read tags.


#+begin_src emacs-lisp

(defvar mu4e-tag-history '("RESEARCH" "TEACHING" "ORGANISATIONAL" "INFO" "INVOICE" "SAVE" "TODO" "DATE" "PENDING" "KITAEV" "WEYL" "INFINITY" "LEIBNITZ" "ADJUNCTION"  )
  "Mu4e tag history list.")

(add-to-list 'savehist-additional-variables 'mu4e-tag-history)

(put 'mu4e-tag-history 'history-length 20)

#+end_src

#+begin_src emacs-lisp

(defun add-to-mu4e-tag-history (tag)
  "Add the new tags to the history"
  (add-to-list 'mu4e-tag-history tag))

#+end_src

Here is the actual tag action

#+begin_src emacs-lisp

  (defun mu4e-tag-read (target msg)
    "Ask for tags to be added and/or removed."
    (let* ((tags nil)
           (old-tags (mu4e-message-field msg :tags))
           (new-tags (completing-read-multiple
                      "TAGS: "
                      mu4e-tag-history
                      nil
                      nil
                      (mapconcat #'identity old-tags ",")
                      ;; 'mu4e-tag-history
                      )))
      (dolist (tag old-tags)
        (let ((tag (string-trim tag)))
          (if (and (> (length tag) 0)
                   (not (member tag new-tags)))
              (push (concat "-" tag) tags))))
      (dolist (tag new-tags)
        (let ((tag (string-trim tag)))
          (if (and (> (length tag) 0)
                   (not (member tag old-tags)))
              (progn
                (add-to-mu4e-tag-history tag)
                (push (concat "+" tag) tags)))))
      (mapconcat #'identity tags ",")))

  ;; Add the mark to mu4e. If the action does nothing, the header is marked anyway.
  ;; I Did not find a way to cancel the marks
  (add-to-list 'mu4e-marks
                 '(tag
                   :char       "g"
                   :prompt     "gtag"
                   :dyn-target mu4e-tag-read
                   :action      (lambda (docid msg target)
                                  (when (> (length target) 0)
                                    (mu4e-action-retag-message msg target)))))

  ;; Tell mu4e about the new mark
  ;; See https://www.djcbsoftware.nl/code/mu/mu4e/Adding-a-new-kind-of-mark.html
  (mu4e~headers-defun-mark-for tag)

#+end_src

We bind the tagging with the "g" key in mu4e-headers-mode.

#+begin_src emacs-lisp

(bind-key "g" #'mu4e-headers-mark-for-tag mu4e-headers-mode-map)

#+end_src

** Folding :FACE:

Some face specification for folding.

#+begin_src emacs-lisp

(require 'mu4e-folding)

(set-face-attribute 'mu4e-folding-root-folded-face nil
                    :background (face-background 'default)
                    :extend t)
(set-face-attribute 'mu4e-folding-root-unfolded-face nil
                    :background (face-background 'default)
                    :extend t)
(set-face-attribute 'mu4e-folding-child-folded-face nil
                    :background (face-background 'default)
                    :extend t)
(set-face-attribute 'mu4e-folding-child-unfolded-face nil
                    :background (face-background 'default)
                    :extend t)

#+end_src

** Spam handling :BINDING:

We move messages automatically to the "correct" spam folder.

#+begin_src emacs-lisp

(add-to-list 'mu4e-marks
             '(spam
               :char       "k"
               :prompt     "Spam"
               :dyn-target (lambda (target msg) (my-mu4e-spam-folder msg))
               ;; :show-target (lambda (target) "Spam")
               :action      (lambda (docid msg target)
                              ;; (message (symbol-value msg))
                              (mu4e--server-move docid (my-mu4e-spam-folder msg) "+S-u-N")
                              )))

(mu4e~headers-defun-mark-for spam)


#+end_src

We bind spam handling to the "k"-key.

#+begin_src emacs-lisp

(define-key mu4e-headers-mode-map (kbd "k") 'mu4e-headers-mark-for-spam)

#+end_src

** Layout for mu4e :HOOK:BINDING:
*** Headers

#+begin_src emacs-lisp

(setq mu4e-headers-fields
      '((:my-flags      . 2)
        (:my-from       . 25)
        (:my-subject    . 70)
        (:my-tags       . 10)
        (:my-date       . 14)))


(setq mu4e-headers-thread-root-prefix          '(""   . "")
      mu4e-headers-thread-first-child-prefix   '(""   . "")
      mu4e-headers-thread-child-prefix         '(""   . "")
      mu4e-headers-thread-last-child-prefix    '(""   . "")
      mu4e-headers-thread-connection-prefix    '("| " . "| ")
      mu4e-headers-thread-blank-prefix         '(""   . "")
      mu4e-headers-thread-orphan-prefix        '(""   . "")
      mu4e-headers-thread-single-orphan-prefix '(""   . "")
      mu4e-headers-thread-duplicate-prefix     '("="  . "="))

(plist-put (cdr (assq 'refile   mu4e-marks)) :char "")
(plist-put (cdr (assq 'trash    mu4e-marks)) :char "")
(plist-put (cdr (assq 'action   mu4e-marks)) :char "")
(plist-put (cdr (assq 'untrash  mu4e-marks)) :char "")
(plist-put (cdr (assq 'delete   mu4e-marks)) :char "×")
(plist-put (cdr (assq 'flag     mu4e-marks)) :char "")
(plist-put (cdr (assq 'unflag   mu4e-marks)) :char "類")
(plist-put (cdr (assq 'move     mu4e-marks)) :char "")
(plist-put (cdr (assq 'tag      mu4e-marks)) :char "")
(plist-put (cdr (assq 'spam     mu4e-marks)) :char "")

#+end_src

**** Colorisation of recent emails

#+begin_src emacs-lisp

(defun my-mu4e-headers-colorise (item msg)
  "Colorise item depending on whe msg was received"

  (let* ((recent (* 5 60)) ;; 5 minutes
         (now (current-time))
         (unread (mu4e-message-field msg :unread))
         (date (mu4e-message-field msg :date))
         (delta (float-time (time-subtract now date))))
    (if (and (< delta recent) unread)
        (propertize item 'face 'nano-salient)
      item)))

#+end_src

**** Date (custom info)

#+begin_src emacs-lisp

(require 'relative-date)

(defun my-mu4e-headers-date (msg)
  (let* ((date (mu4e-message-field msg :date)))
    (my-mu4e-headers-colorise
     (format "%12s" (relative-date date)) msg)))

(add-to-list 'mu4e-header-info-custom
             '(:my-date . (:name "my-date"
                                 :shortname "D"
                                 :function my-mu4e-headers-date)))
#+end_src

**** From (custom info)

#+begin_src emacs-lisp

(defun my-mu4e-headers-from (msg)
  (let* ((from        (my-mu4e-get-sender msg))
         (meta        (when msg (mu4e-message-field msg :meta)))
         (root        (when meta (plist-get meta :root)))
         (orphan      (when meta (plist-get meta :orphan)))
         (first-child (when meta (plist-get meta :first-child)))
         (has-child   (when meta (plist-get meta :has-child)))
         (root        (when meta (plist-get meta :root)))
         (from        (cond ((and root has-child)       (concat " " from))
                            ((and orphan first-child)   (concat " " from))
                            ((and root (not has-child)) (concat "" from))
                            (t                          (concat "│ " from)))))
    (my-mu4e-headers-colorise from msg)))

(add-to-list 'mu4e-header-info-custom
             '(:my-from . (:name "my-from"
                                 :shortname "F"
                                 :function my-mu4e-headers-from)))

#+end_src

**** Flags (custom info)

#+begin_src emacs-lisp

(defun my-mu4e-headers-flags (msg)
  (let* ((size (mu4e-message-field msg :size))
         (flags (cond ((memq 'flagged   (mu4e-message-field msg :flags)) "")
                      ((and (> size 256000)
                            (memq 'attach    (mu4e-message-field msg :flags))) "")
                      ((memq 'replied   (mu4e-message-field msg :flags)) "")
                      ((memq 'draft     (mu4e-message-field msg :flags)) "")
                      ((memq 'trashed   (mu4e-message-field msg :flags)) "")
                      ((memq 'encrypted (mu4e-message-field msg :flags)) "")
                      (t ""))))
    (my-mu4e-headers-colorise flags msg)))

(add-to-list 'mu4e-header-info-custom
             '(:my-flags . (:name "my-flags"
                                  :shortname "F"
                                  :function my-mu4e-headers-flags)))

#+end_src

**** Tags (custom info)

We want pretty tags to get a good overview what an email is about.
This is managed by the ~my-prettify-tag-alist~. Using ~my-prettify-tag~, we replace tags by their symbols

#+begin_src emacs-lisp

(defvar my-prettify-tag-alist
  '(("TODO"           . "")
    ("DATE"           . "")
    ("RESEARCH"       . "")
    ("PENDING"        . "")
    ("INVOICE"        . "")
    ("SAVE"           . "")
    ("TEACHING"       . "")
    ("INFO"           . "")
    ("ORGANISATIONAL" . "")
    ("KITAEV"         . "")
    ("WEYL"           . "")
    ("INFINITY"       . "")
    ("LEIBNITZ"       . "")
    ("ADJUNCTION"     . "")
    ("TALK"           . "")))

(defun my-prettify-tag (tag)
  "Replaces any given tag by the corresponding symbol as specified in my-prettify-tag-alist"
  (let* ((local-tag tag)
         (prettified-tag (car (split-string local-tag ","))))
    (dolist (sym-pair my-prettify-tag-alist)
      (when (string= prettified-tag (car sym-pair))
        (setq prettified-tag (cdr sym-pair)))
      )
    prettified-tag
    ))

#+end_src

#+begin_src emacs-lisp

(defface mu4e-tag-face
  '((t :inherit (nano-salient)))
  "Face for message tags"
  :group 'mu4e-faces)

(defun my-mu4e-headers-tags (msg)
  (let* ((tags (mu4e-message-field msg :tags)))
    (if tags
        (propertize (format "%s" (mapconcat #'my-prettify-tag tags " "))
                    'face 'mu4e-tag-face)
      "")))
(add-to-list 'mu4e-header-info-custom
             '(:my-tags . (:name "my-tags"
                                 :shortname "T"
                                 :function my-mu4e-headers-tags)))

#+end_src

**** Thread count (custom info)

This is an empty info field (4 non-breaking spaces) that will be overwritten by folding mode.

#+begin_src emacs-lisp

(defun my-mu4e-headers-thread-counter (msg)
  "    ") ;; NON-BREAKING spaces
(add-to-list 'mu4e-header-info-custom
             '(:my-counter . (:name "my-counter"
                                    :shortname "#"
                                    :function my-mu4e-headers-thread-counter)))
#+end_src

**** Subject (custom info)

#+begin_src emacs-lisp

(defun my-mu4e-headers-subject (msg)
  (let* ((thread (mu4e-message-field msg :meta))
         (prefix (mu4e~headers-thread-prefix thread))
         (subject (mu4e-message-field msg :subject))
         ;; (subject (concat prefix subject " " (my-mu4e-headers-tags msg)))
         )
    (my-mu4e-headers-colorise subject msg)))

(add-to-list 'mu4e-header-info-custom
             '(:my-subject . (:name "my-subject"
                                    :shortname "S"
                                    :function my-mu4e-headers-subject)))

#+end_src

*** Folding

#+begin_src emacs-lisp

(require 'mu4e-folding)

(setq mu4e-folding-default-view 'folded)
(add-hook 'mu4e-headers-mode-hook #'mu4e-folding-mode)

;; (define-key mu4e-headers-mode-map (kbd "<tab>")     'mu4e-headers-toggle-at-point)
;; (define-key mu4e-headers-mode-map (kbd "<left>")    'mu4e-headers-fold-at-point)
;; (define-key mu4e-headers-mode-map (kbd "<S-left>")  'mu4e-headers-fold-all)
;; (define-key mu4e-headers-mode-map (kbd "<right>")   'mu4e-headers-unfold-at-point)
;; (define-key mu4e-headers-mode-map (kbd "<S-right>") 'mu4e-headers-unfold-all)

;; (defun mu4e-folding--make-root-overlay (beg end)
;;   "Create the root overlay."

;;   (let* ((buffer-read-only)
;;          (overlay (car (mu4e-folding--children-overlay)))
;;          (count (if overlay
;;                     (overlay-get overlay 'mu4e-folding-children-count)
;;                   0)))
;;     (save-excursion
;;       (goto-char beg)
;;       (when (search-forward "" end t)
;;         (put-text-property (- (point) 1) (point)
;;                            'display (svg-lib-tag (format "%d" count) nil
;;                                                  :ascent 'center)))))
;;   (save-excursion
;;     (let* ((match (search-forward "  " end t)))
;;       (if match
;;           (make-overlay (- match 2) end)
;;         (make-overlay beg end)))))

;; (defun mu4e-folding--make-root-overlay (beg end)
;;   "Create the root overlay."

;;   (let* ((buffer-read-only)
;;          (overlay (car (mu4e-folding--children-overlay)))
;;          (count (if overlay
;;                     (overlay-get overlay 'mu4e-folding-children-count)
;;                   0))
;;          (tag (format "%d" count))
;;          (tag (svg-lib-tag tag nil
;;                            :margin (- 4 (length tag))
;;                            :alignment 1.0
;;                            )))
;;     (save-excursion
;;       (goto-char beg)
;;       (when (search-forward "    " end t)
;;         (set-text-properties (- (point) 4) (+ (point) 1)
;;                              `(display ,tag)))))

;;   (let ((buffer-read-only)
;;         (overlay (make-overlay beg end)))
;;     overlay))

#+end_src

*** Threads separation

#+begin_src emacs-lisp

(defun my-mu4e-headers-is-root ()
  "Check if message at point is the root of a thread"
  (let* ((msg  (get-text-property (point) 'msg))
         (meta (when msg (mu4e-message-field msg :meta)))
         (orphan      (when meta (plist-get meta :orphan)))
         (first-child (when meta (plist-get meta :first-child)))
         (has-child   (when meta (plist-get meta :has-child)))
         (root     (when meta (plist-get meta :root))))

    ;; (and root has-child)
    (or root (and orphan first-child))
    ))

;; my-mu4e-headers-is-root

(defun my-mu4e-headers-separate-root ()
  (save-excursion
    (let ((buffer-read-only))
      (goto-char (point-min))
      (while (not (eobp))
        (when (my-mu4e-headers-is-root)
          (goto-char (line-beginning-position))
          (unless (or (eq (point) 1)
                      (and (> (point) (point-min))
                           (get-text-property (- (point) 1) 'mu4e-separator)))
            (insert
             (propertize "\n"
                         'mu4e-separator t
                         'face '(:inherit nano-strong
                                          :strike-through t
                                          :height 45
                                          :weight bold
                                          :extend t)))))
        (forward-line)))))

(add-hook 'mu4e-headers-found-hook #'my-mu4e-headers-separate-root)

#+end_src

** Layout for mu4e (1.8, alternative) :HOOK:BINDING:INACTIVE:

A custom multiline headers view for mu4e.

#+name: my-mu4e-headers-multiline
#+begin_src emacs-lisp

(defun my-mu4e-headers-multiline (msg)
  "A multiline headers mode."

  (let* ((sender  (my-mu4e-get-sender msg))
         (date (mu4e-message-field msg :date))
         (date (concat (propertize "" 'display " ")
                       (format "%16s" (my-date-relative date))))
         (subject (mu4e-message-field msg :subject))
         (subject (truncate-string-to-width subject (- (window-width) 16) nil nil "…"))
         (flagged   (memq 'flagged   (mu4e-message-field msg :flags)))
         (attach    (memq 'attach    (mu4e-message-field msg :flags)))
         (unread    (memq 'unread    (mu4e-message-field msg :flags)))
         (replied   (memq 'replied   (mu4e-message-field msg :flags)))
         (encrypted (memq 'encrypted (mu4e-message-field msg :flags)))
         (draft     (memq 'draft     (mu4e-message-field msg :flags)))
         (thread (mu4e-message-field msg :meta))
         (related (and thread (plist-get thread :related)))
         (prefix (mu4e~headers-thread-prefix thread))
         (root (plist-get thread :root))
         (orphan (plist-get thread :orphan))
         (first-child (plist-get thread :first-child))
         (has-child (plist-get thread :has-child))
         (level (plist-get thread :level))
         (root (or root (and orphan (or first-child has-child))))
         (child (and thread (not root)))
         (tags      (mu4e-message-field msg :tags))
         (unread-mark (propertize (cond (unread               (propertize " ●" 'face 'nano-salient))
                                        ((and root has-child) "  ")
                                        (t                    "  "))))
         (one-line (and child mu4e-headers-include-related))
         (face-sender (cond (unread               '(nano-salient nano-strong))
                            ((and root related)   '(nano-strong nano-faded))
                            (root                '(nano-strong nano-default))
                            ((and child related) '(:inherit nano-faded :height 140))
                            (child               '(:inherit nano-default :height 140))
                            (t                   '(nano-default))))
         (face-subject (cond (unread  '(:inherit nano-salient))
                             (related '(:inherit nano-faded))
                             (t       '(:inherit nano-default))))
         (face-tags (cond (related '(:inherit (nano-faded)              :height 120))
                          (t       '(:inherit (nano-popout nano-strong) :height 120))))
         (face-date    (cond (t '(:inherit nano-faded :height 140))))

         (icons (string-join
                 `(,@(if draft   `( ,(propertize "" 'face 'nano-faded)))
                   ,@(if attach  `( ,(propertize "" 'face 'nano-faded)))
                   ,@(if flagged `( ,(propertize "" 'face 'nano-salient)))
                   ) " ")))

    (concat

     ;; Separaction line between threads
     (when root
       (concat
        (propertize " "
                    'mu4e-root t
                    'display `((margin left-margin) "  "))
        (propertize "-" 'display "\n"
                    'face '(:extend t
                                    :strike-through t
                                    :inherit nano-subtle-i))
        "  ")) ;; !! NON-BREAKING SPACE -> will be searched later

     ;; Children are always indented (relatively to root)
     (when (and child one-line)
       (concat
        (propertize "│" 'face 'nano-faded)))

     ;; Unread mark appears in the left margin
     (propertize " " 'face (if unread 'nano-default face-sender)
                 'display `((margin left-margin) ,unread-mark))

     ;; Sender
     (cond (one-line     (propertize (concat prefix sender)
                                     'face face-sender))
           ((and root has-child) (propertize (concat " " sender)
                                             'face face-sender))
           (t (propertize sender 'face face-sender)))

     " "
     ;; Replied
     (when replied
       (propertize " " 'face face-sender))

     ;; In one line mode (children), icons are displayed next to sender
     (when one-line
       (concat (propertize icons)
               " "))

     ;; Tags next to sender
     (when tags
       (concat
        (propertize " " 'face face-tags)
        (mapconcat #'(lambda (tag)
                       (propertize tag 'face face-tags))
                   tags (propertize "," 'face face-tags))))

     ;; Spacing to have date aligned on the right
     (propertize " " 'display `(space :align-to (- right 1 ,(* 1.0 (length date)))))

     ;; Date
     (propertize date 'face face-date)

     ;; When not a child
     (when (or root (not mu4e-headers-include-related))
       (concat

        ;; Second line. We use a display property such that hl-line-mode works correctly.
        (propertize " " 'display "\n") ;; NON-BREAKING space for later search (see below)

        ;; Blank spaces in the margin (for nice hl-line-mode)
        (propertize " " 'face '(nano-strong nano-salient)
                    'display `((margin left-margin) "  "))

        ;; Indentation (to compensate for the virtual "\n" we introduced before)
        (propertize "  ")

        ;; Align subject and sender when this is a child
        (when (and one-line child)
          (propertize "  " 'face 'nano-faded))

        ;; Subject
        (propertize subject 'face face-subject)

        ;; Spacing to have icons aligned on the right
        (propertize " " 'display `(space :align-to (- right ,(length icons) 1)))

        ;; Icons on the right
        (propertize icons))))))

#+end_src

Then, we redefine thread symbols (we'll mostly manage ourselves).

#+begin_src emacs-lisp

(setq mu4e-headers-thread-root-prefix          '(""    . "")
      mu4e-headers-thread-first-child-prefix   '(" "   . " ")
      mu4e-headers-thread-child-prefix         '(" "   . " ")
      mu4e-headers-thread-last-child-prefix    '(" "   . " ")
      mu4e-headers-thread-connection-prefix    '(" |"  . "  ")
      mu4e-headers-thread-blank-prefix         '(""    . "")
      mu4e-headers-thread-orphan-prefix        '(" "   . "")
      mu4e-headers-thread-single-orphan-prefix '(""    . "")
      mu4e-headers-thread-duplicate-prefix     '("="   . "="))

#+end_src

And we install the new header.

#+begin_src emacs-lisp

;; (add-to-list 'mu4e-header-info-custom
;;              '(:multiline . (:name "multiline"
;;                              :shortname ""
;;                              :function my-mu4e-headers-multiline)))
;; (setq mu4e-headers-fields  '((:multiline . nil)))

#+end_src

*** Margins :INACTIVE:

Because the multiline header view uses margin to show new mail, we have to make sure there are always margin in the headers view. We also make the hl-line more salient.

#+name: my-mu4e-headers-setup
#+begin_src emacs-lisp

(defun my-mu4e-headers-mode-setup ()

  (with-current-buffer "*mu4e-headers*"
    (set-face-attribute 'mu4e-header-highlight-face nil
                        :inherit 'nano-salient-i)
    (setq-local left-margin-width 2)
    (setq-local cursor-type nil)
    (set-window-buffer nil "*mu4e-headers*")))

(add-hook 'mu4e-headers-found-hook #'my-mu4e-headers-mode-setup)
(add-hook 'mu4e-headers-mode-hook  #'my-mu4e-headers-mode-setup)

#+end_src

*** Navigation :INACTIVE:

Since a header can now be displayed over several consecutive lines, we need to remap prev/next line such as to use mu4e prev/next functions (that works properly with multiline headers).

#+begin_src emacs-lisp

(bind-key [remap next-line] #'mu4e-headers-next mu4e-headers-mode-map)
(bind-key [remap previous-line] #'mu4e-headers-prev mu4e-headers-mode-map)

#+end_src

*** Highlight :INACTIVE:

A special highlight function for root headers that takes the multiline root header into account.

#+begin_src emacs-lisp

(defun my-mu4e-hl-line-move ()

  (save-excursion
    (let* ((beg (line-beginning-position))
           (end (min (line-beginning-position 2) (point-max)))
           (match1 (search-forward "  " end t))
           (match2 (search-forward "│" end t)))
      (goto-char beg)
      (cond (match1 (cons (- match1 2) end))
            (match2 (cons (+ match2 1) end))
            (t      (cons beg end))))))

#+end_src

We retrict the hack to mu4e-header-mode

#+begin_src emacs-lisp

(defun my-mu4e-headers-mode-hl-line-move ()
  (setq-local hl-line-range-function #'my-mu4e-hl-line-move))

(add-hook 'mu4e-headers-mode-hook  #'my-mu4e-headers-mode-hl-line-move)

#+end_src

*** Folding :INACTIVE:

A special overlay function for folding that takes the multiline root header
into account & insert the number of children at the root level (replacing "" symbol)

#+begin_src emacs-lisp

(defun mu4e-folding--make-root-overlay (beg end)
  "Create the root overlay."

  (let* ((buffer-read-only)
         (overlay (car (mu4e-folding--children-overlay)))
         (count (if overlay
                    (overlay-get overlay 'mu4e-folding-children-count)
                  0)))
    (save-excursion
      (goto-char beg)
      (when (search-forward "" end t)
        (put-text-property (- (point) 1) (point)
                           'display (svg-lib-tag (format "%d" count) nil
                                                 :ascent 'center)))))
  (save-excursion
    (let* ((match (search-forward "  " end t)))
      (if match
          (make-overlay (- match 2) end)
        (make-overlay beg end)))))


#+end_src

#+begin_src emacs-lisp

(defun my-mu4e-move-mark-overlay ()
  (interactive)
  (let* ((beg (line-beginning-position))
         (end (line-beginning-position 2))
         (overlays (overlays-in beg end)))
    (dolist (overlay overlays)
      (when (overlay-get overlay 'mu4e-mark)
        (move-overlay overlay
                      (overlay-start overlay)
                      (+ (overlay-start overlay) 2))))))

#+end_src

** Dashboard

Provide a [[help:mu4e-dashboard][mu4e-dashboard]] command that opens the mu4e dashboard on the left side.

#+name: mu4e-dashboard
#+begin_src emacs-lisp

(require 'mu4e-dashboard)
(require 'svg-lib)

(setq mu4e-dashboard-propagate-keymap nil)
(setq mu4e-dashboard-buffer-name nil)

(defun mu4e-dashboard ()
  "Open the mu4e dashboard on the left side."

  (interactive)
  (with-selected-window
      (split-window (selected-window) -34 'left)

    (find-file (expand-file-name "mu4e-dashboard.org" user-emacs-directory))
    (mu4e-dashboard-mode)
    (hl-line-mode)
    (set-window-dedicated-p nil t)
    (setq mu4e-dashboard-buffer-name '"mu4e-dashboard.org")
    ;; (defvar svg-font-lock-keywords
    ;;   `(("\\!\\([\\ 0-9]+\\)\\!"
    ;;      (0 (list 'face nil 'display (svg-font-lock-tag (match-string 1)))))))
    ;; (defun svg-font-lock-tag (label)
    ;;   (svg-lib-tag label nil
    ;;                :stroke 0 :margin 1 :font-weight 'bold
    ;;                :padding (max 0 (- 3 (length label)))
    ;;                :foreground (face-foreground 'nano-popout-i)
    ;;                :background (face-background 'nano-popout-i)))
    ;; (push 'display font-lock-extra-managed-props)
    ;; (font-lock-add-keywords nil svg-font-lock-keywords)
    ;; (font-lock-flush (point-min) (point-max))
    ))

#+end_src

We activate the dashboard in the headers view.

#+begin_src emacs-lisp

(add-hook 'mu4e-headers-mode-hook #'(lambda()(unless mu4e-dashboard-buffer-name (mu4e-dashboard))))
(advice-add 'mu4e~headers-quit-buffer :after #'(lambda()(when mu4e-dashboard-buffer-name (mu4e-dashboard-quit))))
#+end_src

#+begin_src emacs-lisp

(defun mu4e-dashboard-quit ()
  "Close the currently open dashboard"

  (interactive)
  (when mu4e-dashboard-buffer-name
    (kill-buffer mu4e-dashboard-buffer-name)
    (setq mu4e-dashboard-buffer-name nil)
  ))

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "Mail")

#+end_src


* Math-mode :DEFER:MODE:BINDING:

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

Writing long LaTeX documents is painful. In the following, we make set up some functionalities to make our life easier.
We begin with some basic latex default settings.

#+begin_src emacs-lisp
(use-package latex
  :ensure auctex
  :config
  (setq TeX-auto-save t                      ; We automatically save style information when saving the buffer.
      TeX-parse-self t                       ; Parse the file after loading it if no style hook is found.
      ;; TeX-PDF-mode t                      ; We use PDFTeX mode
      TeX-source-correlate-mode t            ; Correlate (La-)TeX files with their PDF output.
      TeX-source-correlate-start-server nil) ; We do start a server for correlation.
  (setq-default TeX-master nil)              ; We do not specify the master files globally.

  (setq ispell-dictionary "british")         ; The default language is British English.

  (visual-line-mode)                         ; Only visual line wrapping.

  (setq TeX-open-quote "`")                  ; We use single quotation marks.
  (setq TeX-close-quote "'")                 ; We use single quotation marks.
  (setq font-latex-fontify-sectioning 1.0)   ; We set section hights to 1.
  )

#+end_src

** Compilation and PDF output

We compile LaTeX files using latexmk and view the resulting pdf in evince.

#+begin_src emacs-lisp

(use-package auctex-latexmk
  :ensure auctex
  :init
  (add-to-list 'TeX-command-list '("LatexMk"
                                   "latexmk %(-PDF)%S%(mode) -pv -view=pdf  -interaction=nonstopmode -synctex=1 %(file-line-error) %(extraopts) %t"
                                   TeX-run-latexmk
                                   nil
                                   (plain-tex-mode latex-mode doctex-mode)
                                   :help "Run LatexMk")) ; We compile latex documents with latexmk
  :preface
  (defun my-latex-compile ()
    "Compile latex files with latexmk"
    (interactive)
    (save-buffer)
    (TeX-command "LatexMk" 'TeX-master-file)
    )
  :hook
  (LaTeX-mode . auctex-latexmk-setup)
  (TeX-after-TeX-LaTeX-command-finished-hook . TeX-view)
  (TeX-after-compilation-finished-functions . TeX-view)
  (TeX-after-compilation-finished-functions . TeX-revert-document-buffer) ; refreshes the pdf output if PDF Tools is used
  :config
  (setq TeX-view-program-selection '((output-pdf "Evince"))) ; We use Evince as standard pdf-viewer. An alternative is PDF Tools.
  :bind (:map LaTeX-mode-map
              ("<f5>" . my-latex-compile))
  ;; :hook (TeX-after-compilation-finished-functions . TeX-revert-document-buffer) ; refreshes the pdf output if PDF Tools is used
  )

#+end_src

** Bibliography
We use reftex for handling the bibliography.
Our setup follows Tony Zorman.

#+begin_src emacs-lisp

(use-package reftex
  :hook (LaTeX-mode . turn-on-reftex)
  :config (reftex-set-cite-format "\\cite[][]{%l}")
  :custom
  (reftex-plug-into-AUCTeX t)               ; Integrate reftex into auctex.
  (reftex-toc-split-windows-horizontally t) ; Show reftex TOC on the left.
  (reftex-ref-macro-prompt nil)             ; No unnecessary prompts
  (reftex-label-alist              ; Tell reftex about some environments.
   '(("section"     ?s "sec:"  "~\\ref{%s}" t (regexp "[Ss]ection\\(s\\)?"       ))
     ("definition"  ?d "def:"  "~\\ref{%s}" t (regexp "[Dd]efinition\\(s\\)?"    ))
     ("example"     ?x "ex:"   "~\\ref{%s}" t (regexp "[Ee]xample\\(s\\)?"       ))
     ("lemma"       ?l "lem:"  "~\\ref{%s}" t (regexp "[Ll]emma\\(s\\|ta\\)?"    ))
     ("proposition" ?p "prop:" "~\\ref{%s}" t (regexp "[Pp]roposition\\(s\\)?"   ))
     ("theorem"     ?h "thm:"  "~\\ref{%s}" t (regexp "[Tt]heorem\\(s\\)?"       ))
     ("remark"      ?r "rem:"  "~\\ref{%s}" t (regexp "[Rr]emark\\(s\\)?"        ))
     ("corollary"   ?c "cor:"  "~\\ref{%s}" t (regexp "[Cc]orollar\\(y\\|ies\\)?")))))

#+end_src

** Editing and Autocompletion

CdLaTeX makes a lot of editing work easier.
We initialise it here and sprinkle it with a few of our own features.


#+begin_src emacs-lisp

(use-package cdlatex
  :hook
  (LaTeX-mode . turn-on-cdlatex    ) ; with AUCTeX LaTeX mode
  (org-mode   . turn-on-org-cdlatex) ; Use subset of cdlatex for org mode
  :custom
  (cdlatex-paired-parens nil) ; We will use aas to pair parentheses.
  ;; Custom bindings for the math modify list, accessed with '
  (cdlatex-math-modify-alist
   '(;;  MATHCMD      TEXTCMD    ARG RMDOT IT
     (?b "\\mathbb"   "\\textbf" t   nil   nil)
     (?f "\\mathbf"   "\\textsf" t   nil   nil)
     (?l "\\ld"       "\\textsl" t   nil   nil)
     (?k "\\mathfrak" nil        t   nil   nil)
     (?t "\\text"     nil        t   nil   nil)
     (?u "\\lld"      ""         t   nil   nil)
     ))
  ;; Custom bindings for the symbol list, accessed with `.  You may add
  ;; additional layers here.  Also, some of these are user-defined
  ;; commands.
  (cdlatex-math-symbol-alist
   '(;;    LAYER 1        LAYER 2      LAYER 3
     (?c  ("\\circ"           ""           "\\cos"   ))
     (?C  ("\\coprod"     ""           "\\arccos"))
     (?e  ("\\varepsilon"           "\\epsilon"         "\\exp"   ))
     (?f  ("\\varphi"          "\\phi"          ""        ))
     (?F  ("\\Phi"           ""           ""        ))
     (?R  ("\\real"          "\\Re"        ""        ))
     (?N  ("\\nat"       "\\nabla"          "\\exp"   ))
     (?Z  ("\\integer"    ""           ""        ))
     (?Q  ("\\rat"        "\\Theta"         ""        ))
     (?0  ("\\varnothing" ""           ""        ))
     (?{  ("\\subseteq"   "\\subset"         ""        ))
     (?}  ("\\supseteq"   "\\supset"         ""        ))
     (?.  ("\\cdot"           "\\dots"          ""        ))
     (?^  ("\\otimes"          ""            ""        ))
     (?ö  ("\\odot"           ""            ""        ))
     ))
  :config
  (setq cdlatex-tab-hook '(yas-expand indent-for-tab-command)))

#+end_src

We set try to be clever about our uses of <return> and <$>.

#+begin_src emacs-lisp
(use-package smart-keys-for-latex
  :ensure reftex
  :after cdlatex
  :config (setup-smart-keys)
  :bind (:map cdlatex-mode-map
         ("$" . cycle-texmath)
         :map TeX-mode-map
         ("RET" . smart-return)
              )
  )
#+end_src

Some latex-commands that are auto-expanded by aas.

#+begin_src emacs-lisp
(use-package aas
  :after dash
  :init
  (yas-minor-mode 1)
  (laas-mode 1)
  :hook ((LaTeX-mode org-mode) . aas-activate-for-major-mode)
  :config
  (--each '(latex-mode) ;; TODO integrate qorg-mode
    (aas-set-snippets it
      :cond #'(lambda()(and (texmathp) (car texmathp-why)))
      " :"      "\\from "
      " **"     "\\star"
      " mm"     "\\mid "
      " ->"     "\\to "
      " mt"     "\\mapsto "
      " =>"     "\\implies "
      " ..."    "\\dots"
      " bln"    "\\blank"
      " def"    "\\defeq"
      " ~"      "\\sim"
      " =="     "\\cong"
      " ot"     "\otimes"
      " bz"     "\\mathbb{Z}"
      " bq"     "\\mathbb{Q}"
      " br"     "\\mathbb{R}"
      " bc"     "\\mathbb{C}"
      " bf"     "\\mathbb{F}"
      " bp"     "\\mathbb{P}"
      " fg"     "\\mathfrak{g}"
      " fh"     "\\mathfrak{h}"
      " cc"     "\\cat{C}"
      " cd"     "\\cat{D}"
      " cm"     "\\cat{M}"
      " zc"     "\\ZCat{C}"
      " subset" "\\subset"
      " supset" "\\supset"
      " <>"    (lambda () (interactive)
                 (yas-expand-snippet "\\langle $0 \\rangle"))
      " adj"   (lambda () (interactive)
                 (yas-expand-snippet "\\adj{${1:F}}{${2:U}}{${3:\\cc}}{${4:\\mm}} $0"))
      " hom"  (lambda () (interactive)
                (yas-expand-snippet "${1:\\cc}(${2:s}, ${3:t})"))
      " coend" (lambda () (interactive)
                 (yas-expand-snippet "\\int^{${2:C \\in \\cc}}"))
      " end"   (lambda () (interactive)
                 (yas-expand-snippet "\\int_{${2:C \\in \\cc}}"))
      " set"   (lambda () (interactive)
                 (yas-expand-snippet "\\\\{$0"))
      " sum"   (lambda () (interactive)
                 (yas-expand-snippet "\\sum_{${1:i=1}}^{${2:n}}$0"))
      ;;" gl"    (lambda () (interactive)
      ;;          (yas-expand-snippet "\\mathfrak{gl}_{${1:n}}$0"))
      ;;" //"    (lambda () (interactive)
      ;;          (yas-expand-snippet "\\frac{$1}{$2}$0"))
      " cat"   (lambda () (interactive)
                 (yas-expand-snippet "\\cat{$1}$0")))))

#+end_src

** TODO Visuals

It just makes more fun to write latex if it already looks nice while writing.
As a preventive measure to eye-cancer we change most of the auctex defaults to something humans can bare.

#+begin_src emacs-lisp
(defun my-LaTeX-better-fonts()
  (set-face-attribute 'font-latex-bold-face nil
                      :foreground 'unspecified
                      :weight 'bold
                      :inherit 'unspecified)

  (set-face-attribute 'font-latex-italic-face nil
                      :family "Victor Mono"
                      :foreground 'unspecified
                      :slant 'oblique
                      :inherit 'unspecified)

  (set-face-attribute 'font-latex-math-face nil
                      :height 'unspecified
                      :foreground 'unspecified
                      :weight 'semilight
                      :inherit 'nano-strong)

  (set-face-attribute 'font-latex-script-char-face nil
                      :foreground 'unspecified)

  (set-face-attribute 'font-latex-warning-face nil
                      :foreground 'unspecified
                      :inherit 'nano-faded)

  (set-face-attribute 'font-latex-sectioning-0-face nil
                      :height 'unspecified
                      :weight 'bold
                      :foreground 'unspecified
                      :underline t
                      :inherit 'nano-salient)

  (set-face-attribute 'font-latex-sectioning-1-face nil
                      :height 'unspecified
                      :foreground 'unspecified
                      :inherit 'font-latex-sectioning-0-face)

  (set-face-attribute 'font-latex-sectioning-2-face nil
                      :height 'unspecified
                      :foreground 'unspecified
                      :inherit 'font-latex-sectioning-1-face)

  (set-face-attribute 'font-latex-sectioning-3-face nil
                      :height 'unspecified
                      :foreground 'unspecified
                      :inherit 'font-latex-sectioning-2-face)

  (set-face-attribute 'font-latex-sectioning-4-face nil
                      :weight 'normal
                      :height 'unspecified
                      :foreground 'unspecified
                      :underline nil
                      :inherit 'font-latex-sectioning-3-face)

  (set-face-attribute 'font-latex-sectioning-5-face nil
                      :weight 'normal
                      :height 'unspecified
                      :foreground 'unspecified
                      :inherit 'font-latex-sectioning-4-face)

  (set-face-attribute 'font-latex-slide-title-face nil
                      :height 'unspecified
                      :inherit 'font-latex-sectioning-0-face)

  (set-face-attribute 'font-latex-underline-face nil
                      :height 'unspecified
                      :foreground 'unspecified
                      :underline t)

  (set-face-attribute 'font-lock-keyword-face nil
                      :inherit 'nano-faded)

  (set-face-attribute 'font-lock-constant-face nil
                      :inherit 'nano-faded)

  (set-face-attribute 'font-lock-comment-face nil
                      :inherit 'nano-subtle)
  )

(use-package font-latex
  :hook (LaTeX-mode . my-LaTeX-better-fonts)
  :config
  )

#+end_src
First, we fold away annoying parts like comments or commuting diagrams.
The code for this function is due to Tony Zorman.

#+begin_src emacs-lisp

(defun my-LaTeX-fold-annoyances ()
  "Fold annoyances.
Everything that makes the LaTeX file worse to look at—things like
commutative diagrams, as well as comments."
  (interactive)
  (TeX-fold-mode)
  (TeX-fold-region-comment (point-min) (point-max))
  (setq-local TeX-fold-env-spec-list-internal
              '(("≪commutative diagram≫" ("tikzcd"))
                ("≪tikz picture≫" ("tikzpicture"))))
  (TeX-fold-region-macro-or-env (point-min) (point-max) 'env))

#+end_src

Some symbols we want to display differently. Font-locking allows us to do so.

#+begin_src emacs-lisp
(defun latex-regexp-prettify ()
  "We use an unobtrusive font for certain latex-internal formating rules such as `{...}'"
  (highlight-regexp "{" 'custom-comment)
  (highlight-regexp "}" 'custom-comment)
  (highlight-regexp "[[:space:]]*\\\\quad[[:space:]]*" 'custom-comment)
  (highlight-regexp "[[:space:]]*\\\\qquad[[:space:]]*" 'custom-comment)
  (highlight-regexp "[[:space:]]*\\\\,[[:space:]]*" 'custom-comment)
  (highlight-regexp "[[:space:]]*\\\\;[[:space:]]*" 'custom-comment)
  (highlight-regexp "[[:space:]]*\\\\enspace[[:space:]]*" 'custom-comment)
  (highlight-regexp "[[:space:]]*\\\\emspace[[:space:]]*" 'custom-comment)
  )

(add-hook 'LaTeX-mode-hook 'latex-regexp-prettify)
#+end_src

In order to prettify symbols, we use fira code and a long list of symbols which are replaced.

#+begin_src emacs-lisp
(defun my-LaTeX-fira-pitch ()
  (set-face-attribute 'font-latex-math-face nil
                      :family "Fira Code"
                      :weight 'semilight
                      :height 140)
  )

(defun latex-symbols-prettify ()
  "A long list of symbols to display nicely in latex-mode"
  (mapc (lambda (pair) (add-to-list 'prettify-symbols-alist pair))
        ;; ARROWS
        '(("\\to"                  32 (Br . Bl) 32 (Br . Br) 57620)
          ("\\rightarrow"          32 (Br . Bl) 32 (Br . Br) 57620)
          ("\\mapsto"              8870 (cr  cl 16 0) 57620)
          ("\\longmapsto"          32 (Br . Bl)  8866 (cr . cl) 32 (Br . Bl)  32 (Br . Br)  57619)
          ("\\inj"                 5308 (tl  tl 20 0) 32 (tr  tl 0 -5) 57620)
          ("\\emb"                 5308 (tl  tl 20 0) 32 (tr  tl 0 5) 57620)
          ("\\hookrightarrow"      5354 (tl . tl) 32 (tr . tl) 57620)
          ("\\surj"                32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57621)
          ("\\proj"                32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57621)
          ("\\twoheadrightarrow"   32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57621)
          ("\\twoheadleftarrow"    32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57693)
          ("\\longrightarrow"      32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57619)
          ("\\rightsquigarrow"     32 (Br . Bl) 32 (Br . Br) 57703)
          ("\\leftarrow"           32 (Br . Bl) 32 (Br . Br) 57682)
          ("\\longleftarrow"       32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57683)
          ("\\leftrightarrow"      32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57684)
          ("\\leftsquigarrow"      32 (Br . Bl) 32 (Br . Br) 57696)
          ("\\Rightarrow"          32 (Br . Bl) 32 (Br . Br) 57663)
          ("\\Longrightarrow"      32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57662)
          ("\\implies"             32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57662)
          ("\\Leftarrow"           32 (Br . Bl) 32 (Br . Br) 57688)
          ("\\Longleftarrow"       32 (Br . Bl) 32 (Br . Br) 57688)
          ("\\impliedby"           32 (Br . Bl) 32 (Br . Br) 57688)
          ("\\Leftrightarrow"      32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57689)
          ("\\upharpoonleft"       ?↿)
          ("\\upharpoonright"      ?↾)
          ("\\downharpoonleft"     ?⇃)
          ("\\downharpoonright"    ?⇂)
          ("\\hookleftarrow"       ?↩)
          ("\\looparrowleft"       ?↫)
          ("\\looparrowright"      ?↬)
          ("\\leftrightsquigarrow" ?↭)
          ("\\leftleftarrows"      ?⇇)
          ("\\rightrightarrows"    ?⇉)
          ("\\leftrightarrows"     ?⇆)
          ("\\rightleftarrows"     ?⇄)
          ("\\Lleftarrow"         ?⇚)
          ("\\Rrightarrow"        ?⇛)
          ;; ENVIRONMENTS
          ("\\part"                ?#)
          ("\\section"             32 (Br . Bl) 32 (Br . Br) 57627)
          ("\\subsection"          32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57628)
          ("\\subsubsection"       32 (Br . Bl) 32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57629)
          ("\\begin"               32 (Br . Bl) 32 (Br . Br) 57653)
          ("\\end"                 32 (Br . Bl) 32 (Br . Br) 57677)
          ("\\item"                32 (Br . Bl) 32 (Br . Bl) 32 (Br . Br) 57686)
          ;; SPACING
          ("\\,"                  8194 (Bc . Bc) 8231)
          ("\\:"                  8194 (Bc . Bc) 8231)
          ("\\;"                  8194 (Bc . Bc) 8231)
          ("\\enspace"            8194 (Bc . Bc) 8231)
          ("\\emspace"            8195 (Bc . Bc) 8231)
          ("\\quad"               8231 (Bc . Bc) 8195 (Br . Bl) 8231 (Bc . Bc) 8195)
          ("\\qquad"              8231 (Bc . Bc) 8195 (Br . Bl) 8231 (Bc . Bc) 8195 (Br . Bl) 8231 (Bc . Bc) 8195 (Br . Bl) 8231 (Bc . Bc) 8195)
          ;; SETS
          ("\\mathbb{N}"           ?\u2115)
          ("\\mathbb{R}"           ?\u211D)
          ("\\mathbb{C}"           8450)
          ("\\mathbb{P}"           8473)
          ("\\mathcal{C}"          120018)
          ("\\cat{C}"              120018)
          ("\\mathcal{D}"          120019)
          ("\\cat{D}"              120019)
          ("\\cat{E}"              120020)
          ("\\cat{M}"              120028)
          ("\\cat{N}"              120029)
          ("\\mathfrak{C}"         120174)
          ("\\mathfrak{D}"         120175)
          ("\\ZCat"                120041)
          ;; OPERATORS
          ("\\defeq"               32 (Br . Bl) 32 (Br . Br) 57612)
          ("\\eq"                  ?=)
          ("\\neq"                 32 (Br . Bl) 32 (Br . Br) 57614)
          ("\\blank"               8212)
          ("\\from"                32 (Br . Br) 57708)
          ("\\colon"               32 (Br . Br) 57708)
          ("\\lact"                9655)
          ("\\blact"               9654)
          ("\\ract"                9665)
          ("\\bract"               9664)
          ("\\unlhd"               ?⊴)
          ("\\unrhd"               ?⊵)
          ("\\cdot "               8226)
          (" \\cdot "              8226)
          ("\\times "              215)
          (" \\times "             215)
          ("\\parallel"            ?∥)
          ("\\notni"               8260 (cc . cc) ?∋)
          ("\\sqcup"               ?⊔)
          ("\\bigsqcup"            ?⊔)
          ("\\sqcap"               ?⊓)
          ("\\bigsqcap"            ?⊓)
          ("\\biguplus"            ?⨄)
          ("\\land"                ?∧)
          ("\\lor"                 ?∨)
          ("\\odot"                ?⊙)
          ("\\bigodot"             ?⊙)
          ("\\otimes"              ?⊗)
          ("\\bigotimes"           ?⊗)
          ("\\oplus"               ?⊕)
          ("\\bigoplus"            ?⊕)
          ("\\sqrt"                ?√)
          ("\\iint"                ?∬)
          ("\\iiint"               ?∭)
          ("\\iiiint"              ?⨌)
          ("\\oiint"               ?∯)
          ("\\oiiint"              ?∰)
          ("\\ointclockwise"       ?∲)
          ("\\ointctrclockwise"    ?∳)
          ;; BETTER SUB AND SUPERSCRIPTS
          ("^0"                    8304)
          ("^1"                    185)
          ("^2"                    178)
          ("^3"                    179)
          ("^4"                    8308)
          ("^5"                    8309)
          ("^6"                    8310)
          ("^7"                    8311)
          ("^8"                    8312)
          ("^9"                    8313)
          ("^l"                    ?\u02E1)
          ("^r"                    ?\u02B3)
          ("^T"                    ?\u1d40)
          ("_0"                    8320)
          ("_1"                    8321)
          ("_2"                    8322)
          ("_3"                    8323)
          ("_4"                    8324)
          ("_5"                    8325)
          ("_6"                    8326)
          ("_7"                    8327)
          ("_8"                    8328)
          ("_9"                    8329)
          ;; GREEK UPPER CASES
          ("\\Alpha"               ?Α)
          ("\\Beta"                ?Β)
          ("\\Gamma"               ?Γ)
          ("\\Delta"               ?Δ)
          ("\\Epsilon"             ?Ε)
          ("\\Zeta"                ?Ζ)
          ("\\Eta"                 ?Η)
          ("\\Theta"               ?Θ)
          ("\\Iota"                ?Ι)
          ("\\Kappa"               ?Κ)
          ("\\Lambda"              ?Λ)
          ("\\Mu"                  ?Μ)
          ("\\Nu"                  ?Ν)
          ("\\Xi"                  ?Ξ)
          ("\\Omicron"             ?Ο)
          ("\\Pi"                  ?Π)
          ("\\Rho"                 ?Ρ)
          ("\\Sigma"               ?Σ)
          ("\\Tau"                 ?Τ)
          ("\\Upsilon"             ?Υ)
          ("\\Phi"                 ?Φ)
          ("\\Chi"                 ?Χ)
          ("\\Psi"                 ?Ψ)
          ("\\Omega"               ?Ω)
          ;; SPECIAL SYMBOLS
          ("\\ss"                  ?ß)
          ("\\aa"                  ?å)
          ("\\AA"                  ?Å)
          ("\\ae"                  ?æ)
          ("\\oe"                  ?œ)
          ("\\AE"                  ?Æ)
          ("\\OE"                  ?Œ)
          ("\\o"                   ?ø)
          ("\\O"                   ?Ø)
          ("\\l"                   ?ł)
          ("\\L"                   ?Ł)
          ("\\S"                   ?§)
          ;; ESCAPED SYMBOLS
          ("\\$"                   ?＄)
          ("\\%"                   ?％)
          ("\\#"                   ?＃)
          ("\\_"                   ?＿)
          ("\\&"                   ?& (Bc . Bc) ?|)
          ;;REFERECING
          ("\\ref"                 ?☞)
          ("\\cite"                ?†)
          ("\\footnote"            ?‡)
          ("\\label"               43 (cc . cc) ?‡)
          ("\\TeX"                 ?T (cr cl -20 -45) ?E (cr cl -20 24) ?X)
          ("\\LaTeX"               ?L (cr cl -60 35) ?A (cr cl -18 -20) ?T (cr cl -18 -60) ?E (cr cl -20 5) ?X)
          ;; PARENTHESES
          ("{"                     ?⎨)
          ("}"                     ?⎬)
          ("\\{"                   ?{)
          ("\\}"                   ?})
          ("\\lbrace"              ?{)
          ("\\rbrace"              ?})
          ("\\{"                   ?{)
          ("\\}"                   ?})
          ("\\|"                   ?║)
          ;; Misc
          ("\\dots"                ?…)
          ("\\textbackslash"       ?＼)
          ("\\backslash"           ?＼)
          ("\\qed"                 ?□)
          ("\\lightning"           ?Ϟ)
          ("\\copyright"           ?©)
          ("\\texistregistered"    ?®)
          ("\\texttrademark"       ?™)
          ("\\euro"                8364)
          ("\\pounds"              ?£)
          ("\\lvert"               ?|)
          ("\\rvert"               ?|)
          ("\\lVert"               ?ǁ)
          ("\\rVert"               ?ǁ)
          )))

(use-package fira-code-mode
  :custom (fira-code-mode-disabled-ligatures '("[]" "#{" "#(" "#_" "#_(" "x" "{-" "-}" )) ;; List of ligatures to turn off
  :hook
  (LaTeX-mode . my-LaTeX-fira-pitch)
  (LaTeX-mode . fira-code-mode)
  :config
  (latex-symbols-prettify)
   )
#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "LaTeX")

#+end_src




* TODO Python :DEFER:MODE:

This is only a rough setup to be able to write python code in emacs.

#+begin_src emacs-lisp

(use-package elpy
  :defer t
  :init
  (advice-add 'python-mode :before 'elpy-enable))

#+end_src

#+RESULTS:

* TODO Bibliography
** Bibtex

Settings for bibtex

#+begin_src emacs-lisp
(setq bibtex-autokey-titleword-length 0
      bibtex-autokey-name-year-separator ":"
      bibtex-autokey-name-case-convert-function 'capitalize
      bibtex-autokey-year-length 4
      bibtex-autokey-names 1
      bibtex-autokey-titleword-separator ""
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-edit-before-use nil
      imenu-list-position 'left
      imenu-list-size 100
      org-imenu-depth 2
      org-image-actual-width `( ,(truncate (* (frame-pixel-width) 0.85)))
      org-startup-with-inline-images t)
#+end_src

** Org bib mode :HOOK:

Dedicated header line for org-bib-mode

#+begin_src emacs-lisp

(defun my-org-bib-mode-hook ()

  (with-current-buffer "*Ilist*"
    (setq header-line-format
          '(:eval
            (nano-modeline-render nil
                                  (buffer-name imenu-list--displayed-buffer)
                                  (format "(view mode: %s, filter: %s)"
                                          (if (eq org-bib--view-mode-current 'none)
                                              "-"
                                            org-bib--view-mode-current)
                                          (if (eq org-imenu-filter-string "*")
                                              "-"
                                            org-imenu-filter-string))
                                  "")))
    (face-remap-add-relative 'hl-line :inherit 'nano-strong-i)))

(add-hook 'org-bib-mode-hook #'my-org-bib-mode-hook)

#+end_src

A shortcut to edit bibliography

#+begin_src emacs-lisp :prologue "" :epilogue ""
(defun my-biblio ()
  "Create a new frame for editing bibliography"

  (interactive)
  (require 'org-bib)
  (setq imenu-list-position 'left
        imenu-list-size 100
        org-imenu-depth 2)

  (select-frame (make-frame '((name . "my-biblio")
                              (width . 180)
                              (height . 45))))
  (find-file "~/Documents/mathematics/research/literature.org")
  (org-bib-mode))

#+end_src

An autoload function for my-config (that will load org mode).

#+begin_src emacs-lisp :prologue "" :epilogue ""

(autoload 'my-biblio
  (expand-file-name "init.el" user-emacs-directory)
  "Autoloaded my-config command."
  t)

#+end_src


* Org :DEFER:
:PROPERTIES:
:header-args:emacs-lisp: :prologue "(with-eval-after-load 'org" :epilogue ")"
:END:

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** General :HOOK:

#+begin_src emacs-lisp

(setq-default org-directory "~/Documents/org-files"
              org-tags-column 1                            ; Tags next to header title
              org-hide-emphasis-markers t                  ; Hide markers
              org-cycle-separator-lines 2                  ; Number of empty lines between sections
              org-use-tag-inheritance nil                  ; Tags ARE NOT inherited
              org-use-property-inheritance t               ; Properties ARE inherited
              org-indent-indentation-per-level 2           ; Indentation per level
              org-link-use-indirect-buffer-for-internals t ; Indirect buffer for internal links
              org-fontify-quote-and-verse-blocks t         ; Specific face for quote and verse blocks
              org-return-follows-link nil                  ; Follow links when hitting return
              org-image-actual-width nil                   ; Resize image to window width
              org-indirect-buffer-display 'other-window    ; Tab on a task expand it in a new window
              org-outline-path-complete-in-steps nil)      ; No steps in path display

#+end_src

Always indent org-files

#+begin_src emacs-lisp

(add-hook 'org-mode-hook 'org-indent-mode)

#+end_src

Better latex preview (see https://stackoverflow.com/questions/30151338)

,#+begin_src emacs-lisp

(setq org-latex-create-formula-image-program 'dvisvgm)

#+end_src

We adapt fill functions according to the indent level.

#+begin_src emacs-lisp

(defun my-calc-offset-on-org-level ()
  "Calculate offset (in chars) on current level in org mode file."

  (* (or (org-current-level) 0) org-indent-indentation-per-level))

(defun my-org-fill-paragraph (&optional justify region)
  "Calculate apt fill-column value and fill paragraph."

  (let* ((fill-column (- fill-column (my-calc-offset-on-org-level))))
    (org-fill-paragraph justify region)))

(defun my-org-auto-fill-function ()
  "Calculate apt fill-column value and do auto-fill"

  (let* ((fill-column (- fill-column (my-calc-offset-on-org-level))))
    (org-auto-fill-function)))

(defun my-org-mode-hook ()
  (setq fill-paragraph-function #'my-org-fill-paragraph
        normal-auto-fill-function #'my-org-auto-fill-function))

(add-hook 'org-load-hook 'my-org-mode-hook)
(add-hook 'org-mode-hook 'my-org-mode-hook)

#+end_src

A shortcut for emacs-lisp source blocks. Type "<S" (in org-mode) then press tab.

#+begin_src emacs-lisp

(require 'org-tempo)
(add-to-list 'org-structure-template-alist
             '("S" . "src emacs-lisp"))

#+end_src

** TODO HTML-Export :CUSTOM:

We treat ~code~ and =verbatim= faces differently among export

#+begin_src emacs-lisp

(setq org-html-text-markup-alist '(
       (bold           . "<b>%s</b>")
       (code           . "<code class=\"code\">%s</code>")
       (italic         . "<i>%s</i>")
       (strike-through . "<del>%s</del>")
       (underline      . "<span class=\"underline\">%s</span>")
       (verbatim       . "<code class=\"verbatim\">%s</code>")))

#+end_src

** Babel

#+begin_src emacs-lisp

(setq-default org-src-fontify-natively t         ; Fontify code in code blocks.
              org-adapt-indentation nil          ; Adaptive indentation
              org-src-tab-acts-natively t        ; Tab acts as in source editing
              org-confirm-babel-evaluate nil     ; No confirmation before executing code
              org-edit-src-content-indentation 0 ; No relative indentation for code blocks
              org-fontify-whole-block-delimiter-line t) ; Fontify whole block

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "Org")

#+end_src




* Agenda :DEFER:
:PROPERTIES:
:header-args:emacs-lisp: :prologue "(with-eval-after-load 'org-agenda" :epilogue ")"
:END:

#+begin_src emacs-lisp

;; Modern org mode

(use-package org
  :pin gnu
  :commands (org-capture org-agenda)
  :config
  (setq org-ellipsis " ▾")

  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)

  (setq org-agenda-files '("~/Documents/org-files/agenda"))

  (setq org-agenda-include-diary t) ;; allows you to integrate your calendar into the agenda
  (setq org-use-fast-todo-selection t)

  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(w)" "|" "DONE(d)")
          (sequence "PENDING(p)" "DEFERRED(D)" "OCCURING (o)" "|" "COMPLETED(c)")
          ;; (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
          (sequence "|" "CANCELED(C)")))



  (setq org-todo-keyword-faces
        '(("TODO" :foreground "tomato4" :weight bold)
          ("DONE" :foreground "PaleGreen4" :weight bold)
          ("REVIEW" :foreground "LightGoldenrod3" :weight bold)
          ("WAITING" :foreground "peru" :weight bold)
          ("INACTIVE" :foreground "coral" :weight bold)
          ("CANCELLED" :foreground "sienna" :weight bold)))

  ;;  Auto-update tags whenever the state is changed
  (setq org-todo-state-tags-triggers
        '(("CANCELLED" ("CANCELLED" . t))
          ("WAITING" ("SOMEDAY") ("INACTIVE") ("WAITING" . t))
          ("INACTIVE" ("WAITING") ("SOMEDAY") ("INACTIVE" . t))
          ("SOMEDAY" ("WAITING") ("INACTIVE") ("SOMEDAY" . t))
          (done ("WAITING") ("INACTIVE") ("SOMEDAY"))
          ("TODO" ("WAITING") ("CANCELLED") ("INACTIVE") ("SOMEDAY"))
          ("REVIEW" ("WAITING") ("CANCELLED") ("INACTIVE") ("SOMEDAY"))
          ("DONE" ("WAITING") ("CANCELLED") ("INACTIVE") ("SOMEDAY"))))

  (setq org-tag-alist
        '((:startgroup)
                                        ; Put mutually exclusive tags here
          (:endgroup)
          ("short"        . ?s)
          ("necessary"    . ?n)
          ("extension"    . ?e)
          ("idea"         . ?i)
          ("polish"       . ?p)
          ("internal"     . ?I)
          ("organisation" . ?o)
          ("meetings"     . ?m)
          ("feedback"     . ?f)
          ("regularly"    . ?r)
          ))

  (setq org-capture-templates
        `(
          ("t" "Tasks / Projects")
          ("tt" "Task" entry (file+olp "~/Documents/org-files/agenda" "Tasks")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

          ("j" "Journal Entries")
          ("jj" "Journal" entry
           (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
           "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
           ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
           :clock-in :clock-resume
           :empty-lines 1)
          ("jm" "Meeting" entry
           (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
           "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
           :clock-in :clock-resume
           :empty-lines 1)

          ("w" "Workflows")
          ("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
           "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

          ("m" "Metrics Capture")
          ("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org" "Weight")
           "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

  (define-key global-map (kbd "C-c j")
              (lambda () (interactive) (org-capture nil "jj")))
  )


(require 'org-super-agenda)

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator #x2501
      org-agenda-compact-blocks t
      org-agenda-start-with-log-mode t)
(setq org-agenda-deadline-faces
      '((1.0001 . org-warning)              ; due yesterday or before
        (0.0    . org-upcoming-deadline)))  ; due today or later



(defun style-org-agenda()
  (set-face-attribute 'org-agenda-date nil :height 1.1)
  (set-face-attribute 'org-agenda-date-today nil :height 1.1 :weight 'bold)
  (set-face-attribute 'org-agenda-date-weekend nil :height 1.1))

(add-hook 'org-agenda-mode-hook 'style-org-agenda)

(setq org-agenda-breadcrumbs-separator " ❱ "
      org-agenda-current-time-string " ┈┈┈┈┈┈┈┈┈┈┈┈┈ now"
      org-agenda-time-grid '((weekly today require-timed)
                             (800 1000 1200 1400 1600 1800 2000)
                             "---" "┈┈┈┈┈┈┈┈┈┈┈┈┈")
      org-agenda-prefix-format '((agenda . "%i %-12:c%?-12t%b% s")
                                 (todo . " %i %-12:c")
                                 (tags . " %i %-12:c")
                                 (search . " %i %-12:c")))

(setq org-agenda-format-date (lambda (date) (concat "\n" (make-string (window-width) 9472)
                                                    "\n"
                                                    (org-agenda-format-date-aligned date))))
(setq org-cycle-separator-lines 2)




(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                                :time-grid t
                                :date today
                                :todo "TODAY"
                                :scheduled today
                                :deadline today
                                :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '(;; Each group has an implicit boolean OR operator between its selectors.
                          (:name "Today"
                                 :face (:weight "semi-bold"))
                          (:name "Behind deadline"
                                 :and (:deadline past :todo ("TODO" "WAITING" "HOLD" "NEXT"))
                                 :face (:background "#7f1b19"))
                          (:name "Work important"
                                 :and (:priority>= "B" :category "Work" :todo ("TODO" "NEXT")))
                          (:name "Work other"
                                 :and (:category "Work" :todo ("TODO" "NEXT")))
                          (:name "Important"
                                 :priority "A")
                          (:priority<= "B"
                                       ;; Show this section after "Today" and "Important", because
                                       ;; their order is unspecified, defaulting to 0. Sections
                                       ;; are displayed lowest-number-first.
                                       :order 1)
                          (:name "Papers"
                                 :file-path "org/roam/notes")
                          (:name "Waiting"
                                 :todo "WAITING"
                                 :order 9)
                          (:name "On hold"
                                 :todo "HOLD"
                                 :order 10)))))))))
(add-hook 'org-agenda-mode-hook 'org-super-agenda-mode)


;; Minimal UI


(setq
 ;; Edit settings
 ;; org-auto-align-tags nil
 org-tags-column 0
 org-catch-invisible-edits 'show-and-error
 org-special-ctrl-a/e t
 org-insert-heading-respect-content t

 ;; Org styling, hide markup etc.
 org-hide-emphasis-markers t
 org-pretty-entities t
 org-ellipsis "…"

 ;; Agenda styling
 org-agenda-tags-column 0
 org-agenda-block-separator ?─
 org-agenda-time-grid
 '((daily today require-timed)
   (800 1000 1200 1400 1600 1800 2000)
   " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
 org-agenda-current-time-string
 "⭠ now ─────────────────────")

(global-org-modern-mode)


(use-package org-recur
  :hook ((org-mode . org-recur-mode)
         (org-agenda-mode . org-recur-agenda-mode))
  :demand t
  :config
  (define-key org-recur-mode-map (kbd "C-c d") 'org-recur-finish)

  ;; Rebind the 'd' key in org-agenda (default: `org-agenda-day-view').
  (define-key org-recur-agenda-mode-map (kbd "d") 'org-recur-finish)
  (define-key org-recur-agenda-mode-map (kbd "C-c d") 'org-recur-finish)

  (setq org-recur-finish-done t
        org-recur-finish-archive t))

;; Refresh org-agenda after rescheduling a task.
(defun org-agenda-refresh ()
  "Refresh all `org-agenda' buffers."
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (derived-mode-p 'org-agenda-mode)
        (org-agenda-maybe-redo)))))

(defadvice org-schedule (after refresh-agenda activate)
  "Refresh org-agenda."
  (org-agenda-refresh))

;; Log time a task was set to Done.
(setq org-log-done (quote time))

;; Don't log the time a task was rescheduled or redeadlined.
(setq org-log-redeadline nil)
(setq org-log-reschedule nil)

(setq org-read-date-prefer-future 'time)


#+end_src


#+begin_src emacs-lisp :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** General

Load libraries.

#+begin_src emacs-lisp

(require 'org-agenda)
(require 'org-agenda-property)

#+end_src

Open agenda(s)

#+begin_src emacs-lisp :prologue "" :epilogue ""

(bind-key "C-c a" #'org-agenda)

#+end_src

Files

#+begin_src emacs-lisp

(setq org-agenda-files (list "~/Documents/org-files/agenda/maths.org"
                             "~/Documents/org-files/agenda/leisure.org")
      org-agenda-diary-file (expand-file-name "diary" user-emacs-directory))

#+end_src

Settings

#+begin_src emacs-lisp

(setq org-agenda-window-setup 'current-window
      org-agenda-restore-windows-after-quit t
      org-agenda-show-all-dates nil
      org-agenda-time-in-grid t
      org-agenda-show-current-time-in-grid t
      org-agenda-start-on-weekday 1
      org-agenda-span 7
      org-agenda-hide-tags-regexp "." ; No tags
                                        ; org-agenda-hide-tags-regexp nil) ; All tags
      org-agenda-tags-column 0
                                        ; org-agenda-tags-column -79)      ; Left aling
      org-agenda-block-separator nil
      org-agenda-category-icon-alist nil
      org-agenda-skip-deadline-if-done t
      org-agenda-skip-scheduled-if-done t
      org-agenda-sticky t)

#+end_src

Prefix format

#+begin_src emacs-lisp

(setq org-agenda-prefix-format
      '((agenda . "%i %?-12t%s")
        (todo .   "%i")
        (tags .   "%i")
        (search . "%i")))

#+end_src

Sorting strategy

#+begin_src emacs-lisp

(setq org-agenda-sorting-strategy
      '((agenda deadline-down scheduled-down todo-state-up time-up
                habit-down priority-down category-keep)
        (todo   priority-down category-keep)
        (tags   timestamp-up priority-down category-keep)
        (search category-keep)))

#+end_src

Minimal time grid

#+begin_src emacs-lisp

(setq org-agenda-time-grid
      '((daily today require-timed)
        ()
        "......" "----------------"))

(setq org-agenda-current-time-string "   now")

#+end_src

A small function to cancel a meeting

#+begin_src emacs-lisp

(defun my-org-cancel-meeting ()
  (interactive)
  (org-entry-put (point) "CATEGORY" "cancelled")
  (org-entry-put (point) "NOTE" "Cancelled")
  (org-set-tags ":CANCELLED:"))

#+end_src

** Holidays :HOOK:PERSONAL:

#+begin_src emacs-lisp

(require 'cal-iso)
(require 'holidays)

(defvar french-holidays nil
  "French holidays")

(setq french-holidays
      `((holiday-fixed 1 1 "New year's Day")
	    (holiday-fixed 5 1 "Labour Day")
	    (holiday-fixed 5 8 "Victory in Europe Day")
	    (holiday-fixed 7 14 "Bastille day")
	    (holiday-fixed 8 15 "Assumption of Mary")
	    (holiday-fixed 11 11 "Armistice 1918")
	    (holiday-fixed 11 1 "All Saints' Day")
	    (holiday-fixed 12 25 "Christmas Day")
	    (holiday-easter-etc 0 "Easter Sunday")
        (holiday-easter-etc 1 "Easter Monday")
        (holiday-easter-etc 39 "Ascension Day")
        (holiday-easter-etc 50 "Whit Monday")
        (holiday-sexp
         '(if (equal
               (holiday-easter-etc 49)
               (holiday-float 5 0 -1 nil))
              (car (car (holiday-float 6 0 1 nil)))
            (car (car (holiday-float 5 0 -1 nil))))
         "Mother's Day")))

(setq calendar-holidays french-holidays     ; French holidays
      calendar-date-style 'european         ; European style calenders
      calendar-week-start-day '1            ; The week starts on Monday
      calendar-mark-diary-entries-flag nil) ; Do not show diary entries


(add-hook 'calendar-today-visible-hook  #'calendar-mark-today); Mark today in calendar

#+end_src

Week day name with holidays

#+name: my-org-agenda-format-date
#+begin_src emacs-lisp

(defun my-org-agenda-format-date (date)
  "Org agenda date format displaying holidays"
  (let* ((dayname (calendar-day-name date))
	     (day (cadr date))
	     (month (car date))
	     (monthname (calendar-month-name month))
	     (year (nth 2 date))
         (holidays (calendar-check-holidays date)))
    (concat "\n"
            dayname " "
            (format "%d " day)
            monthname " "
            (format "%d" year)
            (if holidays (format " (%s)" (nth 0 holidays)))
            "\n")))

(setq org-agenda-format-date #'my-org-agenda-format-date)

#+end_src

** Daily agenda :HOOK:ADVICE:BINDING:

The daily agenda

#+begin_src emacs-lisp

(add-to-list 'org-agenda-custom-commands
             '("a" "Agenda"
               ((agenda "Agenda"
                        ((org-agenda-todo-keyword-format "%s")
                         (org-agenda-skip-deadline-if-done nil)
                         (org-deadline-warning-days 3)
                         (org-agenda-overriding-header nil))))))

#+end_src

Some decorations for the agenda

#+name: my-org-agenda-highlight-todo
#+begin_src emacs-lisp

(defun my-org-agenda-highlight-todo (x)
  (let* ((done (string-match-p (regexp-quote ":DONE:") x))
         (canceled (string-match-p (regexp-quote "~") x))
         (x (replace-regexp-in-string ":TODO:" "" x))
         (x (replace-regexp-in-string ":DONE:" "" x))
         (x (replace-regexp-in-string "~" "" x))
         (x (if (and (boundp 'org-agenda-dim) org-agenda-dim)
                (propertize x 'face 'nano-faded) x))
         (x (if done (propertize x 'face 'nano-faded) x))
         (x (if canceled (propertize x 'face 'nano-faded) x)))
    x))

;;(advice-add 'org-agenda-highlight-todo
;;            :filter-return #'my-org-agenda-highlight-todo)

#+end_src

Timestamp tags for the agenda (bold means inverse video below):

now        -> *now*
9:00       -> *9h00*
9:30-10:00 -> 9h30 | *30mn*
-> ANYTIME

#+name: svg-tag-timestamp
#+begin_src emacs-lisp

(require 'svg-lib)
(require 'svg-tag-mode)

(defun my-svg-tag-timestamp (&rest args)
  "Create a timestamp SVG tag for the time at point."

  (interactive)
  (let ((inhibit-read-only t))

    (goto-char (point-min))
    (while (search-forward-regexp
            "\\(\([0-9]/[0-9]\):\\)" nil t)
      (set-text-properties (match-beginning 1) (match-end 1)
                           `(display ,(svg-tag-make "ANYTIME"
                                                    :face 'nano-faded
                                                    :inverse nil
                                                    :padding 3 :alignment 0))))

    (goto-char (point-min))
    (while (search-forward-regexp
            "\\([0-9]+:[0-9]+\\)\\(\\.+\\)" nil t)

      (set-text-properties (match-beginning 1) (match-end 2)
                           `(display ,(svg-tag-make (match-string 1)
                                                    :face 'nano-faded
                                                    :margin 4 :alignment 0))))

    (goto-char (point-min))
    (while (search-forward-regexp
            "\\([0-9]+:[0-9]+\\)\\(\\.*\\)" nil t)

      (set-text-properties (match-beginning 1) (match-end 2)
                           `(display ,(svg-tag-make (match-string 1)
                                                    :face 'nano-default
                                                    :inverse t
                                                    :margin 4 :alignment 0))))
    (goto-char (point-min))
    (while (search-forward-regexp
            "\\([0-9]+:[0-9]+\\)\\(-[0-9]+:[0-9]+\\)" nil t)
      (let* ((t1 (parse-time-string (match-string 1)))
             (t2 (parse-time-string (substring (match-string 2) 1)))
             (t1 (+ (* (nth 2 t1) 60) (nth 1 t1)))
             (t2 (+ (* (nth 2 t2) 60) (nth 1 t2)))
             (d  (- t2 t1)))

        (set-text-properties (match-beginning 1) (match-end 1)
                             `(display ,(svg-tag-make (match-string 1)
                                                      :face 'nano-faded
                                                      :crop-right t)))
        ;; 15m: ¼, 30m:½, 45m:¾
        (if (< d 60)
            (set-text-properties (match-beginning 2) (match-end 2)
                                 `(display ,(svg-tag-make (format "%2dm" d)
                                                          :face 'nano-faded
                                                          :crop-left t :inverse t)))
          (set-text-properties (match-beginning 2) (match-end 2)
                               `(display ,(svg-tag-make (format "%1dH" (/ d 60))
                                                        :face 'nano-faded
                                                        :crop-left t :inverse t
                                                        :padding 2 :alignment 0))))))))

#+end_src


#+begin_src emacs-lisp

(add-hook 'org-agenda-mode-hook #'my-svg-tag-timestamp)
(advice-add 'org-agenda-redo :after #'my-svg-tag-timestamp)

#+end_src

** Tasks agenda

A custom date format function using svg tags (progress pies) for the task agenda.

#+name: my-org-agenda-custom-date
#+begin_src emacs-lisp

(defun my-org-agenda-custom-date ()
  (interactive)
  (let* ((timestamp (org-entry-get nil "TIMESTAMP"))
         (timestamp (or timestamp (org-entry-get nil "DEADLINE"))))
    (if timestamp
        (let* ((delta (- (org-time-string-to-absolute (org-read-date nil nil timestamp))
                         (org-time-string-to-absolute (org-read-date nil nil ""))))
               (delta (/ (+ 1 delta) 30.0))
               (face (cond ;; ((< delta 0.25) 'nano-popout)
                      ;; ((< delta 0.50) 'nano-salient)
                      ((< delta 1.00) 'nano-default)
                      (t 'nano-faded))))
          (concat
           (propertize " " 'face nil
                       'display (svg-lib-progress-pie
                                 delta nil
                                 :background (face-background face nil 'default)
                                 :foreground (face-foreground face)
                                 :margin 0 :stroke 2 :padding 1))
           " "
           (propertize
            (format-time-string "%d/%m" (org-time-string-to-time timestamp))
            'face 'nano-popout)))
      "     ")))

#+end_src

The task agenda

#+begin_src emacs-lisp

(add-to-list 'org-agenda-custom-commands
             '("x" "Tasks"
               ((todo "TODO" ;; "PROJECT"
                      ( (org-agenda-todo-keyword-format ":%s:")
                        (org-agenda-prefix-format '((todo   . " ")))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp))
                        (org-agenda-overriding-header (propertize " Todo \n" 'face 'nano-strong))))

                (tags "+TALK+TIMESTAMP>=\"<now>\""
                      ((org-agenda-span 90)
                       (org-agenda-max-tags 5)
                       (org-agenda-prefix-format '((tags   . " %(my-org-agenda-custom-date) ")))
                       (org-agenda-overriding-header "\n Upcoming talks\n")))

                (tags ">TEACHING+TIMESTAMP=\"<now>\""
                      ((org-agenda-span 90)
                       (org-agenda-max-tags 5)
                       (org-agenda-prefix-format '((tags   . " %(my-org-agenda-custom-date) ")))
                       (org-agenda-overriding-header "\n Upcoming lessons\n")))

                (tags "TRAVEL+TIMESTAMP>=\"<now>\""
                      ((org-agenda-span 90)
                       (org-agenda-max-tags 5)
                       (org-agenda-prefix-format '((tags .  " %(my-org-agenda-custom-date) ")))
                       (org-agenda-overriding-header "\n Upcoming travels\n")))

                (tags "DEADLINE>=\"<today>\""
                      ((org-agenda-span 90)
                       (org-agenda-max-tags 5)
                       (org-agenda-prefix-format '((tags .  " %(my-org-agenda-custom-date) ")))
                       (org-agenda-overriding-header "\n Upcoming deadlines\n"))))))

#+end_src

** Update :TIMER:

We install a time to refresh the daily agenda (a) at regular intervals such that the current time is up to date.

#+begin_src emacs-lisp

(defvar my-org-agenda-update-delay 60)
(defvar my-org-agenda-update-timer nil)

(defun my-org-agenda-update ()
  "Refresh daily agenda view"

  (when my-org-agenda-update-timer
    (cancel-timer my-org-agenda-update-timer))

  (let ((window (get-buffer-window "*Org Agenda(a)*" t)))
    (when window
      (with-selected-window window
        (let ((inhibit-message t))
          (org-agenda-redo)))))

  (setq my-org-agenda-update-timer
        (run-with-idle-timer
         (time-add (current-idle-time) my-org-agenda-update-delay)
         nil
         'my-org-agenda-update)))

(run-with-idle-timer my-org-agenda-update-delay t 'my-org-agenda-update)

#+end_src

** Refile

Set refile targets according to my setup

#+begin_src emacs-lisp
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-use-outline-path nil)
(setq org-refile-targets
      '(
        ("~/Documents/org/agenda.org"    :maxlevel . 2)
        ("~/Documents/org/inbox.org"     :maxlevel . 1)
        ;;        ("~/Documents/org/organizer.org" :tag      . "tasks")
        ;;        ("~/Documents/org/organizer.org" :tag      . "notes")
        ;;        ("~/Documents/org/organizer.org" :tag      . "mails")
        ;;        ("~/Documents/org/organizer.org" :tag      . "meetings")
        ;;("~/Documents/org/archives.org" :maxlevel . 1)
        ))

#+end_src
** Capture :ADVICE:BINDING:

#+begin_src emacs-lisp :prologue "" :epilogue ""

(setq org-capture-templates
      '(("i" "Inbox"  entry   (file "inbox.org")
         "* TODO %?Task :INBOX:\n")

        ("m" "Meeting" entry  (file+headline "agenda.org" "Future")
         "* %?Meeting   <%<%Y-%m-%d %a 12:00-13:00>>"
         :empty-lines-after 1)))

#+end_src

Assign key

#+begin_src emacs-lisp :prologue "" :epilogue ""

(bind-key "C-c c" #'org-capture)

(defun my-org-capture-meeting ()
  (interactive)
  (org-capture nil "m"))

(bind-key "C-c m" #'my-org-capture-meeting)

(defun my-org-capture-inbox ()
  (interactive)
  (org-capture nil "i"))

(bind-key "C-c i" #'my-org-capture-inbox)

#+end_src

Here we orverwrite the [[help:org-capture-place-template][org-capture-place-template]] to have the capture window below the current one. There must be a better way to do that but I did not find it yet. Since we are in org-agenda deferred mode, we need to cancel epiloque/prologue.

#+begin_src emacs-lisp :prologue "" :epilogue ""

(with-eval-after-load 'org-capture

  (defun org-capture-place-template (&optional inhibit-wconf-store)
    "Insert the template at the target location, and display the buffer.
when `inhibit-wconf-store', don't store the window configuration, as it
may have been stored before."
    (unless inhibit-wconf-store
      (org-capture-put :return-to-wconf (current-window-configuration)))
    ;; (delete-other-windows)
    ;; (org-switch-to-buffer-other-window
    ;;  (org-capture-get-indirect-buffer (org-capture-get :buffer) "CAPTURE"))
    (select-window (split-window-below -6))
    (switch-to-buffer
     (org-capture-get-indirect-buffer (org-capture-get :buffer) "CAPTURE"))
    (widen)
    (org-show-all)
    (goto-char (org-capture-get :pos))
    (setq-local outline-level 'org-outline-level)
    (pcase (org-capture-get :type)
      ((or `nil `entry) (org-capture-place-entry))
      (`table-line (org-capture-place-table-line))
      (`plain (org-capture-place-plain-text))
      (`item (org-capture-place-item))
      (`checkitem (org-capture-place-item)))
    (setq-local org-capture-current-plist org-capture-plist)
    (org-capture-mode 1)))

#+end_src

** Capture 2 :ADVICE:BINDING:

#+begin_src emacs-lisp

(defun my-org-capture-frame (orig-fun &optional goto keys)
  (if (not (org-capture-get :description))
      (funcall orig-fun goto keys))
  (progn
    (select-frame (my-mini-frame 8))
    (let ((split-width-threshold nil)
          (split-height-threshold 0))
      (funcall orig-fun goto keys))
    (delete-other-windows)
    (setq word-wrap nil)
    (setq truncate-lines nil)
    (nano-modeline--update-selected-window)
    (let* ((left (concat (propertize " "
                                     'face '(nano-subtle)
                                     'display '(raise +0.20))
                         (propertize " Capture"
                                     'face '(nano-strong nano-subtle))
                         (propertize " "
                                     'face 'nano-subtle
                                     'display '(raise -0.30))
                         (propertize (org-capture-get :description)
                                     'face 'nano-default)))
           (right (propertize "C-c C-c: capture, C-c C-k: abort "
                              'face '(:inherit (nano-faded nano-subtle)
                                               :weight light)))
           (spacer (propertize (make-string (- (window-width)
                                               (length left)
                                               (length right)
                                               0) ?\ )
                               'face 'nano-subtle))
           (header (concat left spacer right " ")))
      (setq-local header-line-format header))

    (set-window-dedicated-p nil t)
    (set-frame-parameter (selected-frame) 'height 5)
    (face-remap-add-relative 'mode-line :background (face-background 'highlight))
    (save-excursion
      (goto-char (point-min))
      (let ((overlay (make-overlay
                      (line-beginning-position) (line-end-position))))
        (overlay-put overlay 'display '(raise -0.5))))))

#+end_src

#+begin_src emacs-lisp

(defun my-org-capture (goto key)
  (interactive)
  (unwind-protect
      (progn
        (advice-add 'org-capture :around #'my-org-capture-frame)
        (org-capture goto key))
    (advice-remove 'org-capture #'my-org-capture-frame)))

(require 'org-capture)

;; (bind-key "C-c m" #'(lambda ()
;;                       (interactive)
;;                       (my-org-capture nil "m")))

;; (bind-key "C-c i" #'(lambda ()
;;                       (interactive)
;;                       (my-org-capture nil "i")))

;; (bind-key "C-g" #'org-capture-kill 'org-capture-mode-map)

#+end_src

** Navigation :ADVICE:

The default [[help:org-agenda-goto][org-agenda-goto]], which is used when =tab= key is pressed or when follow mode (F) is active open a window at a non specific place. Here, we make sure the window is opened where we want. In this case, this is below the agenda window.

#+begin_src emacs-lisp

(defun my-org-agenda-goto (buffer args)
  "Open a headline in a window below the current window"

  (setq-local mode-line-format nil)
  (select-window (or (window-in-direction 'below (selected-window))
                     (split-window nil -6 'below)))
  (switch-to-buffer buffer)
  (setq-local header-line-format
              '((:eval
                 (let ((nano-modeline-prefix 'none)
                       (nano-modeline-prefix-padding 0)
                       (outline-path (org-with-point-at (org-get-at-bol'org-marker)
                                       (org-display-outline-path nil nil " » " t))))
                   (nano-modeline-render
                    ""
                    (file-name-nondirectory
                     (buffer-file-name (buffer-base-buffer)))
                    (format "/ %s" (substring-no-properties outline-path))
                    "")))))
  (selected-window))

#+end_src

Install the new function as an advice around [[help:org-agenda-goto][org-agenda-goto]] and apply a narrow to subtree after

#+begin_src emacs-lisp

(define-advice org-agenda-goto (:around (orig-fn &rest args) "my-org-agenda-goto")
  (let ((display-buffer-overriding-action '(my-org-agenda-goto)))
    (apply orig-fn args)
    (org-narrow-to-subtree)))

#+end_src


Finally, we disable [[help:org-agenda-show-outline-path][org-agenda-show-outline-path]] since this is now redundant with the header line.

#+begin_src emacs-lisp

(setq org-agenda-show-outline-path nil)

#+end_src

** Nano agenda :BINDING:

#+header: :prologue "" :epilogue ""
#+begin_src emacs-lisp

(bind-key "C-c n" #'nano-agenda)

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "Agenda")

#+end_src


* Versioning

#+begin_src emacs-lisp :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** Magit :ADVICE:HOOK:

Prevent magit from writing in the header line.

#+begin_src emacs-lisp

(advice-add 'magit-set-header-line-format :override #'ignore)

#+end_src

Add fringe on the left side of magit windows such that we can highlight region using the fringe.

#+begin_src emacs-lisp

(add-hook 'magit-mode-setup-hook
          #'(lambda ()
              (interactive)
              (set-window-fringes nil (* 2 (window-font-width)) 0)))

#+end_src
** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "Versioning")

#+end_src


* News :DEFER:
:PROPERTIES:
:header-args:emacs-lisp: :prologue "(with-eval-after-load 'elfeed" :epilogue ")"
:END:

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** Read :HOOK:BINDING:

Alternative print entry function using [[https://github.com/rougier/svg-tag-mode][svg-tag-mode]].

#+begin_src emacs-lisp

(require 'elfeed)
(require 'svg-tag-mode)

(defun my-elfeed-search-print-entry (entry)
  "Alternative printing of elfeed entries using SVG tags."

  (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title (or (elfeed-meta entry :title)
                    (elfeed-entry-title entry) ""))
         (unread (member 'unread (elfeed-entry-tags entry)))
         (feed (elfeed-entry-feed entry))
         (feed-title (when feed
                       (or (elfeed-meta feed :title)
                           (elfeed-feed-title feed))))
         (title-face (if unread 'nano-default 'nano-faded))
         (date-face (if unread 'nano-salient 'nano-faded))
         (feed-title-face (if unread 'nano-strong '(nano-strong nano-faded)))
         (tag-face (if unread 'nano-popout 'nano-faded))
         (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
         (tags (delete "unread" tags))
         (tags-svg (mapconcat
                    (lambda (s)
                      (propertize (concat (upcase s) " ")
                                  'display (svg-tag-make (upcase s)
                                                         :margin 0
                                                         :padding 1
                                                         :inverse 1
                                                         :face tag-face)))
                    tags " "))
         (left (concat
                (when feed-title
                  (propertize feed-title 'face feed-title-face))
                " " tags-svg " "
                (propertize title 'face title-face 'kbd-help title)))
         (right (propertize date 'face date-face)))
    (insert (my-string-join -1 left right))))

#+end_src

Elfeed setup.

#+begin_src emacs-lisp

(setq elfeed-search-title-max-width 80    ; Maximum titles width
      elfeed-search-title-min-width 40    ; Minimum titles width
      elfeed-search-trailing-width 24     ; Space reserved for feed & tag
      elfeed-search-filter                ; Default filter
      "@1-weeks-ago +unread"
      elfeed-search-print-entry-function  ; Alternative print function
      #'my-elfeed-search-print-entry)


                                        ; Bind "U" to update feeds on main screen
(bind-key "U" #'elfeed-update elfeed-search-mode-map)

#+end_src

Hook on elfeed main screen (hl-line mode).

#+name: my-elfeed-search-mode-hook
#+begin_src emacs-lisp

(defun my-elfeed-search-mode-hook ()
  (hl-line-mode t)
  (face-remap-add-relative 'hl-line :inherit 'nano-subtle)
  (set-window-fringes nil 0 1) ; One pixel right fringe to avoid ellipsis
  (setq cursor-type nil))

(add-hook 'elfeed-search-mode-hook  #'my-elfeed-search-mode-hook)

#+end_src

Hook on elfeed post screen (visual mode).

#+name: my-elfeed-show-mode-hook
#+begin_src emacs-lisp

(defun my-elfeed-show-mode-hook ()
  (visual-line-mode)
  ;;  (setq truncate-lines t)

  (let ((inhibit-read-only t)
        (inhibit-modification-hooks t))
    (setq-local truncate-lines nil)
    (setq-local shr-width 79)
    (set-buffer-modified-p nil)))

(add-hook 'elfeed-show-mode-hook #'my-elfeed-show-mode-hook)

#+end_src

** Bookmarks

Setup bookmarks ([[file:elfeed.org][elfeed.org]]) using [[https://github.com/remyhonig/elfeed-org][elfeed-org]]. It is important to load it after elfeed such as to not load org immediately.

#+begin_src emacs-lisp

(with-eval-after-load 'elfeed
  (require 'elfeed-org)
  (setq rmh-elfeed-org-files (list "~/.emacs.org/elfeed.org"))
  (elfeed-org))

#+end_src
** Elfeed-Dashboard

We give elfeed the mu4e looks and feel.

#+begin_src emacs-lisp
(use-package elfeed-dashboard
  :load-path "~/.emacs.d/lisp/elfeed-dashboard/"
  :config
  (setq elfeed-dashboard-file "~/.emacs.org/elfeed-dashboard.org")
  ;; update feed counts on elfeed-quit
  (advice-add 'elfeed-search-quit-window :after #'elfeed-dashboard-update-links))
#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

(my-report-time "News")

#+end_src


# * Notes (denote) :DEFER:
# :PROPERTIES:
# :header-args:emacs-lisp: :prologue "(with-eval-after-load 'denote" :epilogue ")"
# :END:

# #+begin_src emacs-lisp  :prologue "" :epilogue ""

# (setq my-section-start-time (current-time))

# #+end_src

# ** Configuration

# Samplet configuration from https://protesilaos.com/emacs/denote

# #+begin_src emacs-lisp

# (require 'denote)

# ;; Remember to check the doc strings of those variables.
# (setq denote-directory (expand-file-name "~/Documents/Denote/"))
# (setq denote-known-keywords
#       '("emacs" "research" "visualisation"))
# (setq denote-infer-keywords t)
# (setq denote-sort-keywords t)
# (setq denote-file-type nil) ; Org is the default, set others here

# ;; We allow multi-word keywords by default.  The author's personal
# ;; preference is for single-word keywords for a more rigid workflow.
# (setq denote-allow-multi-word-keywords t)

# (setq denote-front-matter-date-format nil) ; change this to `org-timestamp' or custom string

# ;; You will not need to `require' all those individually once the
# ;; package is available.
# (require 'denote-retrieve)
# (require 'denote-link)
# (require 'denote-dired)
# (setq denote-dired-rename-expert nil)

# ;; We use different ways to specify a path for demo purposes.
# (setq denote-dired-directories
#       (list denote-directory
#             (thread-last denote-directory (expand-file-name "attachments"))
#             (expand-file-name "~/Documents/vlog")))

# ;; Generic:
# ;; (add-hook 'dired-mode-hook #'denote-dired-mode)
# ;;
# ;; OR better:
# (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)

# ;; Here is a custom, user-level command from one of the examples we
# ;; showed in this manual.  We define it here and add it to a key binding
# ;; below.
# (defun my-denote-journal ()
#   "Create an entry tagged 'journal', while prompting for a title."
#   (interactive)
#   (denote
#    (denote--title-prompt)
#    "journal"))

# ;; Denote does not define any key bindings.  This is for the user to
# ;; decide.  For example:
# (let ((map global-map))
#   (define-key map (kbd "C-c n j") #'my-denote-journal) ; our custom command
#   (define-key map (kbd "C-c n n") #'denote)
#   (define-key map (kbd "C-c n N") #'denote-type)
#   (define-key map (kbd "C-c n d") #'denote-date)
#   ;; If you intend to use Denote with a variety of file types, it is
#   ;; easier to bind the link-related commands to the `global-map', as
#   ;; shown here.  Otherwise follow the same pattern for `org-mode-map',
#   ;; `markdown-mode-map', and/or `text-mode-map'.
#   (define-key map (kbd "C-c n i") #'denote-link) ; "insert" mnemonic
#   (define-key map (kbd "C-c n I") #'denote-link-add-links)
#   (define-key map (kbd "C-c n l") #'denote-link-find-file) ; "list" links
#   (define-key map (kbd "C-c n b") #'denote-link-backlinks)
#   ;; Note that `denote-dired-rename-file' can work from any context, not
#   ;; just Dired bufffers.  That is why we bind it here to the
#   ;; `global-map'.
#   (define-key map (kbd "C-c n r") #'denote-dired-rename-file))

# (with-eval-after-load 'org-capture
#   (require 'denote-org-capture)
#   (setq denote-org-capture-specifiers "%l\n%i\n%?")
#   (add-to-list 'org-capture-templates
#                '("n" "New note (with denote.el)" plain
#                  (file denote-last-path)
#                  #'denote-org-capture
#                  :no-save t
#                  :immediate-finish nil
#                  :kill-buffer t
#                  :jump-to-captured t)))

# #+end_src


# ** Benchmark

# #+begin_src emacs-lisp  :prologue "" :epilogue ""

# (my-report-time "Notes")

# #+end_src



# * Notes (deft) :DEFER:
# :PROPERTIES:
# :header-args:emacs-lisp: :prologue "(with-eval-after-load 'deft" :epilogue ")"
# :END:

# #+begin_src emacs-lisp  :prologue "" :epilogue ""

# (setq my-section-start-time (current-time))

# #+end_src

# ** Read :HOOK:BUGFIX:

# Deft setup

# #+begin_src emacs-lisp

# (setq deft-default-extension "org"
#       deft-extensions '("org")
#       deft-recursive nil
#       deft-use-filename-as-title nil
#       deft-use-filter-string-for-filename t
#       deft-file-naming-rules '((noslash . "-")
#                                (nospace . "-")
#                                (case-fn . downcase))
#       deft-separator " "
#       deft-time-format " %d %b %Y")

# #+end_src

# Rewrite the ~deft-print-header~ function to get rid of "Deft\n"

# #+begin_src emacs-lisp

# (defun deft-print-header ()
#   (force-mode-line-update))

# #+end_src

# Bug fix (see https://github.com/jrblevin/deft/issues/73)

# #+begin_src emacs-lisp

# (defun org-open-file-with-emacs (path)
#   (org-open-file path t))

# #+end_src

# A small bugfix for header that are too long by one character.

# #+begin_src emacs-lisp
# (defun deft-setup ()

#   (face-remap-add-relative 'hl-line :inherit 'nano-salient-i)
#   (set-window-fringes nil 0 1)
#   (set-default 'truncate-lines t))

# (add-hook 'deft-mode-hook #'deft-setup)

# #+end_src

# ** Keywords :ADVICE:

# #+begin_src emacs-lisp

# (defun my-deft-parse-summary (orig-fun contents title)
#   "Filter deft summary in order to extract the first dot
# terminated sentence and add tags if any."

#   (let ((summary (apply orig-fun (list contents title)))
#         (tags nil))
#     (when (and (stringp contents)
#                (string-match "#\\+TAGS:\\(.*\\)$" contents))
#       (setq tags (split-string (string-trim (match-string 1 contents))
#                                  "[ ,]")))
#     (if (and (stringp summary)
#              (string-match "\\(.*?\\)\\. " summary))
#         (concat
#          (when tags
#            (concat (propertize (car tags)
#                                'display (svg-tag-make (car tags)
#                                                       :face 'nano-popout
#                                                       :inverse t))
#                    " "))
#          (match-string 1 summary))
#       summary)))

# (advice-add 'deft-parse-summary :around #'my-deft-parse-summary)

# #+end_src


# #+begin_src emacs-lisp

# (defun deft-note-toggle-keywords ()
#   "Toggle visibility of all keywords."

#   (interactive)
#   (save-excursion
#     (goto-char (point-min))
#     (re-search-forward "^\\(#\\+.*\\)$" nil t)
#     (if (get-text-property (match-beginning 1) 'display)
#         (deft-note-show-keywords)
#       (deft-note-hide-keywords))))

# (defun deft-note-hide-keywords ()
#   "Hide all keywords."

#   (interactive)
#   (save-excursion
#     (goto-char (point-min))
#     (while (re-search-forward "^\\(#\\+.*\\)$" nil t)
#       ;; (message (format "Hiding keyword %s" (match-string 1)))
#       (put-text-property
#         (match-beginning 1) (+ (match-end 1) 1) 'display ""))))

# (defun deft-note-show-keywords ()
#   "Show all keywords."

#   (interactive)
#   (save-excursion
#     (goto-char (point-min))
#     (while (re-search-forward "^\\(#\\+.*\\)$" nil t)
#       ;; (message (format "Showing keyword %s" (match-string 1)))
#       (remove-text-properties
#         (match-beginning 1) (+ (match-end 1) 1) '(display)))))

# (defun deft-note-get-keyword (keyword)
#   "Get the value of a KEYWORD"

#   (interactive)
#   (let ((case-fold-search t)
#         (re (format "^#\\+%s:[ \t]+\\([^\t\n]+\\)" keyword)))
#     (if (save-excursion (or (re-search-forward re nil t)
#                             (re-search-backward re nil t)))
#         (substring-no-properties (match-string 1)))))

# (defun deft-note-set-keyword (keyword value)
#   "Set the VALUE of KEYWORD, creates it if absent."
#   (interactive)
#   (save-excursion
#     (goto-char (point-min))
#     (if (deft-note-get-keyword keyword)
#         (replace-match value t nil nil 1)
#       (insert (format "#+%s: %s\n" keyword value)))))

# #+end_src

# ** Write :HOOK:

# Setup note modes and ask for a title if the file does not exist

# #+begin_src emacs-lisp
# (defun my-deft-open-file ()
#   "Setup note modes and ask for a title if the file does not exist."

#   (when (= (buffer-size (current-buffer)) 0)
#     (setq title (read-from-minibuffer "Note title: "))
#     (deft-note-set-keyword "DATE" (format-time-string "[%Y-%m-%d %a]"))
#     (deft-note-set-keyword "TITLE" (if (> (length title) 0)
#                                        title
#                                      "New note"))
#     (org-mode)
#     (org-indent-mode)
#     (visual-line-mode)))

# (add-hook 'deft-open-file-hook 'my-deft-open-file)

# #+end_src

# ** Benchmark

# #+begin_src emacs-lisp  :prologue "" :epilogue ""

# (my-report-time "Notes")

# #+end_src


* System
#+begin_src emacs-lisp  :prologue "" :epilogue ""

(setq my-section-start-time (current-time))

#+end_src

** Term & shell :ADVICE:

Set default shell (zsh)

#+begin_src emacs-lisp

(setq-default shell-file-name          "/bin/zsh"
              explicit-shell-file-name "/bin/zsh")

#+end_src

Make sure our environment variables are set properly

#+begin_src emacs-lisp

;; (require 'exec-path-from-shell)
;; (exec-path-from-shell-copy-envs '("LANG" "LC_ALL" "LC_CTYPES"))

#+end_src


Kill term buffer when exiting.

#+begin_src emacs-lisp

(defun my-term-handle-exit (&optional proc msg)
  "Kill term buffer (advice)."

  (message "%s | %s" proc msg)
  (kill-buffer (current-buffer)))

(advice-add 'term-handle-exit :after 'my-term-handle-exit)

#+end_src

** OSX :OS:

Open an iterm (OSX) and go to the curent directory

#+begin_src emacs-lisp

  (defun my-iterm-here ()
    (interactive)

    (shell-command "open -a iTerm $PWD" nil nil))

#+end_src

** Benchmark

#+begin_src emacs-lisp  :prologue "" :epilogue ""

  (my-report-time "System")

#+end_src


* TODO Miscellaneous
For all the small additional goodies that make life a bit easier.
** Spotify
We use smudge to control spotify from within emacs.

#+begin_src emacs-lisp
  (use-package smudge
    :custom
    (setq smudge-oauth2-client-secret "307ee557e2724f4c966b76cb343403a5"
          smudge-oauth2-client-id "8af15fa300304341a0e1bcbe09165e27")
    :bind
    (("<f7>" . smudge-controller-toggle-play)
     ("<f8>" . smudge-controller-next-track)
     ;; :map smudge-command-map
     ;; ("RET" . smudge-track-select)
     )
    )
#+end_src

* Finishing up
** TODO Some cosmetics
We use our customisation of the nano theme.
#+begin_src emacs-lisp
(use-package lambda-themes
  :straight (:type git :host github :repo "lambda-emacs/lambda-themes")
  :custom
  (lambda-themes-set-italic-comments t)
  (lambda-themes-set-italic-keywords t)
  (lambda-themes-set-variable-pitch t)
  :config
  ;; load preferred theme
  (load-theme 'lambda-light))

(my-nano-light-muted)
#+end_src
** Final report

#+begin_src emacs-lisp

  (let ((init-time (float-time (time-subtract (current-time) my-init-start-time)))
        (total-time (string-to-number (emacs-init-time "%f"))))

    (message "---------------------------------------------------------------")
    (message "Initialisation time:                 %.2fs (+ %.2f system time)"
             init-time (- total-time init-time)))
  (message "---------------------------------------------------------------")

#+end_src

* NOT YET INTEGRATED

#+begin_src emacs-lisp

;; (use-package emacs
;;   :init (column-number-mode)
;;   )

;; (global-visual-line-mode 1); Proper line wrapping
;; (setq visible-bell t); Flashes on error

;; (savehist-mode 1)
;; (setq save-interprogram-paste-before-kill t ; clipboard text is saved to the kill-ring
;;       apropos-do-all t
;;       ediff-window-setup-function 'ediff-setup-windows-plain)

(define-key key-translation-map (kbd "<AltGr>") (kbd "<menu>")) ;; To allow for menu modifier on laptops
(bind-key (kbd "C-)") nil 'ergoemacs-override-keymap)
(bind-key (kbd "M-<right>") nil 'ergoemacs-override-keymap)
(bind-key (kbd "M-<left>") nil 'ergoemacs-override-keymap)

(require 'all-the-icons)      ;; Better handeling of icons
(require 'projectile)         ;; Projectile offers a 'project-based' logic

;; Where the projects are to be searched
(setq projectile-project-search-path '(("~/Documents/mathematics/research/" . 3)))


(let ((init-time (float-time (time-subtract (current-time) my-init-start-time)))
      (total-time (string-to-number (emacs-init-time "%f"))))

  (message "---------------------------------------------------------------")
  (message "Final initialisation time:             %.2fs (+ %.2f system time)"
           init-time (- total-time init-time)))
(message "---------------------------------------------------------------")
#+end_src
